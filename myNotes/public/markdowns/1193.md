

# üî∑ MySQL Indexes & Query Optimization

Indexes are fundamental to **query performance optimization** in MySQL. They serve the same purpose as an index in a book ‚Äî instead of scanning every row in a table (full table scan), MySQL can quickly locate the required rows using the index structure. At Enterprise-level scale (billions of rows, complex joins, high concurrency), **choosing the right index strategy** often determines whether queries take milliseconds or hours.

---

## 1. Concept of Indexes in MySQL

* An **index** is a **data structure (typically a B+Tree in InnoDB)** that maintains a sorted order of one or more columns.
* MySQL can traverse this index to quickly locate rows, rather than scanning all rows.
* Indexes also help optimize:

  * **WHERE clauses** (`SELECT * FROM users WHERE email = ?`)
  * **JOINs** (indexed foreign keys improve lookup speed)
  * **ORDER BY / GROUP BY**
  * **Covering queries** (when index stores all required columns, eliminating table lookup)

üëâ Without an index: O(N) full scan.
üëâ With an index: O(log N) search + O(k) fetch.

---

## 2. Types of Indexes

### ‚úÖ Single-Column Index

* Built on **one column**.
* Best for queries where **filtering/searching happens on that one column**.
* Example:

  ```sql
  CREATE INDEX idx_email ON users(email);
  ```

  Optimizes:

  ```sql
  SELECT * FROM users WHERE email = 'x@example.com';
  ```

### ‚úÖ Composite (Multi-Column) Index

* Built on **two or more columns in defined order**.

* Example:

  ```sql
  CREATE INDEX idx_user_city_age ON users(city, age);
  ```

  Optimizes queries like:

  ```sql
  SELECT * FROM users WHERE city = 'Berlin' AND age = 25;
  SELECT * FROM users WHERE city = 'Berlin'; -- works (leftmost column rule)
  ```

  ‚ö†Ô∏è **But not:**

  ```sql
  SELECT * FROM users WHERE age = 25; -- index skipped
  ```

* **Leftmost Prefix Rule**: MySQL can only use the index if the query filters on the **leading column(s)** of the index in sequence.

---

## 3. Single vs Composite Index ‚Äî Trade-offs

| Aspect             | Single Index                                                     | Composite Index                                 |
| ------------------ | ---------------------------------------------------------------- | ----------------------------------------------- |
| **Best for**       | Queries filtering on a single column                             | Queries filtering on multiple columns together  |
| **Storage**        | Uses less space                                                  | Larger size, but avoids multiple lookups        |
| **Flexibility**    | Works for one column only                                        | Can handle subsets of columns (left-to-right)   |
| **Query Coverage** | Must combine multiple indexes using index merge (less efficient) | More efficient if query matches column sequence |
| **Example**        | `users(email)`                                                   | `users(city, age)`                              |

---

## 4. Query Optimization with Indexes

### üîπ When MySQL Uses Indexes

* `WHERE` filters
* `JOIN ON` conditions
* `ORDER BY` (if aligned with index order)
* `GROUP BY`
* Covering index queries (all SELECTed columns are inside index)

### üîπ When Indexes Fail

* Using functions on indexed column:

  ```sql
  WHERE LOWER(email) = 'abc@example.com'; -- index not used
  ```
* Non-leading columns in composite index.
* Low-selectivity columns (e.g., `gender`, `status` with few distinct values).
* Too many indexes ‚Üí slows down `INSERT/UPDATE/DELETE` (because each write must update multiple indexes).

### üîπ Index Merge

MySQL can **combine multiple single indexes** (using union/intersection), but it‚Äôs slower than a well-designed composite index.
Example:
If you have `INDEX(city)` and `INDEX(age)`, MySQL can merge them for:

```sql
WHERE city = 'Berlin' AND age = 25
```

But performance < composite `(city, age)` index.

---

## 5. Advanced Optimization Patterns

* **Covering Indexes**:
  Include all queried columns in index ‚Üí MySQL answers query from index alone (avoids table I/O).

  ```sql
  CREATE INDEX idx_city_age_salary ON employees(city, age, salary);
  SELECT city, age, salary FROM employees WHERE city='NY' AND age=30;
  ```
* **Index Selectivity**:
  High selectivity (unique or near-unique values) = better performance.
  Indexing a column like `status` (`active/inactive`) is wasteful.
* **Prefix Indexing** (for long strings):

  ```sql
  CREATE INDEX idx_partial_email ON users(email(10));
  ```

  Useful when full string is long (e.g., URLs, emails).
* **Composite Index Ordering**:
  Place most selective column first for optimal performance.
* **EXPLAIN**:
  Always analyze queries with:

  ```sql
  EXPLAIN SELECT ...
  ```

  to check index usage, access type (`ALL`, `INDEX`, `REF`, `RANGE`, `CONST`).

---

## 6. Real-World Example (Enterprise-Level Scale)

Suppose you have a table:

```sql
users(id PK, email, city, age, last_login)
```

### Bad Index Strategy

* Index on `email`
* Index on `city`
* Index on `age`

Query:

```sql
SELECT * FROM users WHERE city='Berlin' AND age=25 ORDER BY last_login DESC;
```

üëâ MySQL may do index merge (city + age), then filesort for `last_login`.

### Optimized Composite Index

```sql
CREATE INDEX idx_city_age_lastlogin ON users(city, age, last_login DESC);
```

üëâ MySQL directly fetches rows in sorted order, avoiding filesort.

---

## 7. Best Practices

* Use **composite indexes** for multi-column queries rather than multiple single indexes.
* Follow **leftmost prefix rule** carefully.
* Avoid indexing **low-cardinality** columns (e.g., gender).
* Keep indexes **small** ‚Äî large indexes slow down writes.
* Use **covering indexes** for hot queries.
* Regularly check with:

  ```sql
  SHOW INDEXES FROM table;
  EXPLAIN SELECT ...
  ```
* Monitor slow queries (`slow_query_log`, `performance_schema`).

---

## 8. Interview-Level Key Points

1. Explain **B+Tree index** vs Hash index (MySQL MEMORY engine supports hash).
2. Leftmost prefix rule in composite indexes.
3. Trade-off between read vs write performance with many indexes.
4. Covering indexes and when they eliminate table lookups.
5. How MySQL chooses indexes (`optimizer_cost`).
6. Why index selectivity matters.
7. Role of clustered index in InnoDB (`PRIMARY KEY` defines row storage order).
8. Why composite indexes beat index merge for multi-column queries.

---

‚úÖ This above note covers **theory, practical trade-offs, optimization techniques, and interview-relevant insights** at Enterprise level.

---

## **Code-based case studies** 



# üî∑ Case Study 1 ‚Äî Equality filter + sort ‚Üí composite covering index

## Schema & sample data

```sql
CREATE TABLE users (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  email VARCHAR(255) NOT NULL,
  city VARCHAR(64) NOT NULL,
  age INT NOT NULL,
  last_login DATETIME NOT NULL,
  salary INT NOT NULL,
  KEY idx_city (city),
  KEY idx_age (age)
) ENGINE=InnoDB;

-- ~5‚Äì20M rows in real life; for demo, just imagine it‚Äôs large.
```

## Slow query (filesort + index merge)

```sql
SELECT city, age, last_login, salary
FROM users
WHERE city = 'Berlin' AND age = 25
ORDER BY last_login DESC
LIMIT 50;
```

### EXPLAIN (typical)

```
id: 1 | select_type: SIMPLE | table: users | type: index_merge 
possible_keys: idx_city,idx_age 
key: idx_city,idx_age | key_len: 258,4 
rows: ~200000 | Extra: Using union(idx_city,idx_age); Using where; Using filesort
```

**Symptoms**: `index_merge` + `Using filesort` ‚Üí scans/merges two single indexes, sorts result on `last_login`.

## Fix: a composite **covering** index in sort order

```sql
DROP INDEX idx_city ON users;
DROP INDEX idx_age ON users;
CREATE INDEX idx_city_age_lastlogin_salary 
  ON users(city, age, last_login DESC, salary);
```

### Improved EXPLAIN

```
type: ref | key: idx_city_age_lastlogin_salary | rows: ~300 
Extra: Using index
```

**Why it‚Äôs faster**: (1) **leftmost prefix** fits (`city`,`age`), (2) data already in `last_login DESC` ‚Üí no filesort, (3) **covering** (`city,age,last_login,salary`) ‚Üí no table lookup.

**Validate**

```sql
EXPLAIN ANALYZE
SELECT city, age, last_login, salary
FROM users
WHERE city='Berlin' AND age=25
ORDER BY last_login DESC
LIMIT 50;
-- Expect: few rows examined, no filesort, index only.
```

---

# üî∑ Case Study 2 ‚Äî Range + ORDER BY alignment

## Schema

```sql
CREATE TABLE orders (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  status TINYINT NOT NULL,       -- 0..5
  created_at DATETIME NOT NULL,
  KEY idx_user (user_id),
  KEY idx_status (status),
  KEY idx_created (created_at)
) ENGINE=InnoDB;
```

## Slow query (range + filesort)

```sql
SELECT id, user_id, status, created_at
FROM orders
WHERE user_id = 42
  AND created_at >= '2025-08-01'
ORDER BY created_at ASC
LIMIT 100;
```

### EXPLAIN (typical)

```
type: ref | key: idx_user | rows: ~80000 
Extra: Using where; Using filesort
```

## Fix: composite index matching filter ‚Üí sort column last

```sql
CREATE INDEX idx_user_created ON orders(user_id, created_at);
```

### Improved EXPLAIN

```
type: range | key: idx_user_created | rows: ~200 
Extra: Using where
```

**Why**: Predicate `(user_id=const AND created_at>=const)` matches the **leftmost prefix**; index order satisfies `ORDER BY` ‚Üí **no filesort**.

**Validate**

```sql
EXPLAIN ANALYZE
SELECT id, user_id, status, created_at
FROM orders
WHERE user_id=42 AND created_at>='2025-08-01'
ORDER BY created_at
LIMIT 100;
```

---

# üî∑ Case Study 3 ‚Äî JOIN hotspot ‚Üí indexes on join keys + filter key order

## Schema

```sql
CREATE TABLE customers (
  id BIGINT PRIMARY KEY,
  email VARCHAR(255) NOT NULL,
  city VARCHAR(64) NOT NULL,
  KEY idx_city (city)
) ENGINE=InnoDB;

CREATE TABLE tickets (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  customer_id BIGINT NOT NULL,
  priority TINYINT NOT NULL,
  status TINYINT NOT NULL,
  created_at DATETIME NOT NULL,
  KEY idx_status (status),
  KEY idx_created (created_at),
  KEY idx_customer (customer_id)
) ENGINE=InnoDB;
```

## Slow join

```sql
SELECT t.id, t.priority, t.status, t.created_at
FROM tickets t
JOIN customers c ON c.id = t.customer_id
WHERE c.city = 'Bengaluru' AND t.status = 1
ORDER BY t.created_at DESC
LIMIT 50;
```

### EXPLAIN (typical)

```
1: table c | type: ref  | key: idx_city | rows: ~200k | Extra: Using where
1: table t | type: ref  | key: idx_customer | rows: ~5M  | Extra: Using where; Using filesort
```

**Symptoms**: Large probe into `tickets` per city match; `Using filesort`.

## Fixes

1. **Composite index** on probe side aligned with join + filter + order:

```sql
CREATE INDEX idx_customer_status_created 
  ON tickets(customer_id, status, created_at DESC);
```

2. (Optional) **Narrowing first table**: if `status` has higher selectivity than `city`, you can drive from `tickets` first:

```sql
-- Force by rewriting (semi-join) if needed:
SELECT t.id, t.priority, t.status, t.created_at
FROM tickets t
WHERE t.status = 1
  AND EXISTS (
    SELECT 1 FROM customers c 
    WHERE c.id=t.customer_id AND c.city='Bengaluru'
  )
ORDER BY t.created_at DESC
LIMIT 50;
```

### Improved EXPLAIN

```
table c ‚Üí rows: ~200k (unchanged)
table t ‚Üí type: ref | key: idx_customer_status_created | rows: ~500 
Extra: Using where
```

**Why**: Index starts at `customer_id` (join), then `status` (filter), then `created_at DESC` (order) ‚Üí **no filesort** and far fewer row touches.

**Validate**

```sql
EXPLAIN ANALYZE /* original vs new */
```

---

# üî∑ Case Study 4 ‚Äî Covering index vs table lookups (QPS booster)

## Schema

```sql
CREATE TABLE impressions (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  campaign_id BIGINT NOT NULL,
  device TINYINT NOT NULL, -- 0:desktop,1:mobile, etc.
  ts DATETIME NOT NULL,
  cost_cents INT NOT NULL,
  KEY idx_campaign (campaign_id),
  KEY idx_ts (ts)
) ENGINE=InnoDB;
```

## Hot query (read-mostly workload)

```sql
SELECT campaign_id, device, ts, cost_cents
FROM impressions
WHERE campaign_id = 987
  AND ts >= '2025-08-01' AND ts < '2025-08-20'
ORDER BY ts
LIMIT 1000;
```

### EXPLAIN (typical)

```
type: ref | key: idx_campaign | rows: ~1,000,000 
Extra: Using where; Using filesort
```

**Symptoms**: Index on `campaign_id` filters, but then **back to table** for columns and **filesort** on `ts`.

## Fix: composite **covering** index in ts order

```sql
CREATE INDEX idx_campaign_ts_device_cost 
  ON impressions(campaign_id, ts, device, cost_cents);
```

### Improved EXPLAIN

```
type: range | key: idx_campaign_ts_device_cost | rows: ~50k 
Extra: Using index
```

**Why**: (1) Matching predicate `(campaign_id, ts-range)`; (2) `ORDER BY ts` matches index order; (3) all selected columns in index ‚Üí **no table I/O**.

**Validate**

```sql
EXPLAIN ANALYZE
SELECT campaign_id, device, ts, cost_cents
FROM impressions
WHERE campaign_id=987 AND ts>='2025-08-01' AND ts<'2025-08-20'
ORDER BY ts
LIMIT 1000;
```

---

# üî∑ Case Study 5 ‚Äî Long VARCHARS ‚Üí prefix index + uniqueness safety

## Schema

```sql
CREATE TABLE urls (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  long_url VARCHAR(2048) NOT NULL,
  created_at DATETIME NOT NULL,
  UNIQUE KEY uniq_full_long_url (long_url(255)),     -- prefix unique
  KEY idx_created (created_at)
) ENGINE=InnoDB;
```

## Query

```sql
SELECT id
FROM urls
WHERE long_url = 'https://very.long.example/...'
LIMIT 1;
```

### EXPLAIN (with full-length index absent)

```
type: ALL | rows: large | Extra: Using where
```

## Fix: **prefix** index large enough to remain selective (balance memory & collisions)

```sql
-- Already applied above as uniq_full_long_url (long_url(255))
```

### After EXPLAIN

```
type: ref | key: uniq_full_long_url | rows: 1 | Extra: Using where
```

**Caveats**

* Prefix indexes **cannot** fully cover when you select the full string (engine still validates equality).
* Pick prefix length via empirical selectivity tests:

```sql
SELECT COUNT(DISTINCT LEFT(long_url, 64)) / COUNT(*) AS sel64,
       COUNT(DISTINCT LEFT(long_url,128)) / COUNT(*) AS sel128,
       COUNT(DISTINCT LEFT(long_url,255)) / COUNT(*) AS sel255
FROM urls;
```

---

# üî∑ Case Study 6 ‚Äî Function on indexed column ‚Üí generated column + index

## Schema

```sql
CREATE TABLE users2 (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  email VARCHAR(255) NOT NULL
) ENGINE=InnoDB;

-- Slow pattern (function prevents index usage):
-- WHERE LOWER(email) = 'x@y.com'
```

## Fix: **functional index** via persisted generated column (MySQL 8.0+)

```sql
ALTER TABLE users2
  ADD email_lc VARCHAR(255) AS (LOWER(email)) STORED,
  ADD INDEX idx_email_lc (email_lc);

-- Now this is sargable:
SELECT id FROM users2 WHERE email_lc = 'x@y.com';
```

### EXPLAIN

```
type: ref | key: idx_email_lc | rows: ~1 | Extra: Using index condition
```

---

# üî∑ Case Study 7 ‚Äî GROUP BY rollups: composite index for aggregation

## Schema

```sql
CREATE TABLE events (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  app_id INT NOT NULL,
  event_type TINYINT NOT NULL,
  ts DATETIME NOT NULL,
  KEY idx_app_ts (app_id, ts)
) ENGINE=InnoDB;
```

## Slow aggregation

```sql
SELECT app_id, DATE(ts) AS d, COUNT(*) AS c
FROM events
WHERE app_id = 17
  AND ts >= '2025-08-01' AND ts < '2025-08-20'
GROUP BY app_id, d
ORDER BY d;
```

### EXPLAIN (before)

```
type: range | key: idx_app_ts | rows: ~3,000,000 
Extra: Using where; Using temporary; Using filesort
```

## Fixes

1. Add a generated column for date **bucket** and index it:

```sql
ALTER TABLE events
  ADD ts_date DATE AS (DATE(ts)) STORED,
  ADD INDEX idx_app_tsdate (app_id, ts_date);
```

2. Rewrite to use the bucket:

```sql
SELECT app_id, ts_date AS d, COUNT(*) AS c
FROM events
WHERE app_id = 17
  AND ts_date BETWEEN '2025-08-01' AND '2025-08-20'
GROUP BY app_id, ts_date
ORDER BY ts_date;
```

### EXPLAIN (after)

```
type: range | key: idx_app_tsdate | rows: ~200k 
Extra: Using index for group-by
```

**Why**: Grouping keys align with index order ‚Üí avoids temp/filesort; MySQL can perform **loose index scan** patterns.

---

## üîß Repro & Measurement Checklist (use these in interviews)

1. **Turn on slow query tools**

```sql
SET SESSION optimizer_switch='use_invisible_indexes=on';
SET SESSION sql_select_limit=DEFAULT;

-- MySQL 8.0.18+
EXPLAIN ANALYZE SELECT ...;
```

2. **Check index usage**

```sql
EXPLAIN FORMAT=TRADITIONAL SELECT ...;
SHOW INDEX FROM <table>;
```

3. **Look for red flags in EXTRAS**

* `Using where; Using filesort`
* `Using temporary`
* `index_merge`
* `type: ALL` (full table scan) or `range` where `ref/eq_ref` is expected
* very high `rows` estimate relative to selectivity

4. **General index ordering rules of thumb**

* **Equality** columns ‚Üí **first**
* Then **range** columns
* Then **ORDER BY** columns (same direction)
* Add **covering** columns at the tail (only those selected frequently)

5. **Validate after change**

* `EXPLAIN` moves from `ALL/index_merge/filesort` ‚Üí to `ref/range` without filesort/temp.
* `EXPLAIN ANALYZE` shows **rows examined** ‚Üì and **execution time** ‚Üì.

---

## ‚ö†Ô∏è Gotchas to mention in interviews

* Too many indexes **hurt writes** (each INSERT/UPDATE/DELETE pays index maintenance).
* Composite index **respects leftmost prefix** only.
* `OR` predicates often break sargability; consider `UNION ALL` or boolean algebra rewrites.
* **Collation/charset** differences can prevent index usage on string comparisons.
* `IN` vs `=`: both sargable, but big `IN` lists can degrade estimates‚Äîconsider temp tables.
* **Cardinality drift**: refresh histograms (`ANALYZE TABLE`) for better plans on skewed data.

