
# **`this` Binding Rules — Complete Overview**

---

## **1. The Five Rules of `this` Binding**

### **Rule 1: Default Binding (Fallback Rule)**

* Applies when function is called in **standalone mode** (not as a method).
* **Non-strict mode** → `this` = global object (`window` in browsers, `global` in Node.js).
* **Strict mode** → `this` = `undefined`.

```js
function show() { console.log(this); }
show(); // window / undefined (strict)
```

---

### **Rule 2: Implicit Binding**

* Applies when function is called **as a property of an object**.
* `this` is set to the object **before the dot** at call time.

```js
const user = { name: 'Ava', greet() { console.log(this.name); } };
user.greet(); // Ava
```

⚠ **Losing `this`**: If method is extracted, implicit binding is lost.

```js
const greetFn = user.greet;
greetFn(); // undefined
```

---

### **Rule 3: Explicit Binding**

* Use `.call()`, `.apply()`, `.bind()` to **manually set** `this`.

```js
function greet(greeting) { console.log(greeting, this.name); }
const user = { name: 'Ava' };

greet.call(user, 'Hi');   // Hi Ava
greet.apply(user, ['Hi']); // Hi Ava
const bound = greet.bind(user);
bound('Hi');               // Hi Ava
```

---

### **Rule 4: `new` Binding**

* When called with `new`, a **new object** is created and `this` points to it.

```js
function Person(name) { this.name = name; }
const p = new Person('Ava');
console.log(p.name); // Ava
```

---

### **Rule 5: Arrow Function Binding**

* Arrow functions **don’t have their own `this`**; they **lexically inherit** it from surrounding scope.
* Cannot be changed with `.call()`, `.apply()`, or `.bind()`.

```js
const obj = {
  name: 'Ava',
  greet: () => console.log(this.name) // from outer scope
};
obj.greet(); // undefined
```

---

## **2. `this` Binding Precedence**

📌 **Highest to Lowest**:

1. **`new` Binding**
2. **Explicit Binding** (`bind`, `call`, `apply`)
3. **Implicit Binding** (object before dot)
4. **Default Binding**
5. **Arrow Functions** (special case — lexical `this`)

---

## **3. Combined Example**

```js
function foo() { console.log(this.a); }
const obj1 = { a: 2, foo };
const obj2 = { a: 3 };

obj1.foo();             // 2 (implicit)
obj1.foo.call(obj2);    // 3 (explicit)
new obj1.foo();         // undefined (new binding)
(() => console.log(this.a)).call(obj2); // from outer scope
```

---

## **4. Visual Flow Diagram**

```
               ┌───────────────────────────────┐
               │  Is function called with new?  │
               └─────────────┬─────────────────┘
                             Yes → new binding
                             No
               ┌───────────────────────────────┐
               │  Is call site using .call/.apply/.bind? │
               └─────────────┬─────────────────┘
                             Yes → explicit binding
                             No
               ┌───────────────────────────────┐
               │  Is function called as obj method?  │
               └─────────────┬─────────────────┘
                             Yes → implicit binding
                             No
               ┌───────────────────────────────┐
               │  Is function an arrow function? │
               └─────────────┬─────────────────┘
                             Yes → lexical binding
                             No
                             ↓
                        default binding
```

---

## **5. Interview Traps**

* **Lost `this`**: Passing methods as callbacks without binding.
* **Arrow vs Normal**: Arrow functions in object literals inherit from surrounding scope — not the object.
* **`bind()` Return**: `bind` returns a **new function** — ignoring it means binding has no effect.
* **Mixing Rules**: `new` binding overrides implicit/explicit binding.


