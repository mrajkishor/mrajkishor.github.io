

# ðŸ”¹ Prime Numbers

---

## 1. **Concept**

* A **prime number** is a natural number greater than 1 that has **exactly two divisors**:

  * 1
  * itself

ðŸ‘‰ Example:

* 7 is prime because its only divisors are {1, 7}.
* 8 is not prime because its divisors are {1, 2, 4, 8}.

The opposite of a prime is a **composite number** (any number >1 that has more than two divisors).

---

## 2. **Smallest Cases**

* **1** is **not** a prime (it has only one divisor: itself).
* **2** is the smallest and the only **even prime**.
* All other even numbers are composite since they are divisible by 2.

---

## 3. **Properties of Primes**

1. Every integer >1 is either prime or can be expressed as a product of primes (Fundamental Theorem of Arithmetic).
2. Except for 2 and 3, all primes are of the form **6k Â± 1** (though not all 6kÂ±1 are primes).
3. If a number `n` is not prime, it must have a factor â‰¤ âˆšn.

   * Example: To check if 37 is prime, you only test divisibility up to âˆš37 â‰ˆ 6.
4. Distribution of primes is irregular, but ==primes **get less frequent** as numbers grow.==

---

## 4. **Examples**

* First 10 primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}
* First 10 composites = {4, 6, 8, 9, 10, 12, 14, 15, 16, 18}

---

## 5. **Applications of Primes**

* **Cryptography** â†’ RSA encryption relies on factoring very large numbers into primes.
* **Computer Science** â†’ Hash functions, pseudo-random number generators.
* **Mathematics** â†’ Building blocks of all numbers (prime factorization).
* **Signal Processing** â†’ FFT algorithms use properties of primes in modular arithmetic.

---

## 6. **Famous Results About Primes**

1. **Euclidâ€™s Theorem**: There are infinitely many primes.
2. **Twin Primes**: Pairs like (11,13), (17,19). It is still unproven whether infinitely many exist.
3. **Mersenne Primes**: Of the form $2^p - 1$, linked to perfect numbers.
4. **Prime Number Theorem**: Approximate count of primes up to `n` is:

   $$
   \pi(n) \sim \frac{n}{\ln(n)}
   $$

---

## 7. **Prime Checking (Algorithms)**

### a) Naive

* Check divisibility from 2 to n-1.
* Complexity: O(n) (slow).

### b) âˆšn Method (efficient for single numbers)

* Check divisibility from 2 to âˆšn.
* Complexity: O(âˆšn).

### c) Sieve of Eratosthenes

* Generate all primes â‰¤ N efficiently.
* Complexity: O(N log log N).
* Example: Mark multiples of 2, then 3, then 5, etc.

### d) Advanced (for very large primes)

* Miller-Rabin primality test (probabilistic).
* AKS primality test (deterministic, but slower in practice).

---

## 8. **Java Code Examples**

### a) Check if a number is prime (âˆšn method)

```java
public class PrimeCheck {
    public static boolean isPrime(int n) {
        if (n <= 1) return false;
        if (n == 2 || n == 3) return true;
        if (n % 2 == 0) return false;

        for (int i = 3; i * i <= n; i += 2) {
            if (n % i == 0) return false;
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(isPrime(29)); // true
        System.out.println(isPrime(30)); // false
    }
}
```

### b) Generate all primes up to N (Sieve of Eratosthenes)

```java
import java.util.*;

public class SievePrimes {
    public static List<Integer> sieve(int n) {
        boolean[] isPrime = new boolean[n+1];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;

        for (int i = 2; i * i <= n; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        List<Integer> primes = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (isPrime[i]) primes.add(i);
        }
        return primes;
    }

    public static void main(String[] args) {
        System.out.println(sieve(50)); // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
    }
}
```

---

## 9. **Summary**

* **Prime numbers** are the **building blocks** of all natural numbers.
* They have exactly two divisors (1 and itself).
* Checking for primality is essential in mathematics, coding, and cryptography.
* Algorithms like **âˆšn method** (for single numbers) and **Sieve of Eratosthenes** (for ranges) are standard in programming.


