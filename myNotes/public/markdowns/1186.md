

> Heavily tested in GATE.


# **Chapter 6 – CPU Scheduling (Sections 6.1–6.3)**

---

## **6.1 Basic Concepts**

### **What is CPU Scheduling?**

* **When multiple processes are in the ready queue**, the CPU scheduler decides **which process gets the CPU next**.
* Applies **only to processes in memory** that are **ready to execute**.
* Goal: **Optimize CPU utilization and system performance**.

---

### **When Scheduling Happens?**

Scheduling decisions occur when a process:

1. **Switches from running → waiting** (e.g., I/O request).
2. **Switches from running → ready** (e.g., interrupted by higher priority).
3. **Switches from waiting → ready** (e.g., I/O completion).
4. **Terminates**.

---

### **Preemptive vs Non-preemptive**

* **Non-preemptive**: Once a process gets CPU, it runs until it blocks or terminates.
* **Preemptive**: Scheduler can remove a process from CPU **before completion** (e.g., for higher priority or time slice expiry).

---

### **CPU–I/O Burst Cycle**

* Process execution alternates between:

  * **CPU bursts** (computation)
  * **I/O bursts** (waiting for input/output)
* **Scheduling focuses on CPU bursts** — I/O bursts are handled by I/O devices.

---

## **6.2 Scheduling Criteria**

**Performance metrics** used to evaluate scheduling algorithms:

1. **CPU Utilization** – % of time CPU is busy (goal: high).
2. **Throughput** – # of processes completed per unit time.
3. **Turnaround Time** – Total time from process submission → completion.
4. **Waiting Time** – Time spent in the ready queue.
5. **Response Time** – Time from request submission → first CPU allocation (important in interactive systems).

---

**GATE Tip:** Sometimes they give process arrival/burst times and ask for *average waiting time* or *average turnaround time* — you must know the exact algorithm logic.

---

## **6.3 Scheduling Algorithms**

### **1. First-Come, First-Served (FCFS)**

* **Non-preemptive**, processes served in order of arrival.
* **Implementation**: Ready queue as FIFO.
* **Advantage**: Simple.
* **Disadvantage**: *Convoy effect* — small processes wait behind long ones.

---

### **2. Shortest Job First (SJF)**

* Picks process with **smallest next CPU burst**.
* **Can be preemptive or non-preemptive**.
* **Optimal** for minimum average waiting time.
* **Disadvantage**: Requires accurate prediction of CPU burst → not always possible.

---

### **3. Shortest Remaining Time First (SRTF)**

* Preemptive version of SJF.
* If a new process arrives with shorter burst than remaining time of current process → preempt.

---

### **4. Priority Scheduling**

* Each process has a priority number → CPU given to highest priority.
* Can be **preemptive or non-preemptive**.
* **Issue**: Starvation of low-priority processes.
* **Solution**: Aging (gradually increasing priority of waiting processes).

---

### **5. Round Robin (RR)**

* **Preemptive**; each process gets fixed time quantum.
* After time quantum expires → process goes to end of ready queue.
* **Performance** depends heavily on quantum size:

  * Too small → too many context switches.
  * Too large → behaves like FCFS.

---

### **6. Multilevel Queue Scheduling**

* Ready queue split into multiple queues (e.g., system, interactive, batch).
* Each queue has its own scheduling algorithm.
* Fixed priority scheduling between queues.

---

**GATE Pointers:**

* Be ready to compute **Gantt charts** for given inputs.
* Preemptive vs non-preemptive behavior questions are common.
* Convoy effect and starvation appear often in theory MCQs.
* Aging is frequently tested as a starvation-prevention method.


