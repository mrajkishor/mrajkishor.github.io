

# **Default Binding**

---

## **1. What Is Default Binding?**

**Default binding** is the *fallback* `this` binding rule in JavaScript.
It applies **when no other binding rule** (implicit, explicit, `new`, or arrow function) is in effect.

The default binding says:

* If **non-strict mode** → `this` points to the **global object** (`window` in browsers, `global` in Node.js).
* If **strict mode** → `this` is **`undefined`**.

It’s the lowest precedence in the **this binding hierarchy**.

---

## **2. When Does It Apply?**

Default binding happens when:

1. A function is called **as a plain function** — not as a method on an object.
2. No explicit `.call()`, `.apply()`, or `.bind()` is used.
3. The call is not made with `new`.
4. The function is not an arrow function (arrows inherit `this` lexically).

---

## **3. Examples of Default Binding**

### **3.1 Non-strict Mode**

```js
function show() {
  console.log(this);
}
show(); // window (in browsers) or global (Node)
```

### **3.2 Strict Mode**

```js
'use strict';
function show() {
  console.log(this);
}
show(); // undefined
```

---

## **4. Why Does This Happen?**

In the spec:

* If no `thisArg` is provided at call time and no higher-precedence binding applies:

  * In **non-strict mode**, the engine substitutes the global object.
  * In **strict mode**, `this` remains exactly what it was at call time → `undefined`.

This was designed for *backwards compatibility* with early JS code, where omitting a receiver often implied using the global object.

---

## **5. Common Cases Where Default Binding Shows Up**

### **5.1 Standalone Function Calls**

```js
const obj = {
  method: function() { console.log(this); }
};
obj.method(); // obj
const fn = obj.method;
fn(); // default binding (global or undefined)
```

### **5.2 Callbacks Without Binding**

```js
setTimeout(function() {
  console.log(this);
}, 0); // global or undefined
```

### **5.3 Higher-Order Functions**

```js
function run(fn) { fn(); }
const obj = {
  name: 'Ava',
  greet() { console.log(this.name); }
};
run(obj.greet); // undefined (default binding)
```

---

## **6. Strict vs Non-Strict Behavior**

### **Non-strict mode**

* Implicitly binds to the **global object**.
* Can cause accidental pollution of global state:

```js
function setData(x) {
  this.data = x; // creates global variable!
}
setData(42);
console.log(window.data); // 42
```

### **Strict mode**

* Avoids this silent global mutation by leaving `this` as `undefined`:

```js
'use strict';
function setData(x) {
  this.data = x; // TypeError: Cannot set property 'data' of undefined
}
setData(42);
```

---

## **7. Precedence in the Binding Hierarchy**

Default binding has **lowest precedence**:

1. `new` binding
2. Explicit binding (`call`, `apply`, `bind`)
3. Implicit binding (object at call site)
4. **Default binding** (fallback)

If any of the first three rules apply, default binding is ignored.

---

## **8. How to Avoid Default Binding Pitfalls**

### **Bind in advance**

```js
const boundFn = obj.method.bind(obj);
setTimeout(boundFn, 0);
```

### **Use arrow functions**

```js
setTimeout(() => obj.method(), 0);
```

### **Call with explicit binding**

```js
setTimeout(function() { obj.method(); }, 0);
```

### **Enable strict mode**

* Prevents silent global mutations.
* Forces early detection of missing bindings.

---

## **9. Interview-Favorite Gotcha**

```js
var length = 4;
function callback() {
  console.log(this.length);
}
const obj = {
  length: 5,
  method(fn) {
    fn(); // default binding
  }
};
obj.method(callback); // 4 (in browsers) — from global `length`
```

* **Why?** → `fn()` is a plain function call inside `method` → default binding.
* In strict mode, this would log `undefined` instead.

---

## **10. Best Practices**

* Always know **the call site** — `this` is determined there, not at declaration.
* Use **strict mode** (or ES modules, which are strict by default).
* Avoid depending on global object binding — it’s a source of subtle bugs.
* For callbacks, prefer **arrow functions** or `.bind()` to lock `this`.
* In class components (React, etc.), bind handlers in the constructor or use public class field arrows.

---


Here’s a **decision flowchart** for how JavaScript decides the value of `this`, plus a quick **algorithmic checklist** and **worked examples** you can map to the chart in interviews.

---

# `this` Binding Decision Flow

```mermaid

flowchart TD
  A[Call site] --> B{Called with new?}
  B -- yes --> B1[this = new instance]
  B -- no --> C{Called with .call/.apply/.bind?}
  C -- yes --> C1[this = explicit thisArg<br/>(except null/undefined → global in non-strict)]
  C -- no --> D{Is it a method call<br/>(obj.fn())?}
  D -- yes --> D1[this = the receiver object at call site]
  D -- no --> E{Arrow function?}
  E -- yes --> E1[this = lexically captured from enclosing scope]
  E -- no --> F{Strict mode?}
  F -- yes --> F1[this = undefined]
  F -- no --> F2[this = global object (window/global)]

```

**Read it top-down** at the *call site* (where the function is invoked), not where the function is defined.

---

## One-Minute Checklist (memorize this order)

1. **`new`** wins → `this` is the **new object**.
2. **Explicit** (`call`/`apply`/`bind`) → `this` is the provided **thisArg**

   * If `thisArg` is `null`/`undefined`: **global** in non-strict, **null/undefined** in strict.
3. **Implicit** (`obj.fn()`) → `this` is the **receiver** (`obj` *at the call site*).

   * Beware: **extraction** (`const f = obj.fn; f()`) loses the receiver → falls through.
4. **Arrow** → **no own `this`**; uses **enclosing lexical `this`**.
5. **Default** → strict: `undefined`; non-strict: **global object**.

> **Precedence:** `new` → explicit → implicit → (arrow is lexical, not a runtime rule) → default.

---

## Worked Call-Site Examples

### 1) `new` binding beats everything

```js
function Foo(x) { this.x = x; }
const Bound = Foo.bind({ bogus: true });
const a = new Bound(42);
a.x; // 42  (new binding wins; bound this ignored)
```

### 2) Explicit binding

```js
function show() { return this.tag; }
const obj = { tag: 'O' };
show.call(obj);  // 'O'
show.apply(obj); // 'O'
const s = show.bind(obj); s(); // 'O'
```

### 3) Implicit binding (receiver matters)

```js
const user = {
  name: 'Ava',
  hi() { return this.name; }
};
user.hi(); // 'Ava'

const f = user.hi;
f();       // undefined (strict) or global (non-strict) — lost receiver
```

### 4) Arrow functions capture `this` lexically

```js
const ctx = { n: 10 };
function outer() {
  this.n = 20;
  return () => this.n;   // arrow captures outer's this
}
outer.call(ctx)(); // 10 (because this inside outer is ctx, so arrow returns ctx.n)
```

### 5) Default binding

```js
'use strict';
function g(){ return this; }
g(); // undefined  (strict default)
```

### 6) Losing `this` in callbacks (and fixing it)

```js
const obj = { x: 1, get(){ return this.x; } };

setTimeout(obj.get, 0);            // default binding → undefined or global
setTimeout(obj.get.bind(obj), 0);  // explicit binding → 1
setTimeout(() => obj.get(), 0);    // call as method inside arrow → 1
```

---

## Pitfalls to call out in interviews

* **Extraction loses implicit binding:** `const h = obj.m; h();` → default binding.
* **Method chaining receiver:** `a.b.c()` binds `this` to `a.b`, not `a`.
* **Event handlers:** traditional function → `this` is the **element**; arrow → lexical `this`.
* **Modules top-level:** `this` is **undefined** (ESM is strict).
* **`bind` once, reuse everywhere:** especially for React class methods or library callbacks.


