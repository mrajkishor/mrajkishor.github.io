

# **Chapter 10 – File-System Interface (Sections 10.1–10.4)**

---

## **10.1 File Concept**

A **file** is a named collection of related information stored on secondary storage.

* Smallest unit of logical storage visible to the user.
* Can contain:

  * Program code
  * Data (text, binary, multimedia)
* Identified by **name + path**.

**Attributes of a File** (metadata stored in file control block (FCB) or inode):

1. **Name** – human-readable identifier.
2. **Identifier** – unique system-wide tag (e.g., inode number).
3. **Type** – text, binary, executable, etc.
4. **Location** – pointer(s) to disk blocks.
5. **Size** – current file size (bytes).
6. **Protection** – access control info.
7. **Timestamps** – creation, last access, last modification.
8. **Owner** – user ID and group ID.

**File Operations**:

1. **Create** – make new file.
2. **Write** – store data into file.
3. **Read** – retrieve data.
4. **Reposition (seek)** – move file pointer.
5. **Delete** – remove file.
6. **Truncate** – erase content but keep metadata.

---

## **10.2 Access Methods**

Access method = way data is read/written from file.

### **1. Sequential Access**

* Data read/write **in order** from start to end.
* Common in text files, log files.
* Pros: Simple, minimal overhead.
* Cons: No random jumps without scanning.

### **2. Direct Access (Random Access)**

* File viewed as numbered blocks (records).
* Can access any block directly via index.
* Needed for databases, VM page files.

### **3. Other Access Methods**

* **Indexed Access** – use index table to locate data blocks.
* **Hashed Access** – apply hash function to locate data.

---

## **10.3 Directory Structure**

A **directory** is a special file containing mapping from file names to metadata (like inodes).

**Single-Level Directory**

* All files in one directory.
* Pros: Simple.
* Cons: Name collisions; no grouping.

**Two-Level Directory**

* Separate user directories under a master directory.
* Pros: Avoids name conflicts between users.
* Cons: No grouping inside user’s own space.

**Tree-Structured Directory**

* Hierarchical arrangement (like modern OSes).
* Pros: Logical grouping, easier navigation.
* Cons: Slightly more complex lookup.

**Acyclic Graph Directory**

* Allows sharing of files or subdirectories via links.
* Prevents loops.

**General Graph Directory**

* Allows cycles.
* Needs cycle detection to avoid infinite traversal.

---

## **10.4 Protection**

Goal: Control **who** can do **what** with a file.

### **Access Control**

* **Access Control Matrix**:

  * Rows: users/processes.
  * Columns: files/objects.
  * Entries: allowed operations.
* Stored as:

  1. **Access Control Lists (ACLs)** – for each file, list users and permissions.
  2. **Capabilities** – for each user, list accessible objects and allowed ops.

### **Common Permission Sets**

* UNIX-style: **read (r)**, **write (w)**, **execute (x)** for **owner/group/others**.
* Windows NTFS: fine-grained access rules.

**Other Protections**:

* Password-protected files.
* Encryption for confidentiality.
* Immutable/append-only flags for data integrity.

---

## **GATE Exam Pointers**

* **Numerical**: Often directory traversal and file allocation table problems come in **next chapter (allocation)**, but here the focus is conceptual.
* **Direct questions**:

  * “List file attributes stored in FCB/inode.”
  * “Difference between sequential and direct access.”
  * “Advantages/disadvantages of tree vs acyclic graph directories.”
  * “How does access control matrix differ from ACL?”
