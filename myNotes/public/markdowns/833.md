
## üß† **Design of Accumulator Unit (AC)**

The **Accumulator (AC)** is a special-purpose register in a computer‚Äôs **Arithmetic Logic Unit (ALU)**. It plays a vital role in executing arithmetic and logic instructions by holding intermediate results, especially in a system that uses a **single-operand architecture** like a basic computer.

![alt text](image-76.png)


![alt text](image-78.png)

---

## üì• **Role of the Accumulator**

1. **Temporary Storage**:
   AC stores intermediate results of arithmetic or logic operations (e.g., addition, AND, complement).

2. **Implicit Operand**:
   In most instructions, one operand is implicitly assumed to be in AC, reducing instruction size and improving performance.

3. **Multi-step Operations**:
   For operations involving multiple values (e.g., cumulative sum), AC stores the partial result which is updated step-by-step.

---

## üß± **Accumulator Unit Components (Diagram 1)**

### üîπ Major Components:

1. **Adder and Logic Circuit**:

   * Accepts inputs from `DR`, `INPR`, or previous AC value.
   * Performs logic (AND, complement) or arithmetic (ADD, INC) operations.

2. **Accumulator Register (AC)**:

   * 16-bit register for storing intermediate results.
   * Connected to the **common bus** for data exchange.

3. **Control Gates**:

   * Generate control signals like:

     * `LD` (Load AC)
     * `INR` (Increment AC)
     * `CLR` (Clear AC)

4. **Clock Signal**:

   * Synchronizes data transfer into AC with system timing.

---

## ‚öôÔ∏è **Input Sources to the Adder and Logic Circuit**

1. **From DR (Data Register)** ‚Äì 16-bit operand from memory.
2. **From INPR (Input Register)** ‚Äì 8-bit I/O data input (aligned with AC\[0‚Äì7]).
3. **From AC** ‚Äì For operations like increment, complement, shift.

---

## üîÑ **Register Transfer Operations That Affect AC**

| Operation | RTL Statement             | Description                  |
| --------- | ------------------------- | ---------------------------- |
| AND       | `AC ‚Üê AC ‚àß DR`            | Logical AND with DR          |
| ADD       | `AC ‚Üê AC + DR`            | Arithmetic addition          |
| LDA       | `AC ‚Üê DR`                 | Load value from DR           |
| INP       | `AC(0‚Äì7) ‚Üê INPR`          | Input lower 8 bits from INPR |
| CMA       | `AC ‚Üê ¬¨AC`                | One‚Äôs complement             |
| SHR       | `AC ‚Üê shr AC, AC(15) ‚Üê E` | Shift right, MSB from E      |
| SHL       | `AC ‚Üê shl AC, AC(0) ‚Üê E`  | Shift left, LSB from E       |
| CLA       | `AC ‚Üê 0`                  | Clear AC                     |
| INC       | `AC ‚Üê AC + 1`             | Increment AC                 |

---

## üßÆ **Microoperations Supported by Accumulator Logic**

| Operation              | Function                                |
| ---------------------- | --------------------------------------- |
| **Complement**         | Flip all bits of AC                     |
| **Clear**              | Set AC to 0                             |
| **Increment**          | Add 1 to current AC                     |
| **Shift Left/Right**   | Move bits and interact with E flip-flop |
| **Transfer from DR**   | Replace AC with memory operand          |
| **Transfer from INPR** | Input lower 8 bits of AC                |

---

## üîÅ **Working Cycle Example**

To execute the instruction `ADD M[X]`:

1. `DR ‚Üê M[X]` ‚Üí memory data is loaded into DR.
2. `AC ‚Üê AC + DR` ‚Üí Adder unit adds content of DR to AC.
3. Result is stored back in AC.

Similarly, for `AND`, the adder/logic unit computes `AC ‚àß DR`.

---

## üîå **Control Signals Summary**

| Signal              | Function               |
| ------------------- | ---------------------- |
| **LD (Load)**       | Load new value into AC |
| **INR (Increment)** | Increment AC           |
| **CLR (Clear)**     | Clear AC to zero       |

These signals are generated by **control gates** based on decoded instruction and current timing signal (T‚ÇÄ‚ÄìT‚ÇÖ).

---

## üßæ **Conclusion**

The **Accumulator Unit** is a central element in basic computer architecture, acting as the heart of the ALU for holding temporary and final results. It interacts with:

* Memory (via DR),
* I/O devices (via INPR),
* The common bus,
* Control logic and flags (via LD, INR, CLR).

Its design simplifies the execution of instructions by reducing the need for multiple operand fields and helps demonstrate the core functioning of a CPU.
