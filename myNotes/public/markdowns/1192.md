## **Connected Components & Cycle Detection using DFS**:

---

## **1. Concept**

### **Connected Components**

A **connected component** in an undirected graph is a set of vertices where:

* There is a **path** between any two vertices in the set.
* No vertex in the set is connected to any vertex outside the set.

**Key Points:**

* In an **undirected graph**, each connected component is a **maximal** connected subgraph.
* In a **directed graph**, we define:

  * **Strongly Connected Components (SCCs):** Each vertex can reach every other vertex in the same component (Kosaraju’s, Tarjan’s algorithms).
  * **Weakly Connected Components:** The graph becomes connected if all edges are treated as undirected.

---

### **Cycle Detection with DFS**

Cycle detection checks whether a **loop** exists in the graph:

* In **undirected graphs**, a cycle exists if during DFS traversal we encounter an already visited vertex that is **not the parent** of the current vertex.
* In **directed graphs**, cycle detection is done by tracking the recursion stack (or using colors: white, gray, black).

---

## **2. Approach Using DFS**

### **For Connected Components**

1. Maintain a **visited\[]** array.
2. Loop through each vertex:

   * If it’s **not visited**, start a DFS from that vertex.
   * All vertices reached in that DFS belong to the **same connected component**.
3. Count the number of times a DFS is initiated → gives the **number of connected components**.

---

### **For Cycle Detection in Undirected Graph**

1. Use DFS to traverse from each unvisited vertex.
2. Track the **parent** vertex in DFS.
3. If a visited vertex is found that is **not the parent**, a **cycle** exists.

---

### **For Cycle Detection in Directed Graph**

1. Maintain two arrays:

   * **visited\[]** → visited nodes
   * **recStack\[]** → nodes in the current DFS recursion path
2. During DFS:

   * If you find a vertex in **recStack**, a cycle exists.
   * Remove from **recStack** on returning from recursion.

---

## **3. Time & Space Complexity**

* **DFS traversal:**
  Time → **O(V + E)** (V = vertices, E = edges)
  Space → **O(V)** (visited array + recursion stack)

* Works efficiently for **sparse** and **dense** graphs.

---

## **4. Pseudocode**

### **Connected Components**

```python
def dfs(u, visited, graph):
    visited[u] = True
    for v in graph[u]:
        if not visited[v]:
            dfs(v, visited, graph)

def countConnectedComponents(graph, V):
    visited = [False] * V
    count = 0
    for i in range(V):
        if not visited[i]:
            dfs(i, visited, graph)
            count += 1
    return count
```

---

### **Cycle Detection (Undirected)**

```python
def dfsCycle(u, visited, parent, graph):
    visited[u] = True
    for v in graph[u]:
        if not visited[v]:
            if dfsCycle(v, visited, u, graph):
                return True
        elif v != parent:
            return True
    return False
```

---

### **Cycle Detection (Directed)**

```python
def dfsDirected(u, visited, recStack, graph):
    visited[u] = True
    recStack[u] = True

    for v in graph[u]:
        if not visited[v]:
            if dfsDirected(v, visited, recStack, graph):
                return True
        elif recStack[v]:
            return True
    
    recStack[u] = False
    return False
```

---

## **5. Practical Use Cases**

* **Connected Components**: Social network clusters, image segmentation, finding isolated subnetworks.
* **Cycle Detection**:

  * Deadlock detection in OS resource allocation graphs.
  * Detecting infinite loops in dependency resolution (package managers, build systems).
  * Validating that a graph is a tree (tree = connected + acyclic).

