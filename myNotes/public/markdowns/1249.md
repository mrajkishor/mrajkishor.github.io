
# Strings ‚Üí split, join, slice, substring

---

## 1. Why Strings Are Critical in LeetCode

In **interviews** and competitive programming, string manipulation problems are everywhere:

* Palindrome checking (`aba`, `abba`).
* Substring search (`longest substring without repeating chars`).
* Tokenization (`split` for parsing input).
* Rotation, slicing, trimming (`slice`, `substring`).
* Join/Concatenate for **output formatting**.

‚ö° Strings in Node.js are **immutable** (unlike arrays). Any operation like `slice` or `substring` creates a **new string**, which has implications for **time complexity** and **memory usage** in large test cases (10‚Åµ‚Äì10‚Å∂ characters).

---

## 2. Node.js String Essentials

### üîπ String Representation

* In Node.js (JavaScript), strings are stored as **UTF-16 sequences**.
* Random access: `O(1)` with `str[i]`.
* Copying substrings: `O(k)` where `k` = length of substring.

---

## 3. String Methods

### **1. `split()`**

* Breaks a string into an **array** of substrings based on a delimiter.

```js
const s = "leetcode is fun";
console.log(s.split(" "));   // [ 'leetcode', 'is', 'fun' ]
console.log(s.split("e"));   // [ 'l', 'tcod', '', ' is fun' ]
console.log(s.split(""));    // [ 'l','e','e','t','c','o','d','e',' ','i','s',' ','f','u','n']
```

####  Use Cases:

* Parsing input (`"1 2 3 4".split(" ").map(Number)`).
* Breaking words for dictionary/trie problems.
* Splitting large strings (watch out: `O(n)` time + `O(n)` space).

‚ö†Ô∏è **Pitfall**: `split("")` ‚Üí expensive for 10‚Å∂ length strings (creates an array of characters). Prefer indexing.

---

### **2. `join()`**

* Opposite of `split()`. Converts an array into a string.

```js
const arr = ["leetcode", "rocks"];
console.log(arr.join(" ")); // "leetcode rocks"
console.log(arr.join("-")); // "leetcode-rocks"
```

####  Use Cases:

* Efficient **string building** (instead of repeated concatenation in loops).
* Merging array results for output formatting (`console.log(arr.join("\n"))`).

‚ö° Best Practice:
For building long strings inside loops, always use `push()` + `join()` instead of `+=`.

```js
let result = [];
for (let i = 0; i < 5; i++) result.push(i);
console.log(result.join(" ")); // "0 1 2 3 4"
```

---

### **3. `slice(start, end)`**

* Extracts a substring between indices `[start, end)`.
* Accepts **negative indices** (counting from end).

```js
const s = "leetcode";
console.log(s.slice(0, 4));   // "leet"
console.log(s.slice(4));      // "code"
console.log(s.slice(-3));     // "ode"
console.log(s.slice(2, -2));  // "etc"
```

####  Use Cases:

* Rotations (`s.slice(k) + s.slice(0, k)`).
* Extracting suffix/prefix for KMP/Rabin-Karp.
* Handling substrings with **negative indexing** (Python-like).

‚ö†Ô∏è **Pitfall**: `slice` creates a new string ‚Üí `O(k)` time & memory.

---

### **4. `substring(start, end)`**

* Similar to `slice`, but:

  * **No negative indices**.
  * Swaps arguments if `start > end`.

```js
const s = "leetcode";
console.log(s.substring(0, 4));   // "leet"
console.log(s.substring(4, 0));   // "leet" (reverses automatically)
console.log(s.substring(2, 2));   // "" (empty string)
```

####  Use Cases:

* Problems where exact **non-negative bounds** are expected.
* Cleaner in interview scenarios when negative indexing is not needed.

‚ö° Best Practice: Use `slice()` unless you specifically need `substring`'s argument-swapping behavior.

---

## 4. Complexity Analysis

| Operation        | Time Complexity | Space Complexity | Notes                                  |
| ---------------- | --------------- | ---------------- | -------------------------------------- |
| `split(delim)`   | `O(n)`          | `O(n)`           | Every character scanned.               |
| `join(delim)`    | `O(n)`          | `O(n)`           | Concatenates array elements.           |
| `slice(a,b)`     | `O(k)`          | `O(k)`           | Copies substring length `k`.           |
| `substring(a,b)` | `O(k)`          | `O(k)`           | Same as `slice`, no negative indexing. |

üëâ For  interviews, emphasize **trade-offs** between substring creation (`O(k)`) and pointer/index manipulation (`O(1)`).

---

## 5. Tricks with Strings

1. **Palindrome Check (Two-Pointer, No Split)**

```js
function isPalindrome(s) {
  let i = 0, j = s.length - 1;
  while (i < j) {
    if (s[i] !== s[j]) return false;
    i++; j--;
  }
  return true;
}
```

‚úÖ Avoids `split("").reverse().join("")` ‚Üí `O(n)` extra space.

---

2. **Efficient Rotation with Slice**

```js
function rotate(s, k) {
  k %= s.length;
  return s.slice(k) + s.slice(0, k);
}
console.log(rotate("abcdef", 2)); // "cdefab"
```

---

3. **Reverse Words (Split + Join)**

```js
function reverseWords(s) {
  return s.trim().split(/\s+/).reverse().join(" ");
}
console.log(reverseWords("  hello   world  ")); // "world hello"
```

---

4. **Avoiding TLE (Time Limit Exceeded) in Concatenation**
   Bad ‚ùå

```js
let ans = "";
for (let i = 0; i < 1e5; i++) ans += "a"; // O(n^2) due to immutability
```

Good ‚úÖ

```js
let arr = [];
for (let i = 0; i < 1e5; i++) arr.push("a");
let ans = arr.join(""); // O(n)
```

---

5. **Substring Search (Brute Force)**

```js
function strStr(haystack, needle) {
  return haystack.indexOf(needle); // built-in KMP-like implementation
}
```

---

## ‚úÖ In Summary

* **`split()`** ‚Üí input parsing, tokenization.
* **`join()`** ‚Üí efficient concatenation/output formatting.
* **`slice()`** ‚Üí substring extraction with negative indexing.
* **`substring()`** ‚Üí safer, but less flexible (no negatives).

For **interviews**, always highlight:

* String immutability ‚Üí avoid repeated concatenation.
* Complexity trade-offs (`O(n)` copies).
* When to prefer array-based building (`join`) vs string-based slicing.

---


# üöÄ Node.js String Utility Snippet 

```javascript
// ===============================
// üìò Node.js String Utilities
// ===============================

// 1Ô∏è‚É£ Palindrome Check (Two-Pointer, O(n))
function isPalindrome(s) {
  let i = 0, j = s.length - 1;
  while (i < j) {
    if (s[i] !== s[j]) return false;
    i++; j--;
  }
  return true;
}

// 2Ô∏è‚É£ Reverse String (O(n))
function reverseString(s) {
  return s.split("").reverse().join("");
}

// 3Ô∏è‚É£ Reverse Words in a Sentence (O(n))
function reverseWords(s) {
  return s.trim().split(/\s+/).reverse().join(" ");
}

// 4Ô∏è‚É£ Rotate String (O(n))
function rotateString(s, k) {
  k %= s.length;
  return s.slice(k) + s.slice(0, k);
}

// 5Ô∏è‚É£ Count Character Frequencies (O(n))
function charFrequency(s) {
  const freq = {};
  for (let ch of s) {
    freq[ch] = (freq[ch] || 0) + 1;
  }
  return freq;
}

// 6Ô∏è‚É£ Substring Check (O(n))
function containsSubstring(haystack, needle) {
  return haystack.indexOf(needle) !== -1;
}

// 7Ô∏è‚É£ Build String Efficiently (O(n))
function buildString(arr) {
  return arr.join(""); // avoids costly += concatenation
}

// 8Ô∏è‚É£ Compare Substrings (O(k))
function isSubstringEqual(s, i, j, t, x, y) {
  return s.slice(i, j) === t.slice(x, y);
}

// 9Ô∏è‚É£ Normalize Case & Alphanumerics (LeetCode "Valid Palindrome")
function normalizeAlphanumeric(s) {
  return s.replace(/[^a-z0-9]/gi, "").toLowerCase();
}
```

---

## üîë Usage Examples

```javascript
console.log(isPalindrome("abba"));        // true
console.log(reverseString("leetcode"));   // "edocteel"
console.log(reverseWords(" hello world ")); // "world hello"
console.log(rotateString("abcdef", 2));   // "cdefab"
console.log(charFrequency("aabbc"));      // { a: 2, b: 2, c: 1 }
console.log(containsSubstring("leetcode", "code")); // true

let arr = ["leet", "code"];
console.log(buildString(arr));            // "leetcode"

console.log(isSubstringEqual("abcde", 0, 3, "abc", 0, 3)); // true
console.log(normalizeAlphanumeric("A man, a plan, a canal: Panama")); 
// "amanaplanacanalpanama"
```

---

## ‚úÖ Why This Snippet is Interview-Ready

* **Handles Core Interview Patterns**

  * Palindromes
  * Rotations
  * Reverse words
  * Substring checks
  * Character frequency (useful for anagrams, sliding window problems)

* **Optimized for Performance**

  * Avoids `+=` concatenation (`O(n^2)`), uses `join` instead.
  * Uses regex + `toLowerCase()` for normalization (common in string problems).
  * Handles **large strings (10‚Åµ‚Äì10‚Å∂ chars)** without TLE.

* **Reusable Template** ‚Üí Just copy-paste and call inside `solveOneCase()` for LeetCode.

