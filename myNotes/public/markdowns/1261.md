
# 🔷 Chapter 3.3: Specification of Tokens

### 1. Introduction

* Tokens are described formally using **formal languages** and **regular expressions**.
* The goal: give a precise mathematical description of each class of valid lexemes.
* Example:

  * **Keywords** → specific strings (`if`, `while`, `return`).
  * **Identifiers** → pattern like `letter (letter | digit)*`.
  * **Numbers** → digits with optional decimal/exponent parts.

---

### 2. Strings and Languages (3.3.1)

* **Alphabet (Σ)**: finite set of symbols (e.g., `{a–z, A–Z, 0–9}` for identifiers).
* **String**: finite sequence of symbols from Σ.

  * Example: `abc123` is a string over `{a–z, 0–9}`.
* **Language**: set of strings over an alphabet.

  * Example: Set of all valid C identifiers.
* Special strings:

  * Empty string `ε`.
  * Empty set `∅` (no strings).

---

### 3. Operations on Languages (3.3.2)

* **Union (L1 ∪ L2)**: strings in L1 or L2.
* **Concatenation (L1L2)**: all strings formed by concatenating one from L1 with one from L2.
* **Kleene Closure (L*)**: zero or more concatenations of strings from L.

  * Example: `{a}* = {ε, a, aa, aaa, …}`.
* **Positive Closure (L⁺)**: one or more concatenations.

  * Example: `{a}⁺ = {a, aa, aaa, …}`.

---

### 4. Regular Expressions (3.3.3)

* Formal notation to describe **token patterns**.
* Defined recursively:

  * `ε` is a regex → language {ε}.
  * `a` (where a ∈ Σ) → language {a}.
  * If `r` and `s` are regex:

    * `r | s` → union.
    * `rs` → concatenation.
    * `r*` → Kleene closure.
    * `(r)` → grouping.
* Example token regex:

  * Identifier → `letter (letter | digit)*`
  * Integer → `digit+`
  * Number → `digit+(.digit+)?(E(+|-)?digit+)?`

---

### 5. Regular Definitions (3.3.4)

* To simplify regex, we use **names** for components.
* Example:

  ```
  digit     → [0-9]
  letter    → [A-Za-z]
  id        → letter (letter | digit)*
  number    → digit+ (.digit+)? (E(+|-)?digit+)?
  ```
* This modular approach is what real lexical analyzers (like `lex`/`flex`) use.

---

### 6. Extensions of Regular Expressions (3.3.5)

* Practical regex libraries add shorthand:

  * `r+` → one or more repetitions.
  * `r?` → zero or one occurrence.
  * Character classes: `[a-z]`, `[^0-9]`.
  * Abbreviations like `.` for “any character”.
* Though not part of pure formal definition, they are used in tools like **Lex/Flex**.

---

### 7. Connection to Automata

* Regex ↔ Finite Automata equivalence:

  * Every regex → NFA → DFA → minimal DFA.
  * This is the **theory behind lexical analyzers**.
* In practice:

  * Write regex for tokens.
  * Convert to DFA (transition diagrams).
  * Implement DFA in lexer.

---

# ✅ GATE Pointers

* **Regex → Language**: Common MCQ (they may give regex and ask which strings match).
* **Difference between union, concatenation, closure**: Conceptual theory questions.
* **Regex to DFA conversion**: Standard 2–4 mark problems (ties to TOC).
* **Identifiers & numbers regex**: Often asked in exams.
* **Regular definitions**: Appear in numerical examples (“write regex for C identifiers/numbers”).

