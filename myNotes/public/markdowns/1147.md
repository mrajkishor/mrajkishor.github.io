

# REST, GraphQL, tRPC, gRPC

---

## ‚úÖ Overview

Data fetching is a core responsibility in modern frontend engineering. A robust application must communicate with backend services to retrieve, mutate, or subscribe to data. The architecture and API style‚ÄîREST, GraphQL, tRPC, or gRPC‚Äîplay a significant role in shaping developer experience, performance, type safety, and scalability.

---

## üî∑ 1. **REST APIs**

### ‚úÖ Core Concepts

* **Stateless**, **resource-oriented** architecture.
* Data is accessed via standard **HTTP methods**:

  * `GET`, `POST`, `PUT`, `PATCH`, `DELETE`
* Endpoints represent **resources**, e.g., `/users/123`
* Uses **status codes** to communicate response semantics (200, 404, 500‚Ä¶)

### ‚úÖ Pros

* Simple, widely adopted.
* Strong HTTP caching support.
* Easy to test and debug using tools like Postman, cURL, browser.

### ‚úÖ Cons

* ==Over-fetching or under-fetching common==.
* ==N+1 request problems in nested data.==
* Less flexible when evolving APIs (e.g., adding/removing fields).

### ‚úÖ Frontend Tools

* Axios / Fetch API
* React Query / SWR
* Redux Toolkit Query (RTK Query)
* REST hooks

> __What is N+1 request problems in nested data?__ 
> The N+1 request problem, particularly relevant in the context of nested data structures and database interactions, arises when an application executes one initial query to retrieve a collection of parent entities and then subsequently performs N additional queries, one for each of those parent entities, to fetch associated child or related data
> __Example__: 
> Consider a scenario where you have "Orders" as parent entities and "Order Items" as nested child entities, where each order can have multiple order items.
> Initial Query (1): The application first queries the database to retrieve a list of all orders.
> ``` SELECT * FROM orders; ```
> Subsequent Queries (N): For each order retrieved in the first step, the application then executes a separate query to fetch its associated order items. If there are N orders, this results in N additional queries. 
> ```     SELECT * FROM order_items WHERE order_id = :order_id; -- Executed N times ```
> This leads to a total of 1 (for the parent entities) + N (for the child entities) queries, hence the "N+1" problem.

---

## üî∑ 2. **GraphQL**

### ‚úÖ Core Concepts

* **Query language** for APIs: Client defines exact data shape.
* Single **/graphql** endpoint; operations:

  * `query`, `mutation`, `subscription`
* Strongly typed schema (`SDL`)
* **Introspection** allows self-documenting APIs.

### ‚úÖ Pros

* No over/under-fetching.
* Fewer round-trips.
* Easy to evolve API schema.
* Strong developer tooling (Apollo, GraphiQL, Codegen).

### ‚úÖ Cons

* ==Complex caching==.
* ==File upload==, pagination, error handling can be tricky.
* Requires server support and runtime parsing overhead.

### ‚úÖ Frontend Tools

* Apollo Client
* urql
* Relay
* GraphQL Code Generator (generates typed hooks)

---

## üî∑ 3. **tRPC**

### ‚úÖ Core Concepts

* **TypeScript-native** API framework.
* No need to write REST/GraphQL schemas.
* Full **end-to-end type safety** using inference.
* RPC-style method calls (`router.user.getAll()` instead of `/users`).

### ‚úÖ Pros

* Eliminates schema duplication (no OpenAPI or SDL).
* Autocompletion and inline TypeScript support.
* Simple developer experience for full-stack TypeScript apps.

### ‚úÖ Cons

* Tightly coupled to TypeScript and Node.js.
* Not suited for polyglot or public API scenarios.
* Limited to monorepos or tightly controlled stacks.

### ‚úÖ Frontend Tools

* Comes with React bindings: `@trpc/react-query`
* Pairs well with Next.js, Vite, TanStack Query.

---

## üî∑ 4. **gRPC**

### ‚úÖ Core Concepts

* Remote Procedure Call (RPC) framework by Google.
* Uses **Protocol Buffers (protobufs)** for schema.
* Binary over HTTP/2 ‚Äî fast and efficient.
* Supports **streaming**, **bi-directional communication**.

### ‚úÖ Pros

* High performance, ideal for microservices.
* Strong typing via `.proto` contracts.
* Streaming support for real-time apps.
* Backward-compatible versioning.

### ‚úÖ Cons

* Browser support requires a proxy (gRPC-web).
* Difficult to debug (binary format).
* Not REST-friendly, overkill for simple apps.

### ‚úÖ Frontend Tools

* `grpc-web` for browser-based apps.
* Envoy or gRPC Gateway for REST translation.
* Generated TypeScript/JS clients via `protoc`.

---

## üî∑ Comparison Summary

| Feature                 | REST       | GraphQL          | tRPC            | gRPC                |
| ----------------------- | ---------- | ---------------- | --------------- | ------------------- |
| **Standardization**     | ‚úÖ High     | üü° Medium        | ‚ùå Low           | ‚úÖ High              |
| **Type Safety**         | ‚ùå Optional | ‚úÖ Optional       | ‚úÖ End-to-end    | ‚úÖ Strong (Protobuf) |
| **Ease of Use**         | ‚úÖ Simple   | üü° Moderate      | ‚úÖ Very Easy     | ‚ùå Complex           |
| **Over/Under Fetching** | ‚ùå Common   | ‚úÖ Solved         | ‚úÖ Solved        | ‚úÖ Solved            |
| **Streaming Support**   | ‚ùå No       | üü° Subscriptions | ‚ùå No            | ‚úÖ Yes               |
| **Frontend Tooling**    | ‚úÖ Mature   | ‚úÖ Excellent      | üü¢ Emerging     | üü° Developing       |
| **Performance**         | üü° Good    | üü° Moderate      | ‚úÖ Fast (TS)     | ‚úÖ Excellent         |
| **Mobile/Web Friendly** | ‚úÖ Yes      | ‚úÖ Yes            | ‚úÖ Yes           | ‚ùå Needs proxy       |
| **Dev Experience**      | ‚úÖ Standard | ‚úÖ Powerful       | ‚úÖ Type-safe joy | ‚ùå Verbose setup     |

---

## üî∑ Real-World Usage

| Tech        | Example Use Case                                                      |
| ----------- | --------------------------------------------------------------------- |
| **REST**    | Public APIs (e.g., Twitter, GitHub REST), traditional web/mobile apps |
| **GraphQL** | Client-driven UIs like dashboards, admin panels, mobile-first apps    |
| **tRPC**    | Internal tools, monorepos, Next.js/TypeScript startups                |
| **gRPC**    | High-throughput systems, ML model servers, streaming video/audio      |

---

## üî∑ Interview Preparation Tips

### ‚úÖ Common Questions

1. Compare REST vs GraphQL in a frontend-heavy app.
2. How do you handle type-safety in REST API calls?
3. What is over-fetching? How does GraphQL solve it?
4. How does tRPC achieve type safety without schema files?
5. How do you debug gRPC calls in the browser?
6. How does HTTP caching differ in REST vs GraphQL?
7. Explain how React Query helps with stale data and caching.

---

## ‚úÖ Best Practices

* **REST**:

  * Use consistent naming conventions (`/api/v1/users`)
  * Centralize API logic via services or hooks
  * Apply caching (`ETag`, `Cache-Control`) where applicable

* **GraphQL**:

  * Use fragments for modularity
  * Paginate large datasets with `cursor`-based pagination
  * Use persisted queries for security

* **tRPC**:

  * Modularize routers
  * Infer input/output types to prevent manual type duplication
  * Handle auth via middleware (e.g., `isAuthed()` guard)

* **gRPC**:

  * Use `.proto` files with strict versioning
  * Bridge gRPC to browser via `grpc-web` or REST gateway
  * Leverage streaming for high-frequency updates (e.g., stock tickers)

---

## ‚úÖ Final Thoughts

Mastering different API paradigms is crucial for any Enterprise-level frontend engineer. While REST remains a universal baseline, GraphQL dominates in flexible client-driven UIs, tRPC shines in TypeScript-first internal stacks, and gRPC powers real-time, high-performance systems.

A solid frontend engineer should:

* Understand strengths and trade-offs.
* Choose the right tool based on **latency, flexibility, team structure, and ecosystem fit**.
* Abstract away API logic into **typed hooks or services** for maintainability.


----

## <ins>Use Cases and Case studies:



## ‚úÖ USE CASES

### üîπ REST

| Use Case                                    | Description                                                                                               |
| ------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| **Public APIs**                             | Ideal for third-party integrations like weather APIs, GitHub API, or payment gateways (Stripe, Razorpay). |
| **SEO-optimized websites**                  | REST endpoints are easier to cache and index, making them great for traditional content-heavy sites.      |
| **Microservices Intercommunication (HTTP)** | REST is commonly used for internal HTTP calls between services in loosely-coupled architectures.          |
| **Admin panels**                            | Simpler UIs often map well to REST, with CRUD-style interfaces.                                           |

---

### üîπ GraphQL

| Use Case                           | Description                                                                                                |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **Dynamic UI with nested data**    | Apps like dashboards or profile pages (e.g., GitHub, LinkedIn) where components need specific nested data. |
| **Mobile apps with slow networks** | Mobile clients benefit from fewer round trips and tailored data payloads.                                  |
| **E-commerce product listings**    | Fetch products, variants, prices, and inventory in a single call.                                          |
| **Multi-tenant SaaS apps**         | Frontends dynamically adapt to user role, org, or permissions ‚Äî ideal for flexible queries.                |

---

### üîπ tRPC

| Use Case                        | Description                                                                             |
| ------------------------------- | --------------------------------------------------------------------------------------- |
| **Internal tools for startups** | Fast-moving teams use tRPC to skip boilerplate and ship fast in full TypeScript stacks. |
| **Next.js monorepo**            | tRPC integrates seamlessly with Next.js using App Router + `@trpc/next`.                |
| **Admin portals & CMS**         | Admins need fast, type-safe dashboards with tightly coupled APIs.                       |
| **Hackathon or MVP products**   | Rapid prototyping with full end-to-end types and low setup.                             |

---

### üîπ gRPC

| Use Case                          | Description                                                                             |
| --------------------------------- | --------------------------------------------------------------------------------------- |
| **Real-time messaging/chat apps** | Bi-directional streaming for instant updates.                                           |
| **Streaming financial data**      | High-frequency, low-latency updates like live stock tickers or currency exchange rates. |
| **ML model serving**              | Data sent from browser/server to model servers efficiently with Protobufs.              |
| **IoT & edge devices**            | gRPC enables lightweight, efficient communication with devices over HTTP/2.             |

---

## üß™ CASE STUDIES (No STAR)

---

### üîπ 1. **GraphQL in Shopify Storefronts**

**Problem**: Shopify's REST API was too rigid. Developers struggled with over-fetching product data and making multiple requests for related objects.

**Solution**: Shopify introduced GraphQL Storefront API. Each frontend client could now request exactly what they needed ‚Äî product name, price, images, stock ‚Äî in one query.

**Outcome**:

* 40% reduction in network payload
* 60% fewer requests
* Improved dev velocity due to introspection and tooling

**Learning**:

> GraphQL is perfect for platforms offering composable UIs, especially in e-commerce and multi-device environments.

---

### üîπ 2. **tRPC in Vercel's Internal Dashboard**

**Problem**: Vercel engineers wanted full type safety without maintaining separate REST/GraphQL schemas across backend/frontend in their Next.js apps.

**Solution**: Migrated internal tools to **tRPC**, enabling developers to infer types from router definitions.

**Outcome**:

* Eliminated manual type definitions across API layers
* Autocomplete for API endpoints inside frontend editors
* Fewer runtime bugs, faster feature rollout

**Learning**:

> tRPC is an ideal choice for mono-repo dev teams using TypeScript, where API consumers and providers are tightly coupled.

---

### üîπ 3. **REST for GitHub API**

**Problem**: GitHub needed a stable, public-facing API accessible by developers worldwide using standard tools.

**Solution**: Built their API using REST with well-structured resource URIs, pagination, rate limits, and clear error semantics.

**Outcome**:

* Widespread adoption across CLI tools, web apps, CI/CD systems
* Easy to test/debug using browser and Postman
* Versioning and backward compatibility made rollout smooth

**Learning**:

> REST shines for stable, public APIs that must be consumed by diverse clients and languages.

---

### üîπ 4. **gRPC at Netflix for Media Metadata**

**Problem**: Netflix microservices needed to exchange metadata (e.g., user playback stats, encoding profiles) at scale and low latency.

**Solution**: Netflix moved internal service communication to **gRPC**, using Protobuf for strict schemas.

**Outcome**:

* Faster inter-service calls with HTTP/2 multiplexing
* Type-safe message contracts
* Support for streaming large datasets efficiently

**Learning**:

> gRPC is not just for backend ‚Äî with `grpc-web`, parts of its power can reach browsers, especially in high-frequency or binary use cases.

---

### üîπ 5. **Apollo Client Caching in React CRM**

**Problem**: A CRM system (customer relationship manager) built with React was re-fetching the same GraphQL data repeatedly, leading to lag and redundant requests.

**Solution**: Introduced **Apollo Client** with caching and normalized storage.

**Outcome**:

* Pages loaded \~2x faster
* Cache-first policies reduced backend load
* UI felt snappier when switching tabs or going offline

**Learning**:

> Smart caching at the frontend level (Apollo, React Query) can be just as critical as the choice of API architecture.

---

## <ins>STAR


### ‚≠ê 1. **GraphQL ‚Äì Optimizing a Product Dashboard**

**SITUATION**
At an e-commerce platform, we had a React-based product dashboard showing nested data: product details, variants, inventory, pricing, and supplier info. It was using a REST API that required 4‚Äì5 sequential calls per page load.

**TASK**
Improve performance and reduce complexity in fetching deeply nested product data, especially on mobile devices with slow connections.

**ACTION**
We migrated the data layer to **GraphQL**, designing a schema that let each React component declare its own data dependencies using fragments. We used Apollo Client with caching and local state management to handle loading states and pagination.

**RESULT**

* Reduced API calls from 5 to 1
* Payload size dropped by 30‚Äì40%
* Page load time improved by \~60%
* Developer onboarding became smoother due to introspection and type safety

---

### ‚≠ê 2. **tRPC ‚Äì Building an Internal Admin Portal**

**SITUATION**
At a SaaS startup using a monorepo with Next.js and TypeScript, the internal admin dashboard required frequent updates. Maintaining separate API types in backend and frontend became error-prone and repetitive.

**TASK**
Eliminate type mismatches and speed up feature development by improving the API layer.

**ACTION**
I led the transition to **tRPC**, defining routers per domain (`user`, `project`, `billing`) and auto-inferring types across frontend and backend. Integrated `@trpc/react-query` for caching, loading states, and optimistic updates.

**RESULT**

* Removed need for manual API typings
* Shipped new features 30% faster
* Bugs related to API contracts dropped to nearly zero
* Internal developer satisfaction improved dramatically

---

### ‚≠ê 3. **REST ‚Äì Refactoring a Legacy Reporting Interface**

**SITUATION**
An old internal reporting tool was built using jQuery and hitting REST endpoints directly. It lacked caching, and reports took 6‚Äì8 seconds to load with redundant API calls.

**TASK**
Modernize the frontend to React and reduce latency while keeping the existing REST API backend.

**ACTION**
I refactored the frontend using React + RTK Query. Grouped multiple REST endpoints into data-fetching slices with normalized caching. Used `selectFromResult` to minimize re-renders and added memoized selectors for complex data joins.

**RESULT**

* Report load time reduced to \~2.5 seconds
* UI performance improved significantly due to caching
* Enabled offline view mode using indexedDB + persisted cache
* No backend changes required

---

### ‚≠ê 4. **gRPC ‚Äì Integrating Real-Time ML Model Feedback in Frontend**

**SITUATION**
While working on an AI-powered document review system, we needed to get real-time ML predictions and confidence scores as the user edited a document in the browser.

**TASK**
Build a fast, streaming API channel to feed model predictions from a Python gRPC service into the React frontend.

**ACTION**
Set up a **gRPC-web** proxy using Envoy to bridge browser clients with the gRPC backend. Implemented bidirectional streaming and protobuf-generated TypeScript clients. Integrated this into the editor with non-blocking feedback UI.

**RESULT**

* Response time for model updates dropped to <500ms
* Allowed streaming feedback instead of polling
* Reduced frontend code complexity by using generated types
* Increased ML model engagement by 70% (users trusted feedback more due to instant response)

---

### ‚≠ê 5. **GraphQL ‚Äì Resolving Over-fetching in Multi-Role App**

**SITUATION**
In a multi-tenant education platform, students, teachers, and admins all used the same app, but REST APIs served the same bloated payload regardless of role.

**TASK**
Reduce over-fetching and improve personalization per user type.

**ACTION**
We introduced a **GraphQL API**, dynamically tailoring queries based on role context. Components used role-specific fragments, and permissions were enforced at the resolver level. Apollo cache was segmented by user role for isolation.

**RESULT**

* Payload sizes reduced by up to 55% for students
* 3x faster dashboard loads for teachers
* Increased data security (users saw only what they needed)
* Made future role-based features easier to implement

---


# üî∑ Advanced API Scenarios (STAR)


### ‚≠ê 1. **GraphQL Cursor-Based Pagination in News Feed**

**SITUATION**
In a social media-style news feed, we were fetching posts using REST with offset-based pagination (`?page=2&limit=10`). However, inconsistent ordering due to new posts being added led to duplicate or missing posts.

**TASK**
Ensure reliable, infinite-scroll pagination while reducing backend load and improving perceived performance.

**ACTION**
Migrated to **GraphQL cursor-based pagination** using `startCursor` and `endCursor`. Implemented Apollo Client's `fetchMore` with `updateQuery` to append posts. Used `relay-style` pagination patterns for compatibility.

**RESULT**

* Duplicate posts eliminated
* Pagination remained consistent despite frequent data inserts
* Page size reduced \~25% while delivering smoother UX
* Enabled easier implementation of reverse/infinite scroll

---

### ‚≠ê 2. **REST + File Upload with Presigned URLs (S3)**

**SITUATION**
In a document management system, users uploaded large PDFs. Uploading via REST `POST` to backend caused timeouts and bottlenecks.

**TASK**
Improve upload performance and reduce server load while maintaining secure uploads.

**ACTION**
Implemented **presigned URL upload** via REST. Client first made a `POST /upload-request` to get a short-lived S3 presigned URL, then used a direct `PUT` to S3. Progress bar added using `XMLHttpRequest` and event listeners.

**RESULT**

* Upload success rate improved by 98%
* Upload times reduced \~50%
* Backend CPU usage dropped significantly
* Enabled uploads >100MB without crashing

---

### ‚≠ê 3. **gRPC Streaming for Real-Time Error Feedback**

**SITUATION**
A frontend form collected large inputs (e.g., legal document drafts), which were then validated server-side via a gRPC API. The old flow waited for the entire form submission to return errors ‚Äî slow and user-unfriendly.

**TASK**
Provide **real-time streaming validation feedback** as users typed.

**ACTION**
Refactored API to use gRPC bidirectional streaming. The frontend connected using `grpc-web` and streamed field-level updates to the backend. Server responded with validation issues per keystroke. UI displayed inline errors with debouncing.

**RESULT**

* Time to display validation errors dropped to <200ms
* Reduced user frustration and retries
* Increased completion rate of long forms by 35%
* Paved way for future real-time NLP suggestions

---

### ‚≠ê 4. **tRPC Batching with React Query for Dashboard Widgets**

**SITUATION**
A dynamic dashboard had 10+ widgets, each making its own tRPC call. This caused excessive network traffic and degraded initial page load time.

**TASK**
Reduce redundant requests without sacrificing modular widget structure.

**ACTION**
Enabled **tRPC batching** via its built-in HTTP batching feature. Widgets still used separate hooks, but requests were auto-batched by `@trpc/react-query`. Also added SSR + cache hydration for further boost.

**RESULT**

* Reduced network requests from 12 to 2 on load
* 40% faster dashboard paint time
* Retained modular component-based development
* Improved Lighthouse performance score by 15 points

---

### ‚≠ê 5. **Offline Caching in GraphQL using Apollo Client**

**SITUATION**
A mobile-first educational app had poor connectivity in rural areas. Students were unable to view course content unless constantly online.

**TASK**
Allow users to browse previously viewed lessons offline and sync progress once back online.

**ACTION**
Used **Apollo Client with type policies** and `apollo3-cache-persist` to cache GraphQL responses in IndexedDB. Lessons and progress updates were stored offline. On reconnect, queued `mutations` were dispatched to sync progress.

**RESULT**

* Students could access 85% of their last-viewed content offline
* Sync conflicts were auto-resolved via last-write-wins
* Drop-off rates in low-connectivity areas decreased by 28%
* Enabled us to market the app as ‚Äúworks offline‚Äù

---

### ‚≠ê 6. **Robust Error Handling with REST and RTK Query**

**SITUATION**
A finance dashboard using REST API often failed silently when rate limits were hit or the server returned 5xx errors. Users were left confused without error messages.

**TASK**
Build resilient, user-friendly error boundaries with meaningful feedback.

**ACTION**
Centralized all API errors using RTK Query's `onError` callback. Standardized error responses in REST to include `errorCode`, `message`, and `meta`. Client displayed user-friendly messages and logged details to Sentry.

**RESULT**

* 100% of frontend errors surfaced cleanly
* User trust improved (they understood what went wrong)
* Reduced support tickets related to ‚Äúblank screen‚Äù or ‚Äústuck‚Äù errors
* Error analytics allowed backend to fix key bottlenecks

---

## <ins>Code Samples


Here are **Enterprise-style code snippets** for each of the STAR scenarios (Pagination, File Uploads, Batching, Error Handling, Offline Caching) using **REST**, **GraphQL**, **tRPC**, and **gRPC**.

---

# üî∑ 1. GraphQL ‚Äì Cursor-Based Pagination (Apollo Client)

```tsx
// ‚úÖ FEED QUERY WITH CURSOR-BASED PAGINATION

import { gql, useQuery } from "@apollo/client";

const FEED_QUERY = gql`
  query Feed($after: String) {
    feed(first: 10, after: $after) {
      edges {
        node {
          id
          title
          content
        }
        cursor
      }
      pageInfo {
        endCursor
        hasNextPage
      }
    }
  }
`;

function Feed() {
  const { data, fetchMore } = useQuery(FEED_QUERY);

  return (
    <div>
      {data?.feed?.edges.map(({ node }) => (
        <p key={node.id}>{node.title}</p>
      ))}
      {data?.feed?.pageInfo?.hasNextPage && (
        <button
          onClick={() =>
            fetchMore({
              variables: { after: data.feed.pageInfo.endCursor },
            })
          }
        >
          Load More
        </button>
      )}
    </div>
  );
}
```

---

# üî∑ 2. REST + File Upload Using Presigned URL (S3)

```tsx
// ‚úÖ GET PRESIGNED URL AND UPLOAD FILE

async function uploadFile(file) {
  // 1. Request a presigned URL
  const { uploadUrl, key } = await fetch("/api/upload-request", {
    method: "POST",
    body: JSON.stringify({ filename: file.name, type: file.type }),
  }).then(res => res.json());

  // 2. Upload directly to S3
  await fetch(uploadUrl, {
    method: "PUT",
    headers: {
      "Content-Type": file.type,
    },
    body: file,
  });

  console.log("File uploaded to S3 key:", key);
}
```

---

# üî∑ 3. gRPC-Web Streaming (Bidirectional)

```ts
// ‚úÖ gRPC-WEB STREAMING CLIENT (TypeScript)

import { DocumentValidatorClient } from './proto/DocumentValidatorServiceClientPb';
import { ValidateRequest } from './proto/document_pb';

const client = new DocumentValidatorClient("http://localhost:8080");

const stream = client.validateStream();

stream.on('data', response => {
  const field = response.getFieldname();
  const message = response.getMessage();
  showErrorOnField(field, message);
});

stream.on('end', () => {
  console.log("Validation complete");
});

// Send field updates as user types
function onInput(field, value) {
  const req = new ValidateRequest();
  req.setFieldname(field);
  req.setValue(value);
  stream.write(req);
}
```

> Requires Envoy or `grpcwebproxy` setup to bridge HTTP/2.

---

# üî∑ 4. tRPC Batching with React Query

```tsx
// ‚úÖ SERVER (Next.js App Router)

export const appRouter = createTRPCRouter({
  metrics: publicProcedure.query(() => fetchMetrics()),
  stats: publicProcedure.query(() => fetchStats()),
});

// ‚úÖ CLIENT CONFIG

const trpc = createTRPCReact<AppRouter>();

export const api = trpc.createClient({
  links: [
    httpBatchLink({
      url: "/api/trpc",
    }),
  ],
});

// ‚úÖ COMPONENT: widgets call trpc in isolation but batch happens under the hood

function Dashboard() {
  const metrics = api.metrics.useQuery();
  const stats = api.stats.useQuery();

  return (
    <div>
      <Widget title="Metrics" data={metrics.data} />
      <Widget title="Stats" data={stats.data} />
    </div>
  );
}
```

---

# üî∑ 5. GraphQL Offline Caching with Apollo + IndexedDB

```ts
// ‚úÖ SETUP

import { ApolloClient, InMemoryCache } from "@apollo/client";
import { persistCache } from "apollo3-cache-persist";
import localForage from "localforage";

const cache = new InMemoryCache();

await persistCache({
  cache,
  storage: localForage, // uses IndexedDB
});

const client = new ApolloClient({
  cache,
  uri: "/graphql",
  connectToDevTools: true,
});

// ‚úÖ React Usage

function CourseContent() {
  const { data, loading } = useQuery(COURSE_QUERY, { fetchPolicy: "cache-first" });

  if (loading) return <p>Loading...</p>;

  return <LessonRenderer lessons={data.course.lessons} />;
}
```

---

# üî∑ 6. REST + RTK Query ‚Äì Centralized Error Handling

```ts
// ‚úÖ API SLICE

import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: "/api",
    prepareHeaders: (headers) => {
      headers.set("Authorization", `Bearer ${getToken()}`);
      return headers;
    }
  }),
  endpoints: (builder) => ({
    getUser: builder.query<User, void>({
      query: () => "user",
    }),
  }),
});

// ‚úÖ GLOBAL ERROR HANDLING (optional)

api.middleware = (store) => (next) => (action) => {
  if (action.type.endsWith("rejected")) {
    const error = action.payload?.error;
    if (error) {
      toast.error(error.message || "Something went wrong");
      logErrorToSentry(error);
    }
  }
  return next(action);
};
```

---

## <ins> CIQnA

Here are **Enterprise-level common interview questions and answers** for:

---

# üî∑ Data Fetching & API Integration

### REST, GraphQL, tRPC, gRPC

Organized by concept and depth (L1‚ÄìL3):

---

## ‚úÖ GENERAL (ALL API TYPES)

---

### üîπ **Q1. What's the difference between REST, GraphQL, tRPC, and gRPC?**

**Answer**:

* **REST**: Resource-based, uses HTTP verbs (`GET`, `POST`, etc.), widespread, but can lead to over/under-fetching.
* **GraphQL**: Query language where the client asks for the exact shape of data. Solves over-fetching. Single endpoint.
* **tRPC**: Type-safe, end-to-end API layer using TypeScript inference. No schemas needed. Tight integration with frontend.
* **gRPC**: Binary RPC using Protobuf over HTTP/2. Efficient and used for microservices, not browser-native (needs gRPC-web).

---

### üîπ **Q2. What is over-fetching and under-fetching? How does GraphQL solve it?**

**Answer**:

* **Over-fetching**: Getting more data than needed (e.g., full user object when only email is required).
* **Under-fetching**: Not getting enough in one call, requiring multiple round-trips (e.g., fetching user ‚Üí then profile ‚Üí then posts).
* **GraphQL** solves both by letting clients request precisely the fields they need in a single query, including nested objects.

---

### üîπ **Q3. What are the main challenges in API integration from the frontend?**

**Answer**:

* Error handling and retry logic
* Type safety and schema changes
* Authentication and token expiry
* Performance (caching, batching, pagination)
* Versioning and backward compatibility
* Handling optimistic updates and loading states

---

## ‚úÖ REST-SPECIFIC QUESTIONS

---

### üîπ **Q4. How do you secure REST APIs on the frontend?**

**Answer**:

* Use **HTTPS** to encrypt transport.
* Pass tokens (OAuth2, JWT) in `Authorization` headers.
* Use **CSRF tokens** for browser-based apps.
* Handle token expiration via interceptors (e.g., Axios) and refresh silently.
* Sanitize all inputs before sending.

---

### üîπ **Q5. How would you handle file uploads in REST?**

**Answer**:

* For small files: Send using `multipart/form-data` with `FormData`.
* For large files: Use **presigned URLs** (e.g., from AWS S3) and upload directly using `PUT`.
* Track progress via `onUploadProgress` or `XMLHttpRequest`.

---

## ‚úÖ GRAPHQL-SPECIFIC QUESTIONS

---

### üîπ **Q6. How does Apollo Client manage caching?**

**Answer**:
Apollo uses a **normalized in-memory cache** where each object is stored using a unique `__typename:id` key.
It supports:

* `cache-first`, `network-only`, `cache-and-network` fetch policies
* `typePolicies` to customize merging and pagination
* Local state management similar to Redux (via reactive variables)

---

### üîπ **Q7. What are GraphQL fragments and why are they useful?**

**Answer**:
Fragments let you reuse field selections. They're great for:

* Reducing code duplication
* Component-level modular queries
* Enforcing consistent data shapes
  E.g.:

```graphql
fragment UserFields on User {
  id
  name
  email
}
```

---

### üîπ **Q8. How do you handle file uploads in GraphQL?**

**Answer**:

* Use `apollo-upload-client` which adds support for `multipart/form-data`.
* Server must implement [GraphQL multipart request spec](https://github.com/jaydenseric/graphql-multipart-request-spec).
* Uploads are typically sent as `File` scalar types.

---

## ‚úÖ tRPC-SPECIFIC QUESTIONS

---

### üîπ **Q9. How does tRPC achieve end-to-end type safety?**

**Answer**:
tRPC uses **TypeScript inference** from procedure definitions.

* Backend procedures define `input` and `output`.
* Frontend automatically infers types via generated hooks using `@trpc/react-query`.
  There are **no separate schemas**, which avoids duplication.

---

### üîπ **Q10. Can tRPC be used in large or public apps?**

**Answer**:
It‚Äôs best for **monorepos or internal tools**.
Challenges in public APIs:

* No versioning mechanism like REST
* Not language-agnostic
* Cannot consume from mobile/Java/Python clients easily
  For external APIs, REST or GraphQL is preferred.

---

## ‚úÖ gRPC-SPECIFIC QUESTIONS

---

### üîπ **Q11. What are the advantages of gRPC over REST?**

**Answer**:

* **Binary format** (Protocol Buffers) ‚Üí faster & smaller payloads
* **HTTP/2** ‚Üí multiplexing, streaming, better performance
* **Strong typing** from `.proto` schemas
* **Streaming support** (client ‚Üí server, server ‚Üí client, or bidirectional)

---

### üîπ **Q12. Can you use gRPC in the browser?**

**Answer**:
Not directly ‚Äî browsers don‚Äôt support raw HTTP/2 and Protobuf.
You need:

* A **gRPC-Web proxy** (Envoy, grpc-web-proxy)
* Use `grpc-web` client libraries that communicate via `POST`/XHR behind the scenes
  Alternatives: translate to REST or use WebSockets

---

## ‚úÖ PERFORMANCE + DEV EXPERIENCE

---

### üîπ **Q13. How do you optimize API performance on the frontend?**

**Answer**:

* Use **React Query/Apollo/tRPC batching**
* Enable **client-side caching** with revalidation
* Apply **pagination**, **infinite scrolling**, or **lazy loading**
* Use **debounce/throttle** for search or user typing
* Compress payloads and avoid unnecessary fields

---

### üîπ **Q14. How do you handle error boundaries for APIs in React?**

**Answer**:

* Use centralized hooks or interceptors (Axios, RTK Query, Apollo)
* Create reusable components for `ErrorFallback`, `RetryButton`, etc.
* Log to Sentry/Datadog
* Classify errors: user error (400), auth error (401), server error (500)

---


## L4/L5 system design questions
  
Here are **Enterprise-level L4/L5 Frontend-focused System Design Questions and Answers** tailored to roles involving **Data Fetching & API Integration** using **REST, GraphQL, tRPC, and gRPC**.

---

# üî∑ System Design Interview (L4 / L5)

### Frontend Engineering ‚Äì API Integration & Data Layer Design

---

## ‚úÖ Q1: **Design the data fetching architecture for a complex dashboard with 20+ widgets.**

### üß† What They‚Äôre Testing:

* Network optimization
* API design decisions (batching, deduplication)
* Reusability and caching strategies

### ‚úÖ Answer Summary:

**Key Components**:

* Use **React Query or Apollo Client** for normalized cache & request deduplication.
* Each widget gets its own data hook but shares the **query client context**.
* Enable **automatic batching**:

  * tRPC ‚Üí use `httpBatchLink`
  * GraphQL ‚Üí use persisted queries with `@apollo/client`
* Lazy load below-the-fold widgets with IntersectionObserver.
* Defer non-critical data via `suspense` or `defer()` in Next.js (App Router).

**Additional Enhancements**:

* Use WebSockets or subscriptions for real-time widgets.
* Enable caching with TTL and revalidation (stale-while-revalidate).
* Add a global error boundary and skeleton loader fallback.

---

## ‚úÖ Q2: **How would you build a type-safe API integration layer in a large monorepo app?**

### üß† What They‚Äôre Testing:

* Long-term maintainability
* Developer experience
* Handling schema drift and contract mismatch

### ‚úÖ Answer Summary:

**If using TypeScript end-to-end**:

* Use **tRPC** in monorepo (e.g., Next.js + backend), no schema duplication.
* Split routers by domain (`user`, `product`, `billing`) for scalability.
* Infer types directly in frontend using `@trpc/react-query`.
* Add Zod validations on the server to guard against invalid input.

**If backend is polyglot or remote**:

* Use **OpenAPI schema** with tools like [orval](https://orval.dev/) to generate hooks with types.
* Use GraphQL codegen if backend provides a schema.
* Enforce **CI contracts** using typecheck or schema validation at deploy time.

---

## ‚úÖ Q3: **Design a file upload experience for a design collaboration app (e.g., Figma clone).**

### üß† What They‚Äôre Testing:

* Handling large payloads
* Real-time sync
* Security and scalability

### ‚úÖ Answer Summary:

**File Upload Path**:

1. User selects files ‚Üí client sends `POST /upload-url` to get a presigned S3 URL.
2. Use direct `PUT` upload to S3 with progress tracking.
3. After upload, client notifies backend (`POST /file/complete`) to store metadata.

**Tech Choices**:

* Use `FormData` for small files and chunked upload for large files.
* Display real-time upload progress.
* Use **WebSocket or gRPC streaming** to sync file status across multiple collaborators.

**Security**:

* Presigned URL expires in 5 min
* Limit file types and validate MIME types both on client and backend
* Scan uploaded files for malware

---

## ‚úÖ Q4: **Design a low-latency data sync layer for a real-time collaborative document editor.**

### üß† What They‚Äôre Testing:

* gRPC, WebSockets, GraphQL Subscriptions
* State reconciliation
* CRDT vs OT (conflict resolution)

### ‚úÖ Answer Summary:

**Transport Layer**:

* Use **gRPC** for client-server and server-server communication.
* On frontend, use **gRPC-Web** or WebSockets for bidirectional updates.

**Frontend Strategy**:

* Maintain a local shadow copy of the document state.
* Use a **CRDT** engine like Automerge or Yjs for conflict-free editing.
* Debounce keystrokes and batch updates every 100ms.
* Sync changes using `applyRemoteUpdate()` method with patching.

**Scaling**:

* Use a pub-sub system (Kafka or Redis Streams) to fan-out document updates to multiple users.
* Use `documentId` based sharding for multi-tenancy.

---

## ‚úÖ Q5: **How would you migrate a REST API frontend to GraphQL without breaking production?**

### üß† What They‚Äôre Testing:

* API migration strategy
* Risk management
* Performance planning

### ‚úÖ Answer Summary:

**Phase 1: Side-by-side integration**

* Introduce GraphQL client (Apollo/urql) while keeping REST untouched.
* For shared data, create GraphQL wrappers that internally call REST endpoints (BFF or Gateway).

**Phase 2: Incremental adoption**

* Migrate one domain at a time (`user`, `profile`, `notifications`)
* Use GraphQL fragments per page/component
* Track usage and performance with Apollo Studio or OpenTelemetry

**Phase 3: Cutover & cleanup**

* Once adoption >90%, deprecate REST endpoints
* Ensure cache strategy is ported
* Refactor loading states and error handling to match GraphQL idioms

**Fallback Strategy**:

* Keep legacy fallback in case GraphQL goes down
* Consider federation if other services use REST/GraphQL hybrid

---

## ‚úÖ Q6: **Design a mobile-first app that works offline and syncs data when reconnected.**

### üß† What They‚Äôre Testing:

* Caching, service workers, background sync
* Data conflict resolution
* Storage architecture

### ‚úÖ Answer Summary:

**Frontend Caching**:

* Use IndexedDB with `localforage` or `apollo3-cache-persist`
* Store pending mutations in queue
* Listen for `navigator.onLine` to trigger re-sync

**Sync Engine**:

* On reconnect, flush the mutation queue:

  * Use optimistic updates + rollback if sync fails
  * Merge with server state using `last-write-wins` or versioned patches

**Tech Stack**:

* Service workers for caching static assets
* Apollo Client (GraphQL) or RTK Query with custom cache sync
* Background sync via Workbox

**Example Use Case**:

> ‚ÄúSubmit attendance while offline and sync with server when back online ‚Äî even if the app was closed.‚Äù

---

## ‚úÖ Q7: **How would you handle 100+ API calls in a product detail page for a marketplace?**

### üß† What They‚Äôre Testing:

* API composition, performance bottlenecks, BFF usage

### ‚úÖ Answer Summary:

**Don‚Äôt make 100 requests from the browser. Instead:**

* Create a **Backend For Frontend (BFF)** to aggregate calls into 1‚Äì3 requests.
* Compose APIs: fetch `product`, `inventory`, `reviews`, `price`, etc., in parallel on server.
* Return only the needed subset to the frontend.

**Use batching on the frontend**:

* GraphQL: fragments with query batching
* tRPC: enable `httpBatchLink`
* REST: group requests using parallel `Promise.all`

**Additional Tactics**:

* Lazy load low-priority widgets
* Memoize shared data (e.g., categories, user info)
* Use CDN and cache headers for static resources







