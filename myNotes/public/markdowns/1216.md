
# üî∑ Common Interview Questions ‚Äî Detailed Answers

---

## 1. Difference between `CrudRepository`, `JpaRepository`, and `PagingAndSortingRepository`

* **`CrudRepository<T, ID>`**

  * Base interface for CRUD operations.
  * Methods: `save()`, `findById()`, `deleteById()`, `count()`.
  * Minimal set of features.

* **`PagingAndSortingRepository<T, ID>`**

  * Extends `CrudRepository`.
  * Adds pagination & sorting support.
  * Methods: `findAll(Pageable pageable)`, `findAll(Sort sort)`.

* **`JpaRepository<T, ID>`**

  * Extends `PagingAndSortingRepository`.
  * Adds **JPA-specific features**:

    * Batch operations (`saveAllInBatch`, `deleteInBatch`).
    * `getOne()` / `getById()` (lazy reference).
    * Flush control (`flush()`).
  * Most commonly used in Spring Boot projects.

üëâ **Rule of Thumb**: Use `JpaRepository` unless you need only minimal features.

---

## 2. How does Spring Data JPA generate queries from method names?

Spring Data JPA parses **method names** in repositories and derives queries.

### Example

```java
List<User> findByLastNameAndStatusOrderByCreatedAtDesc(String lastName, String status);
```

Generates JPQL:

```sql
SELECT u FROM User u WHERE u.lastName = ?1 AND u.status = ?2 ORDER BY u.createdAt DESC
```

**Keywords** drive query generation:

* `findBy`, `existsBy`, `countBy`, `deleteBy`
* Conditions: `And`, `Or`, `Between`, `LessThan`, `Like`, `In`, `IsNull`
* Sorting: `OrderBy<Field><Asc|Desc>`

üëâ Great for simple queries, but complex conditions ‚Üí prefer `@Query` or Criteria API.

---

## 3. How to optimize JPA queries to avoid N+1 select problem?

**N+1 problem**: Fetching parent entities and lazily accessing children triggers one query for parent + N queries for children.

### Example

```java
List<User> users = userRepo.findAll();
for (User u : users) {
    System.out.println(u.getOrders().size()); // N additional queries
}
```

### Solutions

1. **Fetch Joins (`JOIN FETCH`)**

```java
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();
```

2. **`@EntityGraph`**

```java
@EntityGraph(attributePaths = {"orders"})
List<User> findAll();
```

3. **Projections (DTOs)**

```java
@Query("SELECT new com.dto.UserOrderDTO(u.name, COUNT(o)) FROM User u JOIN u.orders o GROUP BY u")
List<UserOrderDTO> fetchUserOrders();
```

üëâ Best practice: Default to `LAZY` relationships, override with **fetch joins / entity graphs** only where needed.

---

## 4. Explain projections in Spring Data JPA.

**Projection = Fetch subset of entity fields instead of the full entity** ‚Üí reduces data transfer & avoids loading unnecessary associations.

### Types:

1. **Interface-based**

```java
public interface UserSummary {
    String getName();
    String getEmail();
}
List<UserSummary> findByStatus(String status);
```

2. **DTO-based**

```java
public record UserDTO(String name, String email) {}
@Query("SELECT new com.dto.UserDTO(u.name, u.email) FROM User u")
List<UserDTO> findAllUserSummaries();
```

3. **Dynamic Projections**

```java
<T> List<T> findByStatus(String status, Class<T> type);
```

üëâ **Enterprise Best Practice**: Always use projections for **read-heavy APIs** instead of returning full entities.

---

## 5. How would you implement dynamic filtering in repositories?

### Approaches

1. **Specifications API**

```java
public class UserSpecs {
    public static Specification<User> hasStatus(String status) {
        return (root, query, cb) -> cb.equal(root.get("status"), status);
    }
}
List<User> result = userRepo.findAll(Specification.where(hasStatus("ACTIVE")));
```

2. **Criteria API** (for advanced dynamic queries)

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<User> cq = cb.createQuery(User.class);
Root<User> root = cq.from(User.class);
cq.where(cb.equal(root.get("status"), "ACTIVE"));
```

3. **Querydsl** (third-party, type-safe queries).

üëâ Best practice: Use **Specifications** for Spring-friendly dynamic filtering.

---

## 6. What are the trade-offs between `@Query` and derived queries?

* **Derived Queries**

  * ‚úÖ Less boilerplate, quick to implement.
  * ‚úÖ Good for simple queries (`findByNameAndStatus`).
  * ‚ùå Hard to read when method names become long.

* **`@Query`**

  * ‚úÖ More control (custom JPQL/SQL).
  * ‚úÖ Handles complex joins, subqueries.
  * ‚ùå Harder to refactor (string-based queries).

üëâ Rule: Use **derived queries for simple cases**, `@Query` for complex scenarios.

---

## 7. How do entity graphs help improve performance?

**Entity Graphs** tell JPA what associations to fetch eagerly for a given query, **without changing entity mapping**.

### Example

```java
@EntityGraph(attributePaths = {"orders", "profile"})
List<User> findByStatus(String status);
```

Generates:

```sql
SELECT u.*, o.*, p.* FROM users u 
LEFT JOIN orders o ON u.id = o.user_id 
LEFT JOIN profiles p ON u.id = p.user_id
```

‚úÖ Solves N+1 problem.
‚úÖ Flexible ‚Üí avoids hardcoding `EAGER` in entity mapping.

---

## 8. Can you mix custom repository logic with auto-generated methods? How?

Yes ‚úÖ

* Define a repository interface extending `JpaRepository`.
* Add custom repository interface with extra methods.
* Provide an implementation class.

### Example

```java
public interface UserRepository extends JpaRepository<User, Long>, UserRepositoryCustom {}

public interface UserRepositoryCustom {
    List<User> findActiveUsersCustom();
}

@Repository
public class UserRepositoryImpl implements UserRepositoryCustom {
    @PersistenceContext private EntityManager em;

    @Override
    public List<User> findActiveUsersCustom() {
        return em.createQuery("SELECT u FROM User u WHERE u.active = true", User.class).getResultList();
    }
}
```

üëâ This way, you can **mix Spring Data auto-generated queries with hand-written ones**.

---

## 9. How does `@Transactional` behave at repository vs service layer?

* **Repository Layer**

  * Usually **not marked with `@Transactional`** explicitly.
  * Spring Data repositories already run inside transaction boundaries for CRUD methods.

* **Service Layer**

  * Best practice: Annotate at **service layer** (business logic).
  * Gives better control over transactional boundaries across multiple repository calls.

üëâ Example:

```java
@Transactional
public void placeOrder(User user, Order order) {
    userRepo.save(user);
    orderRepo.save(order); // both succeed or both rollback
}
```

‚úÖ Enterprise best practice: Keep **transaction boundaries at service layer**.

---

## 10. Differences between Native Queries, JPQL, and Criteria API

* **JPQL (Java Persistence Query Language)**

  * Entity-oriented query language.
  * Works on **entity objects, not tables**.
  * Portable across databases.

  ```java
  @Query("SELECT u FROM User u WHERE u.email = :email")
  ```

* **Native SQL Queries**

  * Raw SQL directly against DB.
  * DB-specific ‚Üí not portable.
  * Needed for advanced features (window functions, DB extensions).

  ```java
  @Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
  ```

* **Criteria API**

  * Programmatic, type-safe query building.
  * Useful for **dynamic queries**.

  ```java
  CriteriaBuilder cb = em.getCriteriaBuilder();
  CriteriaQuery<User> cq = cb.createQuery(User.class);
  Root<User> root = cq.from(User.class);
  cq.where(cb.equal(root.get("status"), "ACTIVE"));
  ```

üëâ Rule of Thumb:

* Use **JPQL** ‚Üí default, readable, portable.
* Use **Native SQL** ‚Üí when DB-specific features needed.
* Use **Criteria API** ‚Üí dynamic queries, complex filters.

---

# ‚úÖ Summary ‚Äî Enterprise-Level Interview Takeaways

1. **Repositories hierarchy**: Crud < Paging < JPA.
2. **Method name queries** ‚Üí great for simple lookups.
3. **Avoid N+1** ‚Üí use fetch joins, entity graphs, projections.
4. **Projections** ‚Üí optimize read-heavy queries.
5. **Dynamic filtering** ‚Üí Specifications / Criteria API.
6. **`@Query` vs Derived** ‚Üí trade-off between readability and flexibility.
7. **EntityGraph** ‚Üí powerful for performance tuning.
8. **Custom repo impls** ‚Üí possible & common.
9. **Transactional boundaries** ‚Üí always at service layer.
10. **JPQL vs SQL vs Criteria API** ‚Üí portability vs power vs flexibility.


