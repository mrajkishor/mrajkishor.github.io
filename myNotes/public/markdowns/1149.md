
# 🔷 Union-Find (Disjoint Set Union - DSU)

---

## ✅ 1. **Concept**

The **Union-Find** data structure (also called **Disjoint Set Union - DSU**) is used to **track a set of elements partitioned into a number of disjoint (non-overlapping) subsets**.

It supports two primary operations:

* **Find(x)** → Determine the representative (root) of the set containing element `x`.
* **Union(x, y)** → Merge the sets containing `x` and `y`.

It’s the backbone of efficient **graph connectivity algorithms**, especially when dealing with:

* Dynamic connectivity
* Cycle detection
* Minimum spanning trees (like Kruskal’s Algorithm)
* Grid unions (like in "Number of Islands" problems)

---

## 🧠 2. **Real-World Analogy**

Imagine students grouped into clubs. Each student belongs to only one club at a time. You need to:

* Find out which club a student belongs to
* Merge two clubs together

---

## ⚙️ 3. **Core Operations**

### ✅ `Find(x)` – Path Compression (Optimized)

Finds the representative of the set containing `x`. With **path compression**, we flatten the tree during lookup, making future lookups faster.

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])  # Path compression
    return parent[x]
```

### ✅ `Union(x, y)` – Union by Rank / Size

Merges two disjoint sets by attaching the shorter tree to the root of the taller tree to avoid creating tall trees.

```python
def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x == root_y:
        return
    if rank[root_x] > rank[root_y]:
        parent[root_y] = root_x
    elif rank[root_x] < rank[root_y]:
        parent[root_x] = root_y
    else:
        parent[root_y] = root_x
        rank[root_x] += 1
```

---

## ⏱️ 4. **Time and Space Complexity**

| Operation        | Complexity |
| ---------------- | ---------- |
| `find(x)`        | `O(α(n))`  |
| `union(x, y)`    | `O(α(n))`  |
| Space Complexity | `O(n)`     |

> `α(n)` is the **inverse Ackermann function**, which grows extremely slowly (practically constant for all real-world inputs).

---

## 🔩 5. **Use Cases and Applications**

### ✅ Graph Problems

* **Connected Components** (`Number of Provinces`, `Friend Circles`)
* **Cycle Detection** in undirected graphs
* **Minimum Spanning Tree** (Kruskal's algorithm)
* **Dynamic Connectivity** (online union queries)

### ✅ Grid Problems

* **Number of Islands**
* **Percolation Systems**
* **Flood Fill Variants**

### ✅ Other Domains

* **Network Connectivity**
* **Image Segmentation**
* **Clustering algorithms** in Machine Learning

---

## 💡 6. Optimizations

### ✅ Path Compression

Compresses the tree height during `find()` → almost constant-time queries.

### ✅ Union by Rank / Size

Always attach the smaller tree under the bigger one → avoids skewed trees.

These two optimizations **combined** result in **near-constant time operations**, formally `O(α(n))`.

---

## 🚧 7. Limitations

* Not designed to **remove** elements from sets.
* Not suited for problems where sets overlap (non-disjoint).
* For directed graphs (like detecting cycles), needs careful adaptation or different structures (e.g., Tarjan’s Algorithm).

---

## 📦 8. Python Implementation (Clean Version)

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX == rootY:
            return False  # Already connected
        if self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
        elif self.rank[rootX] > self.rank[rootY]:
            self.parent[rootY] = rootX
        else:
            self.parent[rootY] = rootX
            self.rank[rootX] += 1
        return True
```


## Java Implementation 

### ✅ Java Code — UnionFind / Disjoint Set Union

```java 

public class UnionFind {
    private int[] parent;
    private int[] rank;

    // Constructor to initialize parent and rank
    public UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];

        // Initially, each node is its own parent
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0; // Optional, default is 0
        }
    }

    // Find with path compression
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    // Union by rank
    public boolean union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        // Already in the same set
        if (rootX == rootY) {
            return false;
        }

        // Union by rank
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }

        return true;
    }

    // Test the UnionFind class
    public static void main(String[] args) {
        int n = 5; // Number of elements
        UnionFind uf = new UnionFind(n);

        // Union operations
        uf.union(0, 1);
        uf.union(1, 2);
        uf.union(3, 4);

        // Check connections
        System.out.println("Is 0 connected to 2? " + (uf.find(0) == uf.find(2))); // true
        System.out.println("Is 0 connected to 4? " + (uf.find(0) == uf.find(4))); // false

        // Connecting 2 and 4
        uf.union(2, 4);
        System.out.println("Is 0 connected to 4 now? " + (uf.find(0) == uf.find(4))); // true
    }
}
```

> Output:
> Is 0 connected to 2? true
Is 0 connected to 4? false
Is 0 connected to 4 now? true


---

### ✅ Example Usage (e.g. Leetcode 547 — Number of Provinces)

```java
public class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        UnionFind uf = new UnionFind(n);

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    uf.union(i, j);
                }
            }
        }

        Set<Integer> uniqueProvinces = new HashSet<>();
        for (int i = 0; i < n; i++) {
            uniqueProvinces.add(uf.find(i));
        }

        return uniqueProvinces.size();
    }
}
```


---

## 🧪 9. Problem Examples

| Problem                                                                                                                               | Description                              |
| ------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| [547. Number of Provinces](https://leetcode.com/problems/number-of-provinces/)                                                        | Count disjoint sets (connected groups)   |
| [684. Redundant Connection](https://leetcode.com/problems/redundant-connection/)                                                      | Cycle detection in undirected graph      |
| [1319. Number of Operations to Make Network Connected](https://leetcode.com/problems/number-of-operations-to-make-network-connected/) | Minimum operations to connect components |
| [990. Satisfiability of Equality Equations](https://leetcode.com/problems/satisfiability-of-equality-equations/)                      | Apply DSU to symbolic equality reasoning |

---

## 🧩 10. Advanced Variants

### ✅ DSU on Trees (Heavy-Light Decomposition)

Used in segment trees and LCA (Lowest Common Ancestor) problems.

### ✅ Persistent DSU

Used in version-controlled environments (e.g., rollbacks in time-travel queries).

### ✅ Weighted DSU

Attach weights to edges and support range queries.

---

## 💬 11. Common Interview Traps

| Trap                                                | Fix                                                |
| --------------------------------------------------- | -------------------------------------------------- |
| Forgetting to compress paths in `find()`            | Always apply `parent[x] = find(parent[x])`         |
| Not using `union by rank/size`                      | Causes poor performance on skewed trees            |
| Thinking DSU works on **directed** graphs           | DSU is designed for **undirected** graphs          |
| Using `union()` blindly without checking connection | Use return value to detect already-connected nodes |

---

## 🔚 Summary

| Feature           | Description                                             |
| ----------------- | ------------------------------------------------------- |
| Data Structure    | Union-Find / Disjoint Set Union                         |
| Primary Use       | Track connectivity between disjoint sets                |
| Operations        | `find()`, `union()`                                     |
| Optimizations     | Path Compression + Union by Rank/Size                   |
| Time Complexity   | Nearly `O(1)` for most real inputs                      |
| Use in Interviews | Cycle detection, MST, clustering, islands, connectivity |
| Advanced Use      | Version control, DSU on trees, grid unions              |

---

Would you like a **visual animation**, **case study**, or **interview-specific STAR scenario** using DSU next?
