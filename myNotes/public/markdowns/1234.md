
# 🔷 Sum of First N Numbers 

---

## 1. Problem Statement

Given a number `N`, compute the sum:

$$
S = 1 + 2 + 3 + \dots + N
$$

Example:

* Input: `N = 5`
* Output: `15`
  (Because 1+2+3+4+5 = 15)

---

## 2. Approaches

### ✅ Approach 1: Mathematical Formula

The most optimal solution uses the **Gauss formula**:

$$
S = \frac{N \times (N+1)}{2}
$$

**Code (O(1) time, O(1) space):**

```java
int sumFormula(int n) {
    return n * (n + 1) / 2;
}
```

**Complexity:**

* Time → O(1)
* Space → O(1)

**Insight:**

* This is the **most optimal** solution.
* However, beware of **integer overflow** if `N` is large (`n*(n+1)` may exceed `int` range). Use `long` in Java.

---

### ✅ Approach 2: Iterative (Loop-based)

Sum numbers using a simple loop.

**Code (O(N) time, O(1) space):**

```java
int sumIterative(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

**Complexity:**

* Time → O(N)
* Space → O(1)

**Insight:**

* Iterative solutions are safe from stack overflow.
* Still less efficient than formula (but better for extensions like `sum of first N odd numbers`).

---

### ✅ Approach 3: Recursive (Basic Recursion)

Use recursion directly.

**Code (O(N) time, O(N) stack space):**

```java
int sumRecursive(int n) {
    if (n == 0) return 0;     // base case
    return n + sumRecursive(n - 1);
}
```

**Complexity:**

* Time → O(N)
* Space → O(N) (stack depth)

**Insight:**

* Clean & intuitive, but not efficient for very large N.
* Interviewers may ask: “What happens if `N=10^6`?” → **StackOverflowError** in Java.

---

### ✅ Approach 4: Tail Recursion

Optimized recursion where the recursive call is the last operation (in theory allows tail-call optimization).

**Code:**

```java
int sumTailRecursive(int n, int acc) {
    if (n == 0) return acc;
    return sumTailRecursive(n - 1, acc + n);
}

public static void main(String[] args) {
    System.out.println(sumTailRecursive(5, 0));  // prints 15
}
```

**Complexity:**

* Time → O(N)
* Space → O(N) in Java (since Java doesn’t guarantee tail recursion optimization).

**Insight:**

* In functional languages (Scala, Haskell, Scheme), this would run in O(1) space.
* In Java, still risks stack overflow.

---

### ✅ Approach 5: Functional / Streams (Java 8+)

Use Java Streams API.

**Code:**

```java
import java.util.stream.IntStream;

int sumStream(int n) {
    return IntStream.rangeClosed(1, n).sum();
}
```

**Complexity:**

* Time → O(N)
* Space → O(1)

**Insight:**

* Demonstrates knowledge of **modern Java features**.
* Under the hood, still iterative.

---

## 3. Complexity Comparison

| Approach          | Time Complexity | Space Complexity | Notes                                       |
| ----------------- | --------------- | ---------------- | ------------------------------------------- |
| Formula           | O(1)            | O(1)             | Best & safest (use long to avoid overflow). |
| Iterative Loop    | O(N)            | O(1)             | Reliable, no stack risk.                    |
| Recursion         | O(N)            | O(N)             | Elegant but stack heavy.                    |
| Tail Recursion    | O(N)            | O(N) in Java     | Would be O(1) in optimized compilers.       |
| Streams (Java 8+) | O(N)            | O(1)             | Concise & modern.                           |

---

## 4. Interview Variations (Tricky)

* **Sum of first N odd numbers** = $N^2$.
* **Sum of first N even numbers** = $N(N+1)$.
* **Sum of squares (1² + 2² + … + N²)** = $\frac{N(N+1)(2N+1)}{6}$.
* **Sum of cubes (1³ + 2³ + … + N³)** = $\left(\frac{N(N+1)}{2}\right)^2$.
* **Big-O Follow-up:** Which method scales better for `N=10^9`? → Only **formula-based** is feasible.

---

## 5. Interview Tips

1. **Start simple:** Show iterative solution.
2. **Then optimize:** Introduce formula and explain why O(1) is better.
3. **Discuss trade-offs:** Mention recursion limits and stack overflow risk.
4. **Edge cases:** Handle `N=0`, negative inputs.
5. **Overflow discussion:** Use `long` or `BigInteger` for large N.

---

## 🔑 Key Takeaway

* Best solution: **Mathematical Formula (O(1))**.
* Iterative: Good fallback when problem modifies rules.
* Recursion: ==Nice for theory, but impractical for large `N`.==
* Streams: Modern, expressive, but not more efficient.

This problem is often a **warm-up** in interviews — but how you **extend and optimize** your solution shows your depth.

