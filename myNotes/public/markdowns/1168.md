

# **Execution Context & Lexical Environment**

## **1. What is an Execution Context?**

An **Execution Context (EC)** is the internal “container” the JavaScript engine creates whenever it runs code.
It defines **how** and **where** variables, functions, and objects are accessed, and how the **scope chain** is built.

You can think of an EC as a **runtime workspace** containing:

1. **Lexical Environment** → where block-scoped (`let`, `const`, `class`) variables live.
2. **Variable Environment** → where function-scoped (`var`, function declarations) variables live.
3. **This binding** → determines what `this` refers to in the current context.
4. **Outer Environment Reference** → link to the parent’s scope (for variable lookup).
5. **Additional metadata** → `new.target`, `super`, `arguments` (for function ECs).

---

## **2. Types of Execution Context**

There are **three** primary EC types:

### 1. **Global Execution Context (GEC)**

* Created **once** when JS starts running.
* Creates the **global object** (`window` in browsers, `global` in Node).
* Sets up the **global scope**.
* In non-module scripts:

  * `var` attaches to the global object.
  * `let`/`const` create bindings in the global **Lexical Environment** only.
* In modules:

  * Top-level bindings are **module-scoped** (not global object properties).
  * `this` is `undefined` at top-level.

### 2. **Function Execution Context (FEC)**

* Created when a function is invoked.
* Includes:

  * **Arguments object** (except in arrow functions).
  * **Function Environment Record** for params, vars, inner functions.
  * Own `this` binding (if non-arrow).
* Has an **Outer Environment Reference** pointing to the scope where the function was declared (lexical scoping).

### 3. **Eval Execution Context**

* Created when code is run inside `eval()`.
* Can execute in global or function scope.
* Discouraged: slows optimization, breaks static analysis.

---

## **3. Lifecycle of an Execution Context**

### **A. Creation Phase** (a.k.a. “Hoisting” step)

* **Lexical Environment (LE)** and **Variable Environment (VE)** are created.
* Variables & functions are **registered**:

  * `var` → in VE, initialized to `undefined`.
  * Function declarations → in VE, initialized to function object.
  * `let`/`const`/`class` → in LE, uninitialized (**TDZ** until execution reaches them).
* `this` binding is set:

  * Global EC → global object (or `undefined` in strict mode/modules).
  * Function EC → depends on call site (or `undefined` in strict mode).
* Outer Environment Reference is stored.

### **B. Execution Phase**

* Code is executed line-by-line.
* Assignments update bindings in LE/VE.
* Variable lookups follow the **scope chain**: current EC → parent EC → … → global.

---

## **4. Lexical Environment: The Heart of Scoping**

A **Lexical Environment** is a spec-defined structure:

```js
LexicalEnvironment = {
  EnvironmentRecord: { /* identifier bindings */ },
  Outer: <reference to parent LE>
}
```

* **EnvironmentRecord**: a table mapping variable names to their values (and flags for mutability/configurability).

  * **Declarative Environment Record** → for `let`, `const`, `class`, function parameters.
  * **Object Environment Record** → wraps an object’s properties (global object, `with`).
  * **Function Environment Record** → declarative + `this`/`super`/`new.target` bindings.
  * **Module Environment Record** → for ES module `import`/`export` bindings.
* **Outer**: pointer to the parent lexical environment (forms the **scope chain**).

---

## **5. Variable Environment vs Lexical Environment**

Although both are environment structures, the spec distinguishes them for historical reasons:

| Variable Environment                  | Lexical Environment                                        |
| ------------------------------------- | ---------------------------------------------------------- |
| Holds `var` and function declarations | Holds `let`, `const`, `class`, block-scoped function decls |
| Function/global scope                 | Block scope                                                |
| Hoisted, initialized to `undefined`   | Hoisted, uninitialized (TDZ)                               |
| No TDZ                                | TDZ applies                                                |

In many engines, VE and LE are optimized into a single structure, but **the rules still differ** for variable resolution.

---

## **6. Scope Chain Resolution**

When resolving an identifier:

1. Look in the **current EC’s** LE (block scope variables).
2. If not found, look in its VE (function-scoped vars).
3. If still not found, follow **Outer** reference to the parent EC’s LE, repeat.
4. If the chain ends (global EC) without finding it → `ReferenceError`.

Example:

```js
let a = 1;
function outer() {
  let b = 2;
  function inner() {
    let c = 3;
    console.log(a, b, c);
  }
  inner();
}
outer();
```

Resolution inside `inner()`:

```
c → inner’s LE
b → outer’s LE
a → global LE
```

---

## **7. Closures & Environment Persistence**

A closure is simply a function **retaining access** to its creation environment even after that environment’s EC is gone.

```js
function makeCounter() {
  let count = 0; // stays in memory
  return () => ++count;
}
const inc = makeCounter();
inc(); // 1
inc(); // 2
```

Here, `count` lives in `makeCounter`’s LE, which is preserved because the returned function still references it.

---

## **8. Special Cases & Gotchas**

* **TDZ (Temporal Dead Zone)**: accessing a `let`/`const` before its declaration → `ReferenceError`.
* **Shadowing**: inner bindings with same name hide outer ones (can cause TDZ inside inner block).
* **Per-iteration scope**: `let` in loops creates a new LE each iteration; `var` shares one binding.
* **Block-scoped function decls**: in strict mode, they live in the block LE, not the function/global scope.
* **Modules**: each has its own LE; imports/exports are *live bindings* with TDZ rules.
* **With statement**: injects an Object Environment Record into the chain (kills optimizations).

---

## **9. Real-World Memory Implications**

* Long-lived closures can retain large structures in memory if they’re referenced in their LE.
* Avoid capturing unneeded variables in closures for better GC.
* Break references (set to `null`) when you no longer need them.

---

## **10. Interview-Trick Examples**

### Example 1: `var` vs `let`

```js
console.log(x); // undefined (var hoisted)
console.log(y); // ReferenceError (TDZ)
var x = 1;
let y = 2;
```

### Example 2: Loop Capture

```js
var funcs1 = [];
for (var i = 0; i < 3; i++) funcs1.push(() => i);
funcs1[0](); // 3

let funcs2 = [];
for (let j = 0; j < 3; j++) funcs2.push(() => j);
funcs2[0](); // 0
```

### Example 3: Scope Chain Persistence

```js
function outer() {
  let a = 10;
  return function inner() { return a; }
}
const fn = outer();
console.log(fn()); // 10
```

---

## **11. Best Practices**

✅ Use `const` by default, `let` when reassignment is needed. Avoid `var`.
✅ Declare variables as close as possible to their usage.
✅ Avoid shadowing unless it’s intentional.
✅ Minimize closure capture to avoid unintended memory retention.
✅ Don’t use `with` or dynamic `eval` — they alter the LE unpredictably.

