
# Section 22.5 – Concurrency Control in Distributed Databases  

### 1. **Need for Concurrency Control**
In distributed databases, multiple sites process transactions at the same time. Without proper control:
- **Conflicts** can occur when two transactions update the same data at different sites.
- **Inconsistency** arises if updates aren’t properly synchronized.
- **Integrity constraints** may be violated.  

The aim is to ensure **serializability** (results equivalent to some serial execution) across all sites.

---

### 2. **Two-Phase Locking (2PL) in Distributed Context**
- Transactions request locks before accessing data.  
- Phases:
  1. **Growing Phase** – transaction acquires locks.
  2. **Shrinking Phase** – once a lock is released, no new locks can be requested.  
- Guarantees serializability.  
- **Problem**: deadlocks can occur across sites.  
- **Solution**: use global deadlock detection or prevention techniques.

---

### 3. **Distributed Deadlock Handling**
- **Wait-for Graphs**: Each site maintains local wait-for graphs, combined periodically to detect cycles.  
- **Timeouts**: Transactions waiting beyond a threshold are rolled back.  
- **Prevention**: Ordering all resources globally avoids cycles but reduces flexibility.

---

### 4. **Timestamp Ordering (TSO)**
- Each transaction is assigned a global timestamp.  
- Operations are ordered by timestamps.  
- If a transaction violates order (e.g., tries to read a value written by a later timestamp), it is rolled back.  
- Ensures serializability without locks, but **frequent rollbacks** can reduce throughput.

---

### 5. **Optimistic Concurrency Control (OCC)**
- Transactions execute freely without locks.  
- At commit time, a **validation phase** checks for conflicts.  
- If conflicts are found → transaction is rolled back.  
- Works well in distributed databases with **low conflict probability**.

---

### 6. **Commit Protocols**
To maintain consistency across sites, special commit protocols are used:
- **Two-Phase Commit (2PC)**  
  1. *Prepare Phase*: coordinator asks participants if they can commit.  
  2. *Commit Phase*: if all agree, the coordinator sends commit; else rollback.  
- **Three-Phase Commit (3PC)** adds an extra step to avoid blocking in case of coordinator failure.  

---

### 7. **Challenges in Distributed Concurrency**
- **Latency**: Communication overhead between sites.  
- **Failures**: A site crash or network partition complicates global consistency.  
- **Global Serializability**: Local schedules may be serializable, but combined they may not be globally serializable.  

---

✅ **Summary:**  
Section 22.5 focuses on how **distributed databases** handle concurrency control. It extends local techniques (like 2PL, timestamp ordering, OCC) into a distributed setting, and emphasizes the importance of commit protocols (2PC/3PC) to maintain atomicity and consistency across multiple sites.  

---

## ==**Real-world SQL + Java examples:**==


# Concurrency Control and Recovery in Oracle

## 1) Oracle’s Isolation Model (what actually happens)

**Default isolation:** `READ COMMITTED` (statement-level read consistency)
**Other modes:** `SERIALIZABLE`, `READ ONLY`

* **READ COMMITTED (default):** Every statement sees a consistent snapshot as of its start time. Readers don’t block writers, and writers don’t block readers. A second `SELECT` in the same transaction can see newer committed rows (non-repeatable reads are possible).
* **SERIALIZABLE:** Transaction-level snapshot. All statements in the transaction see a consistent snapshot as of the **first** statement. If your changes would conflict with concurrent commits, you get **ORA-08177: cannot serialize access for this transaction** (you should retry).
* **READ ONLY:** Like `SERIALIZABLE` but forbids DML.

**Set per transaction:**

```sql
-- One of:
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SET TRANSACTION READ ONLY;
```

**Key Oracle trait:** **Readers never block writers and writers never block readers** (thanks to multiversion read consistency), except when you explicitly take locks (e.g., `SELECT … FOR UPDATE`) or when two writers contend for the **same row**.

---

## 2) Multiversion Read Consistency (MVRC)

* Oracle stores before-images in **UNDO**. A query uses the **SCN** (system change number) of its start time to reconstruct a consistent snapshot from UNDO as needed.
* That’s why selects don’t block updates and vice versa.
* If your long-running query needs older data that UNDO has already purged, you’ll hit **ORA-01555: snapshot too old** → increase `UNDO_RETENTION`, size undo appropriately, or paginate.

**Flashback Query (ad-hoc time travel):**

```sql
SELECT * FROM accounts AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '5' MINUTE)
WHERE id = 1;
```

---

## 3) Locking & Deadlocks

* DML (`UPDATE/DELETE/INSERT`) takes **row-level exclusive (TX) locks** on touched rows. Reads don’t take shared locks.
* **`SELECT … FOR UPDATE`** takes an exclusive lock on selected rows, blocking other sessions’ conflicting writes/locks until commit/rollback.
* Oracle detects deadlocks automatically and aborts one participant with **ORA-00060**. Keep transactions short, lock rows in a consistent order, and index predicates to lock fewer rows.

**Locking reads:**

```sql
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;   -- blocks concurrent DML to that row
```

---

## 4) Backup & Recovery (high level)

* **Redo** → durability (replay committed changes).
* **Undo** → atomicity & read consistency (roll back uncommitted; reconstruct snapshots).
* **ARCHIVELOG** mode + **RMAN** → online backups, point-in-time recovery (PITR).
* **Flashback** features: flashback table / database / query to undo logical errors quickly without full restore.

**Typical RMAN workflow (server-side tool):**

```rman
RMAN> CONFIGURE CONTROLFILE AUTOBACKUP ON;
RMAN> BACKUP DATABASE PLUS ARCHIVELOG;
RMAN> LIST BACKUP;
-- Restore/PITR example
RMAN> SHUTDOWN IMMEDIATE;
RMAN> STARTUP MOUNT;
RMAN> RESTORE DATABASE;
RMAN> RECOVER DATABASE UNTIL TIME "TO_DATE('2025-08-21 10:05','YYYY-MM-DD HH24:MI')";
RMAN> ALTER DATABASE OPEN RESETLOGS;
```

**Flashback Table:**

```sql
FLASHBACK TABLE accounts TO TIMESTAMP (SYSTIMESTAMP - INTERVAL '10' MINUTE);
```

---

# Hands-on: Oracle SQL Examples (two sessions)

Assume table:

```sql
CREATE TABLE accounts (
  id NUMBER PRIMARY KEY,
  name VARCHAR2(50),
  balance NUMBER NOT NULL
);

INSERT INTO accounts (id, name, balance) VALUES (1,'Alice',1000);
INSERT INTO accounts (id, name, balance) VALUES (2,'Bob',1000);
COMMIT;
```

## A) Non-blocking reads with default isolation

**Session A**

```sql
-- Default: READ COMMITTED
UPDATE accounts SET balance = balance + 200 WHERE id = 1;
-- Don’t commit yet
```

**Session B**

```sql
-- This SELECT sees a snapshot from statement start.
-- If A hasn't committed, B still sees the pre-update value.
SELECT balance FROM accounts WHERE id = 1;  -- likely 1000
```

**Session A**

```sql
COMMIT;
```

**Session B (re-run)**

```sql
SELECT balance FROM accounts WHERE id = 1;  -- now 1200
```

## B) Pessimistic write with `FOR UPDATE`

**Session A**

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- locks row
-- keep the transaction open
```

**Session B**

```sql
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
-- this will BLOCK until Session A commits/rolls back
```

**Session A**

```sql
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
COMMIT;  -- Session B proceeds now and applies its +50 on the new value
```

## C) Serializable conflict

**Session A**

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT balance FROM accounts WHERE id = 2;  -- snapshot t0
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
-- hold open
```

**Session B**

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
UPDATE accounts SET balance = balance + 50 WHERE id = 2;
-- If A commits first and B’s update conflicts with A’s commit (based on B's snapshot),
-- B may get ORA-08177 and must retry.
```

## D) Deadlock demo (don’t do this in real code)

**Session A**

```sql
UPDATE accounts SET balance = balance + 10 WHERE id = 1;  -- locks row 1
```

**Session B**

```sql
UPDATE accounts SET balance = balance + 20 WHERE id = 2;  -- locks row 2
```

**Session A**

```sql
UPDATE accounts SET balance = balance + 30 WHERE id = 2;  -- waits for B
```

**Session B**

```sql
UPDATE accounts SET balance = balance + 40 WHERE id = 1;  -- cycle → ORA-00060 on one side
```

**Avoid by:** locking rows in the same order in all code paths (e.g., smaller id first).

---

# Java / Spring examples (how you actually write it)

## 1) Spring Data JPA + `@Transactional` (the usual)

```java
@Service
public class TransferService {

  @Autowired private AccountRepository repo;

  @Transactional
  public void transfer(long fromId, long toId, long amount) {
    Account from = repo.findById(fromId).orElseThrow();
    Account to   = repo.findById(toId).orElseThrow();

    if (from.getBalance() < amount) throw new IllegalStateException("Insufficient");

    from.setBalance(from.getBalance() - amount);
    to.setBalance(to.getBalance() + amount);
    // flush/commit handled automatically at method end
  }
}
```

**Notes**

* By default Spring uses the datasource’s default isolation (Oracle: READ COMMITTED).
* Add retries on transient errors (deadlock, ORA-08177).

## 2) Forcing pessimistic row locks (`SELECT … FOR UPDATE`)

```java
public interface AccountRepository extends JpaRepository<Account, Long> {

  @Lock(LockModeType.PESSIMISTIC_WRITE)
  @Query("select a from Account a where a.id = :id")
  Account lockForUpdate(@Param("id") long id);
}

@Service
public class SafeIncrementService {
  @Autowired private AccountRepository repo;

  @Transactional
  public void addBonus(long id, long inc) {
    Account a = repo.lockForUpdate(id);   // SELECT ... FOR UPDATE
    a.setBalance(a.getBalance() + inc);
  }
}
```

## 3) Overriding isolation per method

```java
@Transactional(isolation = Isolation.SERIALIZABLE)  // maps to Oracle SERIALIZABLE
public void generateMonthlyStatement(...) {
  // consistent snapshot across the whole method
}
```

## 4) Retry on serialization & deadlock

```java
public <T> T withRetry(Supplier<T> op) {
  int attempts = 0;
  while (true) {
    try {
      return op.get();
    } catch (DataAccessException e) {
      String msg = e.getMostSpecificCause().getMessage();
      // ORA-08177 (serialization) or ORA-00060 (deadlock)
      if (msg.contains("ORA-08177") || msg.contains("ORA-00060")) {
        if (++attempts <= 3) continue;  // backoff & retry
      }
      throw e;
    }
  }
}
```

---

# Practical tips (that actually save you pain)

* Keep transactions **short**; avoid user interaction inside them.
* For “read-modify-write” on a single row, use **pessimistic lock** (`FOR UPDATE`) if you must serialize increments.
* For reporting/exports requiring a stable view, use **`@Transactional(isolation = SERIALIZABLE)`** or **`READ ONLY`** transactions.
* Size **UNDO** and set **`UNDO_RETENTION`** to avoid “snapshot too old” for long queries.
* Use **Flashback** for fast logical recovery; use **RMAN** + **ARCHIVELOG** for robust disaster recovery.
* Always add **retry** logic for **ORA-08177** and **ORA-00060** in service-level code.


