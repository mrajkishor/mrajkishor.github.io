## **JavaScript coding challenges** 

---

# 1) Two Sum (indices)

**Idea:** One pass hash map. **Time:** O(n), **Space:** O(n)

```js
function twoSum(nums, target) {
  const seen = new Map();
  for (let i = 0; i < nums.length; i++) {
    const j = seen.get(target - nums[i]);
    if (j !== undefined) return [j, i];
    seen.set(nums[i], i);
  }
  return [];
}
```

---

# 2) Longest Substring Without Repeating

**Idea:** Sliding window with last-seen index. **Time:** O(n)

```js
function lengthOfLongestSubstring(s) {
  const idx = new Map();
  let best = 0, start = 0;
  for (let i = 0; i < s.length; i++) {
    if (idx.has(s[i]) && idx.get(s[i]) >= start) start = idx.get(s[i]) + 1;
    idx.set(s[i], i);
    best = Math.max(best, i - start + 1);
  }
  return best;
}
```

---

# 3) Group Anagrams

**Idea:** Sort each word’s letters as a key. **Time:** O(n k log k)

```js
function groupAnagrams(strs) {
  const groups = new Map();
  for (const w of strs) {
    const key = w.split('').sort().join('');
    (groups.get(key) ?? groups.set(key, []).get(key)).push(w);
  }
  return [...groups.values()];
}
```

---

# 4) Kth Largest (Quickselect)

**Idea:** Partition in average O(n).

```js
function kthLargest(nums, k) {
  k = nums.length - k;
  let l = 0, r = nums.length - 1;
  const swap = (i,j)=>([nums[i],nums[j]]=[nums[j],nums[i]]);
  while (l <= r) {
    let p = l, pivot = nums[r];
    for (let i = l; i < r; i++) if (nums[i] <= pivot) swap(i, p++);
    swap(p, r);
    if (p === k) return nums[p];
    if (p < k) l = p + 1; else r = p - 1;
  }
}
```

---

# 5) Valid Parentheses

**Idea:** Stack. **Time:** O(n)

```js
function isValid(s) {
  const map = {')':'(',']':'[','}':'{'}, st=[];
  for (const ch of s) {
    if (map[ch]) { if (st.pop() !== map[ch]) return false; }
    else st.push(ch);
  }
  return st.length === 0;
}
```

---

# 6) Deep Clone (handles Map/Set/Date/RegExp + circular)

**Idea:** DFS with WeakMap for cycle detection.

```js
function deepClone(value, seen = new WeakMap()) {
  if (value === null || typeof value !== 'object') return value;
  if (seen.has(value)) return seen.get(value);

  if (value instanceof Date) return new Date(value);
  if (value instanceof RegExp) return new RegExp(value.source, value.flags);
  if (value instanceof Map) {
    const m = new Map(); seen.set(value, m);
    for (const [k,v] of value) m.set(deepClone(k, seen), deepClone(v, seen));
    return m;
  }
  if (value instanceof Set) {
    const s = new Set(); seen.set(value, s);
    for (const v of value) s.add(deepClone(v, seen));
    return s;
  }
  const out = Array.isArray(value) ? [] : Object.create(Object.getPrototypeOf(value));
  seen.set(value, out);
  for (const k of Reflect.ownKeys(value)) out[k] = deepClone(value[k], seen);
  return out;
}
```

---

# 7) LRU Cache

**Idea:** Hash map + doubly linked list. **Time:** O(1) ops.

```js
class LRUCache {
  constructor(capacity){ this.cap=capacity; this.map=new Map(); this.h={}; this.t={}; this.h.n=this.t; this.t.p=this.h; }
  _add(node){ node.n=this.h.n; node.p=this.h; this.h.n.p=node; this.h.n=node; }
  _remove(node){ node.p.n=node.n; node.n.p=node.p; }
  get(key){
    const node=this.map.get(key); if(!node) return -1;
    this._remove(node); this._add(node); return node.val;
  }
  set(key,value){
    if(this.map.has(key)){ const node=this.map.get(key); node.val=value; this._remove(node); this._add(node); return; }
    const node={key,val:value}; this.map.set(key,node); this._add(node);
    if(this.map.size>this.cap){ const lru=this.t.p; this._remove(lru); this.map.delete(lru.key); }
  }
}
```

---

# 8) Event Emitter

**Idea:** Map of event → Set of listeners.

```js
class Emitter {
  constructor(){ this.evt = new Map(); }
  on(name, fn){ (this.evt.get(name) ?? this.evt.set(name,new Set()).get(name)).add(fn); return () => this.off(name, fn); }
  off(name, fn){ this.evt.get(name)?.delete(fn); }
  once(name, fn){ const off = this.on(name, (...a)=>{ off(); fn(...a); }); }
  emit(name, ...args){ for (const fn of this.evt.get(name) ?? []) fn(...args); }
}
```

---

# 9) Debounce & Throttle (interview favorites)

```js
function debounce(fn, wait){
  let t; return function(...args){
    clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), wait);
  };
}

function throttle(fn, wait){
  let last = 0, timer = null, saved;
  return function(...args){
    const now = Date.now(); saved = {ctx:this, args};
    if (now - last >= wait) { last = now; fn.apply(this,args); }
    else if (!timer){
      const remaining = wait - (now - last);
      timer = setTimeout(()=>{ last = Date.now(); timer=null; fn.apply(saved.ctx, saved.args); }, remaining);
    }
  };
}
```

---

# 10) Curry & Compose/Pipe

```js
const curry = (fn, arity = fn.length) => function curried(...args){
  return args.length >= arity ? fn.apply(this,args) : (...rest) => curried(...args,...rest);
};

const compose = (...fns) => (x) => fns.reduceRight((v,f)=>f(v), x);
const pipe    = (...fns) => (x) => fns.reduce((v,f)=>f(v), x);
```

---

# 11) `Promise.allSettled` Polyfill

```js
if (!Promise.allSettled) {
  Promise.allSettled = function(promises){
    return Promise.all(promises.map(p => Promise.resolve(p)
      .then(value => ({ status:'fulfilled', value }),
            reason => ({ status:'rejected', reason }))));
  };
}
```

---

# 12) Concurrency Limiter (p-limit style)

**Idea:** Queue tasks; run at most `n` at once.

```js
function pLimit(n){
  const queue = [];
  let active = 0;

  const next = () => {
    if (active >= n || queue.length === 0) return;
    active++;
    const {fn, resolve, reject} = queue.shift();
    Promise.resolve().then(fn).then(
      v => { active--; resolve(v); next(); },
      e => { active--; reject(e); next(); }
    );
  };

  return (fn) => new Promise((resolve,reject) => { queue.push({fn,resolve,reject}); next(); });
}

// Usage:
const limit = pLimit(3);
const tasks = [...Array(10)].map((_,i)=>limit(()=>new Promise(r=>setTimeout(()=>r(i),100))));
Promise.all(tasks).then(console.log);
```

---

# 13) Retry with Exponential Backoff (for `fetch`)

```js
async function retry(fn, {retries=3, base=200}={}){
  let attempt = 0, err;
  while (attempt <= retries) {
    try { return await fn(); }
    catch (e) { err = e; if (attempt === retries) break;
      await new Promise(r => setTimeout(r, base * 2**attempt)); attempt++;
    }
  }
  throw err;
}

// Example:
const getJSON = (url) => retry(()=>fetch(url).then(r=> {
  if (!r.ok) throw new Error(r.statusText); return r.json();
}));
```

---

# 14) Flatten Deeply Nested Arrays (any depth)

```js
function flatten(arr) {
  const out = [];
  (function dfs(a){
    for (const x of a) Array.isArray(x) ? dfs(x) : out.push(x);
  })(arr);
  return out;
}
// Or: arr.flat(Infinity)
```

---

# 15) Top-K Frequent Elements (Bucket Sort)

**Idea:** Count, then buckets by frequency. **Time:** O(n)

```js
function topKFrequent(nums, k){
  const freq = new Map();
  for (const n of nums) freq.set(n, (freq.get(n)||0)+1);
  const buckets = Array(nums.length+1).fill(0).map(()=>[]);
  for (const [n,c] of freq) buckets[c].push(n);
  const res = [];
  for (let i=buckets.length-1; i>=0 && res.length<k; i--) res.push(...buckets[i]);
  return res.slice(0,k);
}
```

