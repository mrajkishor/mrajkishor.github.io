

# üî∑ Transactions with `@Transactional` and Propagation Strategies

## 1. Concept of Transactions

A **transaction** in database systems is a **logical unit of work** that must be executed **completely or not at all**.
It follows the **ACID properties**:

* **Atomicity** ‚Äì All operations succeed, or none do.
* **Consistency** ‚Äì Transaction leaves DB in a valid state.
* **Isolation** ‚Äì Transactions don‚Äôt interfere with each other.
* **Durability** ‚Äì Once committed, data persists even after failures.

In **Spring Data JPA**, transaction management is simplified via the `@Transactional` annotation, which integrates seamlessly with Hibernate and underlying databases.

---

## 2. `@Transactional` in Spring

`@Transactional` is used at the **method** or **class** level to define transactional boundaries.

### Example

```java
@Service
public class OrderService {

    @Autowired
    private OrderRepository orderRepo;

    @Transactional
    public void placeOrder(Order order) {
        orderRepo.save(order);
        // if an exception occurs, transaction rolls back automatically
    }
}
```

### Key Attributes of `@Transactional`

1. **propagation** ‚Üí Defines how transaction boundaries interact across methods.
2. **isolation** ‚Üí Defines isolation level (e.g., READ\_COMMITTED, SERIALIZABLE).
3. **timeout** ‚Üí Max execution time before rollback.
4. **readOnly** ‚Üí Optimization for read-only operations.
5. **rollbackFor / noRollbackFor** ‚Üí Explicitly control rollback on exceptions.

---

## 3. Transaction Propagation Strategies

Propagation defines **what happens when a method with `@Transactional` is called inside another transactional method**.

### üîπ 1. `REQUIRED` (default)

* Join the existing transaction if one exists; otherwise, create a new one.

```java
@Transactional(propagation = Propagation.REQUIRED)
```

‚úÖ Common for most service methods.
‚ö†Ô∏è If outer transaction rolls back, inner also rolls back.

---

### üîπ 2. `REQUIRES_NEW`

* Always create a **new independent transaction**, suspending the existing one.

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
```

‚úÖ Useful for audit logging (should commit even if main transaction fails).
‚ö†Ô∏è Extra overhead: suspends and resumes transactions.

---

### üîπ 3. `SUPPORTS`

* If a transaction exists, join it; otherwise, run non-transactionally.

```java
@Transactional(propagation = Propagation.SUPPORTS)
```

‚úÖ Read-only queries where transactional context is optional.

---

### üîπ 4. `MANDATORY`

* Must run inside an existing transaction; otherwise, throws `TransactionRequiredException`.

```java
@Transactional(propagation = Propagation.MANDATORY)
```

‚úÖ Ensures method is always invoked within a transaction.

---

### üîπ 5. `NOT_SUPPORTED`

* Suspends any existing transaction, runs **non-transactionally**.

```java
@Transactional(propagation = Propagation.NOT_SUPPORTED)
```

‚úÖ For batch reports or long-running queries that should not block transactions.

---

### üîπ 6. `NEVER`

* Must run outside of a transaction; throws exception if one exists.

```java
@Transactional(propagation = Propagation.NEVER)
```

‚úÖ Useful for system health checks.

---

### üîπ 7. `NESTED`

* Runs in a **nested transaction** (savepoint within main transaction).
* Rollback in nested transaction does not rollback outer transaction.

```java
@Transactional(propagation = Propagation.NESTED)
```

‚úÖ Useful when part of a larger transaction may fail but should not affect the whole.
‚ö†Ô∏è Requires DB support (e.g., savepoints in PostgreSQL, Oracle, not all DBs).

---

## 4. Isolation Levels (ACID ‚Üí I in depth)

Defines how concurrent transactions affect each other.

* **READ\_UNCOMMITTED** ‚Üí Dirty reads allowed (rarely used).
* **READ\_COMMITTED** (default in most DBs) ‚Üí Prevents dirty reads.
* **REPEATABLE\_READ** ‚Üí Prevents non-repeatable reads.
* **SERIALIZABLE** ‚Üí Strongest, full isolation (lowest concurrency).

Example:

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
```

---

## 5. Rollback Rules

By default, **Spring rolls back on `RuntimeException` and `Error`** but not on checked exceptions.

Customize behavior:

```java
@Transactional(rollbackFor = Exception.class)
```

---

## 6. Real-World Use Cases

* **E-Commerce Order Processing**

  * `OrderService.placeOrder()` ‚Üí REQUIRED (atomic operation).
  * `PaymentService.chargeCard()` ‚Üí REQUIRED (rollback if payment fails).
  * `AuditLogService.logTransaction()` ‚Üí REQUIRES\_NEW (always commit logs).

* **Banking**

  * Money transfer: debit + credit must happen atomically ‚Üí REQUIRED.
  * Fraud detection alerts must persist regardless ‚Üí REQUIRES\_NEW.

* **Analytics**

  * Report generation ‚Üí NOT\_SUPPORTED (avoid blocking transactional resources).

---

## 7. Best Practices (Enterprise-Level)

1. **Keep transactions short** ‚Äì Long transactions lock resources, degrade performance.
2. **Use REQUIRES\_NEW sparingly** ‚Äì Can cause overhead with suspended transactions.
3. **Never open transactions in controllers** ‚Äì Keep them at **service layer**.
4. **Always declare rollbackFor explicitly** for checked exceptions.
5. **Use readOnly = true** for queries ‚Üí Hibernate optimizes for read operations.
6. **Monitor transaction logs** in production (deadlocks, rollbacks).
7. **Design idempotent operations** ‚Üí Retry-friendly in distributed systems.

---

## 8. Enterprise-Level Interview Questions

1. What happens when a `REQUIRES_NEW` transaction is called inside a `REQUIRED` one?
2. Difference between `REQUIRED` and `NESTED`? Which is supported in your DB?
3. Why is `readOnly = true` important in Spring JPA?
4. How do you ensure audit logs persist even when main transaction rolls back?
5. Can you explain an example where `MANDATORY` makes sense?
6. What is the difference between database transactions and distributed transactions (XA, Saga)?
7. Why doesn‚Äôt Spring roll back for checked exceptions by default?
8. How would you handle deadlocks in transaction-heavy systems?
9. If you had billions of concurrent financial transactions, which isolation level would you choose and why?
10. What‚Äôs the trade-off between SERIALIZABLE and READ\_COMMITTED isolation levels?

---

# **Code example** for

**Spring Transactions with `@Transactional` and Propagation Strategies**

We‚Äôll model a **Banking/E-Commerce-like scenario**:

* **OrderService** ‚Üí Main business flow (`REQUIRED`)
* **PaymentService** ‚Üí Debit/credit operations (`REQUIRED`)
* **AuditLogService** ‚Üí Always commits logs (`REQUIRES_NEW`)
* **CouponService** ‚Üí Uses `NESTED` so rollback affects only coupon but not the main order

---

# üõ† Code Example ‚Äî Transaction Propagation Strategies

## 1. Entities

### `Order`

```java
@Entity
@Table(name = "orders")
public class Order {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String status; // PLACED, FAILED
    private double amount;
}
```

### `Payment`

```java
@Entity
@Table(name = "payments")
public class Payment {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private double amount;
    private String method; // CARD, UPI, WALLET
    private String status; // SUCCESS, FAILED
}
```

### `AuditLog`

```java
@Entity
@Table(name = "audit_logs")
public class AuditLog {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String action;
    private LocalDateTime timestamp;
}
```

---

## 2. Repositories

```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {}

@Repository
public interface PaymentRepository extends JpaRepository<Payment, Long> {}

@Repository
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {}
```

---

## 3. Services with Propagation Strategies

### üîπ `PaymentService` ‚Üí REQUIRED

```java
@Service
@RequiredArgsConstructor
public class PaymentService {
    private final PaymentRepository paymentRepo;

    @Transactional(propagation = Propagation.REQUIRED)
    public void processPayment(double amount, String method, boolean fail) {
        Payment payment = new Payment();
        payment.setAmount(amount);
        payment.setMethod(method);

        if (fail) {
            payment.setStatus("FAILED");
            paymentRepo.save(payment);
            throw new RuntimeException("Payment failed");
        } else {
            payment.setStatus("SUCCESS");
            paymentRepo.save(payment);
        }
    }
}
```

---

### üîπ `AuditLogService` ‚Üí REQUIRES\_NEW

```java
@Service
@RequiredArgsConstructor
public class AuditLogService {
    private final AuditLogRepository auditRepo;

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void log(String action) {
        AuditLog log = new AuditLog();
        log.setAction(action);
        log.setTimestamp(LocalDateTime.now());
        auditRepo.save(log);
    }
}
```

---

### üîπ `CouponService` ‚Üí NESTED

```java
@Service
@RequiredArgsConstructor
public class CouponService {
    private final OrderRepository orderRepo;

    @Transactional(propagation = Propagation.NESTED)
    public void applyCoupon(Order order, boolean invalid) {
        if (invalid) {
            throw new RuntimeException("Invalid coupon");
        }
        order.setStatus("COUPON_APPLIED");
        orderRepo.save(order);
    }
}
```

---

### üîπ `OrderService` ‚Üí Orchestrates everything

```java
@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepo;
    private final PaymentService paymentService;
    private final AuditLogService auditLogService;
    private final CouponService couponService;

    @Transactional(propagation = Propagation.REQUIRED)
    public void placeOrder(double amount, String method, boolean paymentFail, boolean invalidCoupon) {
        Order order = new Order();
        order.setAmount(amount);
        order.setStatus("PLACED");
        orderRepo.save(order);

        try {
            // 1. Payment must succeed else rollback entire transaction
            paymentService.processPayment(amount, method, paymentFail);

            // 2. Apply coupon (if invalid, rollback only coupon via NESTED)
            try {
                couponService.applyCoupon(order, invalidCoupon);
            } catch (Exception e) {
                // coupon rolled back but order still goes through
                auditLogService.log("Coupon failed: " + e.getMessage());
            }

            // 3. Log audit ‚Üí Always commit even if order fails
            auditLogService.log("Order placed successfully: " + order.getId());

        } catch (Exception ex) {
            // rollback order + payment
            auditLogService.log("Order failed: " + ex.getMessage());
            throw ex; // rethrow to rollback
        }
    }
}
```

---

## 4. Controller for Testing

```java
@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final OrderService orderService;

    // Example: /api/orders/place?amount=500&method=CARD&paymentFail=false&invalidCoupon=true
    @PostMapping("/place")
    public ResponseEntity<String> placeOrder(
            @RequestParam double amount,
            @RequestParam String method,
            @RequestParam boolean paymentFail,
            @RequestParam boolean invalidCoupon) {
        try {
            orderService.placeOrder(amount, method, paymentFail, invalidCoupon);
            return ResponseEntity.ok("Order processed successfully");
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Order failed: " + e.getMessage());
        }
    }
}
```

---

# üîë Transaction Behavior in This Example

### ‚úÖ Case 1: Payment succeeds, coupon valid

* Order committed
* Payment committed
* Coupon applied
* Audit log committed

### ‚úÖ Case 2: Payment fails

* Order rolled back
* Payment rolled back
* Audit log (REQUIRES\_NEW) still committed

### ‚úÖ Case 3: Coupon invalid

* Coupon rolled back (NESTED)
* Order + Payment committed
* Audit log records coupon failure

---

# üöÄ Enterprise-Level Insights

1. **REQUIRED (default)**

   * Use for atomic service methods (e.g., order + payment).

2. **REQUIRES\_NEW**

   * Good for **logging, notifications, audit** ‚Üí always commit.

3. **NESTED**

   * Allows partial rollback with **savepoints**.
   * Not supported by all DBs (works with PostgreSQL, Oracle).

4. **Error Handling**

   * Always **rethrow exceptions** you want to trigger rollback.
   * Use `rollbackFor = Exception.class` if you need rollback on checked exceptions.

5. **Performance**

   * Keep transactions **short-lived** (no long API calls inside).
   * Minimize nested/parallel transactions to avoid DB locks.

---

This example shows **transaction orchestration across multiple services** with different **propagation strategies**.

---


Now let‚Äôs **visualize the transaction flow** for our example with

üëâ `OrderService (REQUIRED)`
üëâ `PaymentService (REQUIRED)`
üëâ `CouponService (NESTED)`
üëâ `AuditLogService (REQUIRES_NEW)`

---

# üî∑ Transaction Flow Diagram (Commit & Rollback)

---

## üü¢ Case 1: All Success (Payment + Coupon succeed)

```
[Main Transaction T1: REQUIRED]
   ‚îú‚îÄ‚îÄ OrderService.placeOrder()  ‚Üí begin T1
   ‚îÇ
   ‚îú‚îÄ‚îÄ PaymentService.processPayment() ‚Üí joins T1
   ‚îÇ      ‚úî Payment committed with T1
   ‚îÇ
   ‚îú‚îÄ‚îÄ CouponService.applyCoupon() ‚Üí NESTED (savepoint inside T1)
   ‚îÇ      ‚úî Coupon committed with T1
   ‚îÇ
   ‚îú‚îÄ‚îÄ AuditLogService.log() ‚Üí REQUIRES_NEW (T2)
   ‚îÇ      ‚úî Log committed independently
   ‚îÇ
   ‚îî‚îÄ‚îÄ T1 commit ‚Üí Order + Payment + Coupon saved
```

‚úÖ Everything committed.

---

## üî¥ Case 2: Payment Fails

```
[Main Transaction T1: REQUIRED]
   ‚îú‚îÄ‚îÄ OrderService.placeOrder()  ‚Üí begin T1
   ‚îÇ
   ‚îú‚îÄ‚îÄ PaymentService.processPayment() ‚Üí joins T1
   ‚îÇ      ‚ùå Payment fails ‚Üí Exception ‚Üí T1 marked for rollback
   ‚îÇ
   ‚îú‚îÄ‚îÄ AuditLogService.log("Order failed") ‚Üí REQUIRES_NEW (T2)
   ‚îÇ      ‚úî Log committed independently
   ‚îÇ
   ‚îî‚îÄ‚îÄ T1 rollback ‚Üí Order + Payment discarded
```

‚úÖ Logs still committed (`REQUIRES_NEW`), but main order/payment rolled back.

---

## üü° Case 3: Coupon Fails

```
[Main Transaction T1: REQUIRED]
   ‚îú‚îÄ‚îÄ OrderService.placeOrder() ‚Üí begin T1
   ‚îÇ
   ‚îú‚îÄ‚îÄ PaymentService.processPayment() ‚Üí joins T1
   ‚îÇ      ‚úî Payment committed with T1
   ‚îÇ
   ‚îú‚îÄ‚îÄ CouponService.applyCoupon() ‚Üí NESTED
   ‚îÇ      ‚ùå Coupon fails ‚Üí rollback to savepoint
   ‚îÇ      (Order + Payment unaffected)
   ‚îÇ
   ‚îú‚îÄ‚îÄ AuditLogService.log("Coupon failed") ‚Üí REQUIRES_NEW (T2)
   ‚îÇ      ‚úî Log committed independently
   ‚îÇ
   ‚îî‚îÄ‚îÄ T1 commit ‚Üí Order + Payment saved, Coupon skipped
```

‚úÖ Only coupon rolled back. Order + Payment safe. Audit log records coupon failure.

---

# üîë Key Takeaways from Diagram

1. **REQUIRED** ‚Üí Shares parent transaction ‚Üí rollback cascades to all.
2. **REQUIRES\_NEW** ‚Üí Always starts independent transaction ‚Üí commits even if parent rolls back.
3. **NESTED** ‚Üí Creates savepoint inside parent ‚Üí partial rollback possible.
4. **Audit Logs & Notifications** ‚Üí Always use `REQUIRES_NEW`.
5. **Coupon/Optional Features** ‚Üí Best candidate for `NESTED`.
6. **Mission-Critical Core Flow** ‚Üí Use `REQUIRED` to keep order + payment atomic.

---

This diagram gives you a **timeline view** of commit/rollback behavior across services.


---

Now let‚Äôs build a **Sequence Diagram (ASCII UML style)** that shows how
`OrderService ‚Üí PaymentService ‚Üí CouponService ‚Üí AuditLogService` interact with different transaction propagations.

---

# üî∑ Transaction Sequence Diagram (ASCII UML)

---

## üü¢ Case 1: All Success

```
OrderController         OrderService (T1: REQUIRED)       PaymentService (joins T1)      CouponService (NESTED)        AuditLogService (T2: REQUIRES_NEW)
      |                          |                                 |                              |                                  |
      | ---- placeOrder() ------>|                                 |                              |                                  |
      |                          |---- begin T1 ------------------>|                              |                                  |
      |                          |---- save(Order) ---------------|                              |                                  |
      |                          |---- processPayment() ---------->| save(Payment SUCCESS)        |                                  |
      |                          |                                 |---- join T1 ----------------|                                  |
      |                          |---- applyCoupon() -------------------------------------------------> save(Coupon Applied) --------|
      |                          |---- log("Order placed") -------------------------------------------------------------> begin T2 --> save(Log) --> commit T2
      |                          |                                                                                                           |
      |                          |---- commit T1 (Order+Payment+Coupon) -------------------------------------------------------------------------------------|
      |<-------------------------|                                                                                                           |
```

‚úÖ **Everything committed**: Order, Payment, Coupon, Log.

---

## üî¥ Case 2: Payment Fails

```
OrderController         OrderService (T1: REQUIRED)       PaymentService (joins T1)             AuditLogService (T2: REQUIRES_NEW)
      |                          |                                 |                                         |
      | ---- placeOrder() ------>|                                 |                                         |
      |                          |---- begin T1 ------------------>|                                         |
      |                          |---- save(Order) ---------------|                                         |
      |                          |---- processPayment() ---------->| FAIL ‚Üí throw Exception                  |
      |                          |                                 |---- T1 marked for rollback              |
      |                          |---- log("Order failed") -------------------------------------------------------------> begin T2 --> save(Log) --> commit T2
      |                          |                                                                                     |
      |                          |---- rollback T1 (Order+Payment rolled back) ----------------------------------------|
      |<-------------------------|                                                                                     |
```

‚úÖ **Order + Payment rolled back**, but **Audit log persisted** via REQUIRES\_NEW.

---

## üü° Case 3: Coupon Fails

```
OrderController         OrderService (T1: REQUIRED)       PaymentService (joins T1)      CouponService (NESTED)         AuditLogService (T2: REQUIRES_NEW)
      |                          |                                 |                              |                                   |
      | ---- placeOrder() ------>|                                 |                              |                                   |
      |                          |---- begin T1 ------------------>|                              |                                   |
      |                          |---- save(Order) ---------------|                              |                                   |
      |                          |---- processPayment() ---------->| save(Payment SUCCESS)        |                                   |
      |                          |                                 |---- join T1 ----------------|                                   |
      |                          |---- applyCoupon() -------------------------------------------------> FAIL ‚Üí rollback to SAVEPOINT   |
      |                          |---- log("Coupon failed") --------------------------------------------------------------------------> begin T2 --> save(Log) --> commit T2
      |                          |---- commit T1 (Order+Payment OK, Coupon skipped) ----------------------------------------------------------------------------------------|
      |<-------------------------|                                                                                                    |
```

‚úÖ **Coupon rolled back to savepoint**, Order + Payment still committed, Log saved independently.

---

# üîë Enterprise-Level Observations

* **Nested Transactions** ‚Üí Show *partial rollback capability* (savepoints).
* **Requires\_New** ‚Üí *Independence* of logs/notifications (critical for auditing).
* **Required** ‚Üí *Atomicity* of core workflow (Order + Payment succeed/fail together).
* **Sequence Diagram** helps interviewers see you understand **call hierarchy + transactional context**.

---

This sequence diagram makes it **clear how propagation strategies behave step-by-step** across services.

---

Now let‚Äôs **extend our transactional flow into a distributed system version** where services are independent microservices.

In **Enterprise interviews**, after talking about Spring‚Äôs `@Transactional` and propagation strategies, they often push you towards **distributed transactions** ‚Äî since in real-world systems you don‚Äôt always have a single DB and ACID transactions don‚Äôt scale across microservices.

---

# üî∑ Distributed Transactions ‚Äî Saga & 2PC Perspective

---

## 1. Why Local `@Transactional` Doesn‚Äôt Work in Microservices

* In **monoliths**, `@Transactional` ensures ACID within one database.
* In **microservices**, each service has its **own DB** (for autonomy, scaling).
* Example:

  * `OrderService` DB
  * `PaymentService` DB
  * `CouponService` DB
  * `AuditService` DB

üëâ A **single transaction** across them is not possible with plain Spring JPA.
Instead, we use **Distributed Transaction Patterns**:

1. **Two-Phase Commit (2PC)** ‚Äî ACID across DBs (heavy, less used).
2. **Saga Pattern (Choreography / Orchestration)** ‚Äî BASE (eventual consistency).

---

## 2. Two-Phase Commit (2PC)

* A **transaction coordinator** prepares all participants ‚Üí then commits or rolls back all.
* Ensures **strict ACID**, but:

  * High latency
  * Blocking (participants hold locks)
  * Doesn‚Äôt scale well for Enterprise-level systems

üëâ Rare in microservices, but used in **banking / financial core systems**.

---

## 3. Saga Pattern (Preferred in Enterprise)

### üîπ Orchestration Saga (Centralized Coordinator)

* `OrderService` calls a **Saga Orchestrator**.
* Orchestrator triggers steps: Order ‚Üí Payment ‚Üí Coupon ‚Üí Audit.
* If any step fails ‚Üí Orchestrator triggers **compensating actions**.

### üîπ Choreography Saga (Decentralized, Event-Driven)

* Each service publishes an **event** and listens for the next step.
* Example:

  * `OrderService` ‚Üí publish `OrderPlaced`
  * `PaymentService` ‚Üí consume `OrderPlaced`, process, then publish `PaymentCompleted`
  * `CouponService` ‚Üí consume `PaymentCompleted`, apply coupon, publish `CouponApplied`
  * If failure ‚Üí publish `PaymentFailed` ‚Üí `OrderService` cancels order.

---

## 4. Sequence Diagram ‚Äî Distributed Saga (Orchestration)

```
Client         Orchestrator         OrderService(DB1)        PaymentService(DB2)        CouponService(DB3)        AuditService(DB4)
  |                 |                       |                       |                          |                          |
  |--- placeOrder-->|                       |                       |                          |                          |
  |                 |--- createOrder ------>| save Order (PLACED)   |                          |                          |
  |                 |                       |--- OK ----------------|                          |                          |
  |                 |--- processPayment --------------------------->| save Payment SUCCESS     |                          |
  |                 |                       |                       |--- OK ------------------|                          |
  |                 |--- applyCoupon -------------------------------------------------------->| save Coupon              |
  |                 |                                                                          |--- OK ------------------|
  |                 |--- logAudit -------------------------------------------------------------------------------------->| save Log
  |                 |                                                                                                   |--- OK ---|
  |<----------------|                                                                                                   |
```

‚úÖ Orchestrator manages success flow.

---

## 5. Failure Flow Example (Payment Fails)

```
Client         Orchestrator         OrderService(DB1)        PaymentService(DB2)        AuditService(DB4)
  |                 |                       |                       |                          |
  |--- placeOrder-->|                       |                       |                          |
  |                 |--- createOrder ------>| save Order (PLACED)   |                          |
  |                 |                       |--- OK ----------------|                          |
  |                 |--- processPayment --------------------------->| save Payment FAILED      |
  |                 |                       |                       |--- FAIL -----------------|
  |                 |--- compensate -------->| cancel Order (CANCELLED)                        |
  |                 |--- logAudit -------------------------------------------------------------------------------------->| save Log
  |<----------------|                                                                                                   |
```

‚úÖ Compensation instead of rollback.

---

## 6. Key Enterprise-Level Insights

* **Local Transactions** (`@Transactional`) ‚Üí Work inside one DB only.
* **Distributed Transactions** ‚Üí Require Saga/2PC.
* **Saga Advantages**:

  * Non-blocking
  * Event-driven, scalable
  * Compensating transactions instead of rollback
* **Saga Challenges**:

  * Complex error handling
  * Requires idempotency (retry safe)
  * Event ordering consistency

---

## 7. Best Practices

1. Use **`@Transactional`** only inside a microservice boundary.
2. Use **Saga Pattern** for cross-service transactions (event-driven).
3. Ensure **compensation logic** exists for every step (e.g., cancel order if payment fails).
4. Use **message brokers** (Kafka, RabbitMQ) for saga events.
5. Keep **audit logging** as an independent service (`REQUIRES_NEW` style in distributed world).
6. Design **idempotent APIs** ‚Üí repeated events should not corrupt data.

---

## 8. Enterprise-Level Interview Questions

1. Why can‚Äôt you use `@Transactional` across multiple microservices?
2. What‚Äôs the difference between **2PC** and **Saga**? Why is Saga more common?
3. How do you design compensation for `Order ‚Üí Payment ‚Üí Coupon` flow?
4. How would you make Saga idempotent in event-driven systems?
5. What happens if the Saga orchestrator crashes mid-way?
6. How would you handle ordering in event-based Saga (Kafka out-of-order messages)?
7. Which isolation level would you choose in **distributed transactions**?
8. How do you guarantee **audit logs** are always persisted in a Saga workflow?

---

‚úÖ Now you have **end-to-end mastery**:

* Local transactions (`@Transactional`, propagation strategies).
* Distributed transactions (2PC vs Saga).
* Flow diagrams for both success & failure cases.
* Enterprise interview insights + trade-offs.

---

Now let‚Äôs build a **code skeleton for Saga Orchestration** in a **Spring Boot + Kafka** setup.

We‚Äôll implement a simplified **Order ‚Üí Payment ‚Üí Coupon ‚Üí Audit** Saga flow.

---

# üî∑ Saga Orchestration ‚Äî Spring Boot + Kafka Skeleton

---

## 1. Common Saga Events

```java
// Base Event
public interface SagaEvent {
    String getOrderId();
}

// Order Events
public record OrderCreatedEvent(String orderId, double amount) implements SagaEvent {}
public record OrderCancelledEvent(String orderId, String reason) implements SagaEvent {}

// Payment Events
public record PaymentCompletedEvent(String orderId) implements SagaEvent {}
public record PaymentFailedEvent(String orderId, String reason) implements SagaEvent {}

// Coupon Events
public record CouponAppliedEvent(String orderId) implements SagaEvent {}
public record CouponFailedEvent(String orderId, String reason) implements SagaEvent {}

// Audit Events
public record AuditLogEvent(String orderId, String action) implements SagaEvent {}
```

---

## 2. Kafka Configuration

```java
@Configuration
@EnableKafka
public class KafkaConfig {

    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        return new DefaultKafkaProducerFactory<>(Map.of(
            ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092",
            ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class,
            ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class
        ));
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }

    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        return new DefaultKafkaConsumerFactory<>(Map.of(
            ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092",
            ConsumerConfig.GROUP_ID_CONFIG, "saga-group",
            ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class,
            ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class
        ), new StringDeserializer(), new JsonDeserializer<>(Object.class, false));
    }
}
```

---

## 3. Orchestrator (Central Coordinator)

```java
@Service
@RequiredArgsConstructor
public class OrderSagaOrchestrator {

    private final KafkaTemplate<String, Object> kafkaTemplate;

    public void startSaga(String orderId, double amount) {
        kafkaTemplate.send("order-events", new OrderCreatedEvent(orderId, amount));
    }

    @KafkaListener(topics = "payment-events", groupId = "saga-group")
    public void handlePayment(Object event) {
        if (event instanceof PaymentCompletedEvent e) {
            kafkaTemplate.send("coupon-events", new CouponAppliedEvent(e.orderId()));
        } else if (event instanceof PaymentFailedEvent e) {
            kafkaTemplate.send("order-events", new OrderCancelledEvent(e.orderId(), "Payment failed"));
        }
    }

    @KafkaListener(topics = "coupon-events", groupId = "saga-group")
    public void handleCoupon(Object event) {
        if (event instanceof CouponAppliedEvent e) {
            kafkaTemplate.send("audit-events", new AuditLogEvent(e.orderId(), "Order completed with coupon"));
        } else if (event instanceof CouponFailedEvent e) {
            kafkaTemplate.send("audit-events", new AuditLogEvent(e.orderId(), "Coupon failed: " + e.reason()));
        }
    }
}
```

---

## 4. Order Service (Local Transaction + Event Publish)

```java
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepo;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @Transactional
    public void createOrder(String orderId, double amount) {
        Order order = new Order(orderId, "PLACED", amount);
        orderRepo.save(order);

        kafkaTemplate.send("payment-events", new PaymentCompletedEvent(orderId));
    }

    @KafkaListener(topics = "order-events", groupId = "saga-group")
    public void handleOrderEvents(Object event) {
        if (event instanceof OrderCancelledEvent e) {
            Order order = orderRepo.findById(e.orderId()).orElseThrow();
            order.setStatus("CANCELLED");
            orderRepo.save(order);
        }
    }
}
```

---

## 5. Payment Service

```java
@Service
@RequiredArgsConstructor
public class PaymentService {
    private final PaymentRepository paymentRepo;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @KafkaListener(topics = "order-events", groupId = "saga-group")
    @Transactional
    public void handleOrderCreated(OrderCreatedEvent event) {
        try {
            Payment payment = new Payment(event.orderId(), event.amount(), "SUCCESS");
            paymentRepo.save(payment);

            kafkaTemplate.send("payment-events", new PaymentCompletedEvent(event.orderId()));
        } catch (Exception ex) {
            kafkaTemplate.send("payment-events", new PaymentFailedEvent(event.orderId(), "Insufficient funds"));
        }
    }
}
```

---

## 6. Coupon Service

```java
@Service
@RequiredArgsConstructor
public class CouponService {
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @KafkaListener(topics = "payment-events", groupId = "saga-group")
    public void handlePaymentCompleted(PaymentCompletedEvent event) {
        if (Math.random() > 0.5) { // simulate coupon failure
            kafkaTemplate.send("coupon-events", new CouponFailedEvent(event.orderId(), "Invalid coupon"));
        } else {
            kafkaTemplate.send("coupon-events", new CouponAppliedEvent(event.orderId()));
        }
    }
}
```

---

## 7. Audit Service (Always Commits ‚Äî like REQUIRES\_NEW)

```java
@Service
@RequiredArgsConstructor
public class AuditService {
    private final AuditLogRepository auditRepo;

    @KafkaListener(topics = "audit-events", groupId = "saga-group")
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logAudit(AuditLogEvent event) {
        auditRepo.save(new AuditLog(event.orderId(), event.action(), LocalDateTime.now()));
    }
}
```

---

# üîë Key Enterprise Takeaways

1. **Saga = Compensating Transactions**

   * Instead of rollback, failed steps trigger compensating actions (`OrderCancelledEvent`).

2. **Local Transactions (`@Transactional`)**

   * Used only **within a service + local DB**.

3. **Events (Kafka)**

   * Ensure services remain decoupled.
   * Provide resilience (retry, replay).

4. **Idempotency**

   * Event handlers (`handlePayment`, `handleOrderEvents`) must be idempotent (safe to retry).

5. **Audit Service**

   * Mimics `REQUIRES_NEW` ‚Üí always commits logs, independent of failures.

---

This skeleton shows **how to implement a Saga Orchestration in Spring Boot using Kafka** with:

* Local `@Transactional`
* Distributed orchestration via events
* Compensation instead of rollback
* Independent logging with REQUIRES\_NEW





