Here are the **most common interview questions and answers** on **Java + React full stack integration**, focusing on **CORS** and **Proxy setup** ‚Äî a must-know topic for full stack developer interviews:

---

## üîê CORS (Cross-Origin Resource Sharing)

---

### üìå **Q1. What is CORS and why is it important in a full stack app?**

**Answer:**

**CORS (Cross-Origin Resource Sharing)** is a browser security feature that restricts web pages from making requests to a different domain than the one that served the web page.

In full stack apps (e.g., React on `localhost:3000` and Spring Boot on `localhost:8080`), CORS blocks calls because they are considered **cross-origin**.

To enable secure cross-origin communication, the backend must explicitly allow it using **CORS headers**.

---

### üìå **Q2. What happens if CORS is not configured?**

**Answer:**

The browser will block the API call with an error like:

```
Access to XMLHttpRequest at 'http://localhost:8080/api/data' from origin 'http://localhost:3000' has been blocked by CORS policy
```

‚Üí The request **never reaches the server** ‚Äî it's blocked at the **browser level**.

---

### üìå **Q3. How do you enable CORS in Spring Boot backend?**

**Answer 1: Global Configuration (recommended for full stack apps)**

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
  @Override
  public void addCorsMappings(CorsRegistry registry) {
    registry.addMapping("/**")
            .allowedOrigins("http://localhost:3000")
            .allowedMethods("*")
            .allowedHeaders("*");
  }
}
```

**Answer 2: On Controller Method (fine-grained control)**

```java
@CrossOrigin(origins = "http://localhost:3000")
@GetMapping("/api/data")
public ResponseEntity<?> getData() { ... }
```

---

### üìå **Q4. How do you avoid CORS issues from React during development?**

**Answer:**

Use a **proxy** in `vite.config.js`, `webpack.config.js`, or `package.json` to **bypass CORS** during development by letting the dev server forward API calls to the backend.

For CRA (`create-react-app`):

```json
// package.json
"proxy": "http://localhost:8080"
```

Then in React:

```js
fetch('/api/data')  // proxy will redirect to http://localhost:8080/api/data
```

No need to write full backend URL ‚Äî CORS is bypassed.

---

## üîÅ Proxy Setup (React Dev Server ‚Üí Spring Boot API)

---

### üìå **Q5. How does the React proxy work internally?**

**Answer:**

The React development server (Webpack or Vite) intercepts API calls (like `/api/...`) and forwards them to the target backend (`localhost:8080`), acting as a **reverse proxy**.

This makes it seem to the browser that the request is coming from the **same origin**, avoiding CORS checks altogether.

---

### üìå **Q6. When would you use a proxy vs setting CORS in backend?**

**Answer:**

| Scenario                           | Use                                        |
| ---------------------------------- | ------------------------------------------ |
| **Local development**              | Use **proxy** in React dev server          |
| **Production** (hosted separately) | Set **CORS** in the backend                |
| **Tightly controlled endpoints**   | Use fine-grained `@CrossOrigin` per method |

In **production**, proxying is not possible ‚Äî the backend **must support CORS**.

---

### üìå **Q7. Can you set CORS dynamically in Spring Boot?**

**Answer:**

Yes. You can allow dynamic CORS origins by using `HandlerInterceptor`, filters, or by reading allowed origins from a config:

```java
.allowedOrigins(environment.getProperty("app.cors.allowed-origins").split(","))
```

This is useful when you deploy the same backend across multiple environments.

---

### üìå **Q8. What are the CORS headers added by Spring when CORS is enabled?**

**Answer:**

Spring sets headers like:

```http
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```

These tell the browser what is allowed from the client‚Äôs origin.

---

### üìå **Q9. What is a preflight request in CORS?**

**Answer:**

Browsers send an **OPTIONS** request (called a **preflight**) before certain API calls (e.g., `POST`, `PUT`, `DELETE` with custom headers) to check if the server **allows CORS**.

The server must respond with proper headers, otherwise the main request is blocked.

Spring Boot handles this **automatically** if CORS is properly configured via `WebMvcConfigurer`.

---

### üìå **Q10. What‚Äôs a common mistake in proxy + CORS setup?**

**Answer:**

* Using proxy and still writing **full backend URL** (which defeats the proxy)
* Not matching exact origin in `allowedOrigins` (e.g., missing `http://` or port)
* Not allowing `Authorization` header in CORS config when using JWT
* Setting `allowedOrigins("*")` along with `allowCredentials(true)` ‚Üí **Not allowed**

