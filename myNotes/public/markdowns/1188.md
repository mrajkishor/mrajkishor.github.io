> Heavily tested in GATE.


# **Chapter 8 – Main Memory (Sections 8.1–8.6)**

---

## **8.1 Background**

* **Main memory** = Primary storage for processes while executing.
* Directly accessible by CPU, but volatile (data lost on power-off).
* Instructions must be **in memory** to be executed (von Neumann model).
* **Registers**: fastest, but smallest.
* **Cache**: between CPU and main memory for speedup.
* ==**Memory unit** interacts with CPU via **load/store instructions**.==

<blockquote>

<ins>Explanation of load/store instructions (Extra): 

### **==Memory unit interacts with CPU via load/store instructions==**

In a computer system, the **CPU** (Central Processing Unit) doesn’t directly manipulate memory data in place — instead, it uses **specific instructions** to either:

1. **Load** data from memory **into a CPU register** (so it can be processed).
2. **Store** data from a CPU register **back into memory** (so it’s saved for later).

---

#### **1. Why Load/Store?**

* The **CPU works at a much faster speed** than main memory (RAM).
* The CPU operates mostly on **registers** (small, fast storage inside the CPU).
* To use any data from memory, the CPU **must first bring it into a register**.
* After calculations, the result is **written back to memory** if needed.

---

#### **2. Load instruction**

* Transfers data **from memory → to a CPU register**.
* Example (in assembly):

  ```
  LOAD R1, 1000   ; Load value from memory address 1000 into register R1
  ```

#### **3. Store instruction**

* Transfers data **from a CPU register → to memory**.
* Example:

  ```
  STORE R1, 2000  ; Store value from register R1 into memory address 2000
  ```

---

#### **4. How this interaction happens**

1. The CPU sends a **memory address** to the memory unit.
2. For **load**:

   * Memory unit fetches the value at that address and sends it back to CPU.
3. For **store**:

   * CPU sends the value to memory along with the address.
4. The memory unit uses **address decoding and data bus** to transfer the data.

---

#### **5. Example in action**

Let’s say you want to **add two numbers from memory**:

**Assembly flow:**

```
LOAD R1, 1000     ; Get first number from memory[1000]
LOAD R2, 1004     ; Get second number from memory[1004]
ADD  R3, R1, R2   ; Add them → result in R3
STORE R3, 1008    ; Save result into memory[1008]
```

**Interaction:**
Memory unit was accessed **three times** (two loads + one store).

---

**In short:** The **only way** CPU talks to memory is through **load** (read from memory) and **store** (write to memory) instructions. The CPU never works directly on memory values — it must first bring them into registers.


</blockquote>

---

## **8.2 Address Binding**

**Binding** = Mapping program instructions/data to memory addresses.

Happens at 3 stages:

1. **Compile-time binding**

   * If memory location known at compile time.
   * Absolute addresses generated.
   * Must recompile if starting location changes.

2. **Load-time binding**

   * Address not known at compile time.
   * Compiler generates relocatable code.
   * Final binding done at load time.

3. **Execution-time binding**

   * Can move a process during execution.
   * Requires hardware support (MMU).

---

## **8.3 Logical vs Physical Address Space**

* **Logical address** (virtual address): Generated by CPU.
* **Physical address**: Actual location in memory unit.
* **Logical Address Space (LAS)** ≠ **Physical Address Space (PAS)** except in compile-time binding.

---

### **Memory-Management Unit (MMU)**

* Hardware that maps logical addresses → physical addresses.
* Base register (or relocation register) holds starting physical address.
* Logical address + base register = physical address.

---

## **8.4 Dynamic Loading and Linking**

* **Dynamic Loading**:

  * Load routine into memory only when called.
  * Reduces memory usage.
  * Useful for large programs.

* **Dynamic Linking**:

  * Linking postponed until execution time.
  * Often used with **shared libraries** (`.dll`, `.so`).

---

## **8.5 Swapping**

* Temporarily moves a process from main memory → backing store (disk) → back to memory for execution.
* Allows more processes to run.
* **Swap time** includes disk transfer time.
* Roll out & roll in strategy.

---

## **8.6 Contiguous Memory Allocation**

One of the simplest memory management methods:

* Each process occupies **single contiguous block** of memory.
* Requires **base** and **limit** registers:

  * **Base** → starting physical address.
  * **Limit** → size of allocated block.
* **Protection**: CPU checks if each logical address is within bounds.

### **Memory Allocation Methods**

1. **Single-partition allocation**:

   * OS in low memory, user processes in high memory.
   * Relocation register protects OS memory.

2. **Multiple-partition allocation**:

   * Memory divided into fixed or variable partitions.
   * **Variable partitioning**:

     * Allocate exactly needed size.
     * Leads to **external fragmentation**.

---

### **Fragmentation**

* **External Fragmentation**:

  * Free memory exists but scattered.
  * Example: 3 free holes of 100KB each, process needs 250KB → cannot allocate.
  * **Solution**: Compaction (costly).

* **Internal Fragmentation**:

  * Allocated memory slightly larger than requested → unused space inside partition.

---

### **Allocation Strategies**

* **First Fit**: Allocate first hole large enough.
* **Best Fit**: Allocate smallest hole large enough (more fragmentation).
* **Worst Fit**: Allocate largest hole (may leave small unusable pieces).
* **GATE Tip**: First Fit is generally fastest.

---

## **Exam Takeaways**

* **Definitions**: Binding types, logical vs physical addresses, MMU.
* **Numericals**: First Fit / Best Fit / Worst Fit allocation examples.
* **Conceptual**: Fragmentation differences & fixes.
* **Linking**: Understand difference between dynamic & static linking.

