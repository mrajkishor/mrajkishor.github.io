# ðŸ”· Concept: Error Handling in MySQL Stored Procedures

MySQL stored procedures encapsulate SQL logic in reusable units, but errors can occur during executionâ€”ranging from constraint violations (e.g., duplicate keys) to runtime exceptions (e.g., divide by zero, invalid data type).  
Unlike application code (Java, Python, etc.), MySQL has its own error handling mechanism inside stored procedures, primarily via **DECLARE â€¦ HANDLER** blocks.  

Error handling ensures:  
- Controlled response to failures.  
- Avoidance of transaction inconsistencies.  
- Graceful messaging/logging for debugging.  
- Implementation of **business rules** such as retries, rollbacks, or fallback logic.  

---

# ðŸ”· Error Types in MySQL

MySQL allows handlers for different categories of conditions:

1. **SQLEXCEPTION** â†’ Any SQL error (generic catch-all).  
2. **SQLWARNING** â†’ Warnings such as data truncation.  
3. **NOT FOUND** â†’ Cursor exhaustion or no rows found.  
4. **Error codes / SQLSTATE** â†’ Handling specific MySQL error numbers (like 1062 for duplicate entry).  

---

# ðŸ”· Declaring Handlers

Syntax:  
```sql
DECLARE handler_type HANDLER
FOR condition_value [, condition_value] ...
statement;
```

Where:
- **handler_type** â†’ CONTINUE, EXIT, UNDO  
  - `CONTINUE`: Resume execution with next statement.  
  - `EXIT`: Exit from current BEGINâ€¦END block immediately.  
  - `UNDO`: Not supported in MySQL (present in SQL standard).  

- **condition_value** â†’  
  - `SQLSTATE '45000'` (custom signal state)  
  - `SQLWARNING`  
  - `NOT FOUND`  
  - `SQLEXCEPTION`  
  - Specific error code (`1062`)  

---

# ðŸ”· Example 1: Handling Duplicate Key Error

```sql
DELIMITER $$

CREATE PROCEDURE insert_customer(IN p_id INT, IN p_name VARCHAR(50))
BEGIN
    DECLARE EXIT HANDLER FOR 1062
    BEGIN
        -- Duplicate entry error
        SELECT 'Duplicate entry detected, skipping insert' AS msg;
    END;

    INSERT INTO customers (id, name) VALUES (p_id, p_name);
END$$

DELIMITER ;
```

If a duplicate primary key is inserted, control exits and executes the handler instead of aborting the whole procedure.  

---

# ðŸ”· Example 2: Generic Error Handler with CONTINUE

```sql
DELIMITER $$

CREATE PROCEDURE safe_divide(IN numerator INT, IN denominator INT)
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SELECT 'Error occurred during division' AS msg;
    END;

    SELECT numerator / denominator AS result;
END$$

DELIMITER ;
```

If denominator is `0`, the exception is caught, and a controlled message is returned.  

---

# ðŸ”· Example 3: Handling Cursor Exhaustion (NOT FOUND)

```sql
DELIMITER $$

CREATE PROCEDURE fetch_orders()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE v_order_id INT;

    DECLARE cur CURSOR FOR SELECT order_id FROM orders;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO v_order_id;
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;
        SELECT v_order_id;
    END LOOP;

    CLOSE cur;
END$$

DELIMITER ;
```

Here, `NOT FOUND` gracefully ends the cursor loop.  

---

# ðŸ”· Using SIGNAL and RESIGNAL

MySQL 5.5+ introduced `SIGNAL` and `RESIGNAL` for custom error raising:  

- **SIGNAL** â†’ Generate a user-defined error.  
- **RESIGNAL** â†’ Re-throw an existing error with modified details.  

Example:  
```sql
CREATE PROCEDURE validate_salary(IN p_salary DECIMAL(10,2))
BEGIN
    IF p_salary < 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Salary cannot be negative',
                MYSQL_ERRNO = 10001;
    END IF;
END;
```

---

# ðŸ”· Best Practices (Enterprise-Level Insights)

1. **Granularity of Handlers**  
   - Use specific error codes (e.g., `1062`) instead of broad `SQLEXCEPTION` to avoid masking issues.  

2. **Transaction Safety**  
   - Combine error handling with transactions (`START TRANSACTION â€¦ COMMIT/ROLLBACK`).  
   - Rollback only critical changes, leave logs intact.  

3. **Custom Business Errors**  
   - Use `SIGNAL` to enforce business rules (e.g., disallow negative balances).  

4. **Logging Failures**  
   - Insert errors into an `error_log` table for auditing/debugging.  

5. **Exit vs Continue**  
   - Use `EXIT` for unrecoverable errors.  
   - Use `CONTINUE` for warnings or cursor iterations.  

6. **Integration with Applications**  
   - Applications should interpret custom SQLSTATE codes and take higher-level actions.  

---

# ðŸ”· Advanced Example: Transaction with Error Handling & Logging

```sql
DELIMITER $$

CREATE PROCEDURE transfer_funds(
    IN p_from INT,
    IN p_to INT,
    IN p_amount DECIMAL(10,2)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        INSERT INTO error_log (err_time, message)
        VALUES (NOW(), 'Transaction failed during transfer');
    END;

    START TRANSACTION;

    UPDATE accounts SET balance = balance - p_amount WHERE id = p_from;
    UPDATE accounts SET balance = balance + p_amount WHERE id = p_to;

    COMMIT;
END$$

DELIMITER ;
```

Here:  
- Any error rolls back both debits/credits.  
- Logs error for debugging.  

---

# ðŸ”· Summary

- **Error handling in MySQL stored procedures** is built on `DECLARE â€¦ HANDLER` and `SIGNAL/RESIGNAL`.  
- You can trap **specific errors, warnings, cursor exhaustion, or all exceptions**.  
- Correct use ensures **data consistency, better debugging, and enforcement of business rules**.  
- At Enterprise level, **handlers are coupled with logging, custom SQLSTATEs, and robust transaction management** to ensure reliability in mission-critical systems.  
