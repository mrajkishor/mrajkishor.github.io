

#  **Checked vs Unchecked Exceptions**

---

## üîç Overview

In Java, exceptions are broadly classified into:

* **Checked Exceptions** ‚Äì enforced at **compile-time**
* **Unchecked Exceptions** ‚Äì occur at **runtime**, i.e., `RuntimeException` and its subclasses

This distinction is critical to **API design**, **error resilience**, and **developer experience** ‚Äî and often features in **interviews**, where design decisions and trade-offs are deeply analyzed.

---

## ‚öñÔ∏è Quick Comparison Table

| Feature                          | **Checked Exception**                                | **Unchecked Exception**                            |
| -------------------------------- | ---------------------------------------------------- | -------------------------------------------------- |
| Inherits from                    | `Exception` (excluding `RuntimeException`)           | `RuntimeException`                                 |
| Compile-time enforcement         | ‚úÖ Required                                           | ‚ùå Optional                                         |
| Must declare in method signature | ‚úÖ `throws` clause required                           | ‚ùå Not needed                                       |
| Example types                    | `IOException`, `SQLException`                        | `NullPointerException`, `IllegalArgumentException` |
| Use case                         | External failures, I/O, business logic               | Programming bugs, logic flaws                      |
| Recoverable?                     | Often yes                                            | Often no                                           |
| Enterprise use?                       | Cautiously, only for critical recoverable operations | Preferred for internal logic validation            |

---

## üî∑ 1. **Checked Exceptions** (Compile-Time Enforced)

### üìå Definition:

Exceptions that must be either **caught** or **declared** in the method signature using `throws`.

### üîß Use Case:

When **client code must take an explicit recovery action**, e.g., file not found, network error, DB failure.

### üí° Common Checked Exceptions:

* `IOException`
* `SQLException`
* `ClassNotFoundException`
* `ParseException`

### üî¨ Code Example:

```java
public void readFile(String path) throws IOException {
    Files.readAllLines(Path.of(path));
}
```

OR

```java
try {
    readFile("config.txt");
} catch (IOException e) {
    // Handle error: show error message, fallback to defaults
}
```

---

## üî∂ 2. **Unchecked Exceptions** (Runtime Exceptions)

### üìå Definition:

Exceptions that are **not checked at compile time** and **do not require explicit handling**.

### üîß Use Case:

Represent **programming errors or logic violations** ‚Äì things that should never happen if the code is correct.

### üí° Common Unchecked Exceptions:

* `NullPointerException`
* `IllegalArgumentException`
* `ArrayIndexOutOfBoundsException`
* `ArithmeticException`
* `IllegalStateException`

### üî¨ Code Example:

```java
public int divide(int a, int b) {
    if (b == 0) {
        throw new IllegalArgumentException("Divisor cannot be zero");
    }
    return a / b;
}
```

No need to declare `throws` or force caller to catch this.

---

## üß† When to Use What?

| Scenario                                                   | Exception Type | Rationale                      |
| ---------------------------------------------------------- | -------------- | ------------------------------ |
| API expects caller to fix issue                            | Checked        | Enforce compile-time awareness |
| Caller should not be burdened                              | Unchecked      | Keep API cleaner               |
| Recoverable business logic failure (e.g., retry, fallback) | Checked        | Force user to handle           |
| Programmer error (null, illegal state)                     | Unchecked      | Encourage fail-fast            |

---

## üìö Real-World Analogy

| Situation                  | Type                                            |
| -------------------------- | ----------------------------------------------- |
| Driving without a seatbelt | Unchecked (you should know better)              |
| Traffic light not working  | Checked (external fault; needs active handling) |

---

## ‚ö†Ô∏è Drawbacks of Checked Exceptions

* ‚ùå **Cluttered method signatures**

  * Especially in deeply layered systems (controller ‚Üí service ‚Üí DAO)
* ‚ùå **Forces wrapping or propagation**

  * Often leads to boilerplate: `try { ... } catch (...) { throw new RuntimeException(...) }`
* ‚ùå **Discouraged in functional or reactive paradigms**

  * Lambdas don't work well with checked exceptions

---

## ‚úÖ Best Practices for Exception Usage (Enterprise-level)

| Do                                                                   | Don‚Äôt                                                                                |
| -------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| ‚úÖ Use checked exceptions for recoverable system errors               | ‚ùå Don‚Äôt overuse them for simple validation                                           |
| ‚úÖ Convert low-level checked exceptions to domain-specific exceptions | ‚ùå Don‚Äôt expose implementation exceptions (like `SQLException`) directly to UI layers |
| ‚úÖ Fail-fast with unchecked exceptions for invalid arguments          | ‚ùå Don‚Äôt catch `Exception` or `Throwable` blindly                                     |
| ‚úÖ Use custom exception hierarchy (e.g., `AppException`)              | ‚ùå Don‚Äôt swallow exceptions without logging or reporting                              |

---

## üßµ Custom Exception Example

```java
// Checked Exception
public class InvalidPaymentException extends Exception {
    public InvalidPaymentException(String msg) {
        super(msg);
    }
}

// Unchecked Exception
public class UnexpectedSystemStateException extends RuntimeException {
    public UnexpectedSystemStateException(String msg) {
        super(msg);
    }
}
```

---

## üí¨ Interview Insight

**Q:** *When would you use a checked exception vs unchecked?*

**A:**

> If a method exposes a scenario where the caller is expected to handle a recoverable situation ‚Äî like retrying a failed file read or handling business rule violations ‚Äî I use a **checked exception** to enforce it.
>
> But for internal logic bugs or improper usage ‚Äî like null arguments or invalid states ‚Äî I prefer **unchecked exceptions**, as they reflect coding errors that should be fixed, not caught.

---

## üßæ Summary

| Feature                    | Checked                    | Unchecked                        |
| -------------------------- | -------------------------- | -------------------------------- |
| Compile-time enforcement   | ‚úÖ Yes                      | ‚ùå No                             |
| Used for                   | Recoverable, external      | Logic, programming errors        |
| Subclass of                | `Exception`                | `RuntimeException`               |
| Needs `throws` declaration | ‚úÖ Yes                      | ‚ùå No                             |
| Best for                   | IO, DB, Business contracts | Validation, nulls, illegal state |

