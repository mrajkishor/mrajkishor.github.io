

# üåø  Inversion of Control (IoC) and Dependency Injection (DI)

---

## üîß Introduction

**Inversion of Control (IoC)** and **Dependency Injection (DI)** are fundamental design principles in the **Spring Core** module. They form the backbone of the **Spring Framework‚Äôs lightweight container**, enabling **loosely coupled**, **modular**, and **testable** Java applications.

Spring provides a powerful IoC container that manages object creation, lifecycle, and dependency wiring through **declarative configuration** (XML, annotations, Java config).

---

## üß≠ What Is Inversion of Control (IoC)?

> **Inversion of Control** is a design principle where the control of object creation and dependency management is inverted from the application code to the framework/container.

### Traditional Approach (Tightly Coupled)

```java
class OrderService {
    private final PaymentService paymentService = new PaymentService(); // hardcoded
}
```

### IoC Principle

The framework (Spring) creates and wires dependencies:

```java
class OrderService {
    private final PaymentService paymentService;

    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
```

The `OrderService` doesn‚Äôt create its dependencies ‚Äî **control is inverted**.

---

## üß© What Is Dependency Injection (DI)?

> **Dependency Injection** is a specific implementation of IoC where an object‚Äôs dependencies are provided externally, instead of the object creating them itself.

---

## üîå Types of Dependency Injection in Spring

| Type                      | Description                                       | Usage                                    |
| ------------------------- | ------------------------------------------------- | ---------------------------------------- |
| **Constructor Injection** | Dependencies are passed via constructor arguments | Preferred for required, immutable deps   |
| **Setter Injection**      | Dependencies are set via setter methods           | Useful for optional dependencies         |
| **Field Injection**       | Dependencies injected directly into fields        | Less testable, discouraged in production |

---

### ‚úÖ 1. Constructor Injection

```java
@Component
public class UserService {
    private final UserRepository userRepository;

    @Autowired // Optional in Spring >= 4.3+
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

* ==Guarantees immutability==
* Makes dependencies explicit
* Ideal for unit testing (via constructor args)

---

### ‚úÖ 2. Setter Injection

```java
@Component
public class EmailService {
    private NotificationService notificationService;

    @Autowired
    public void setNotificationService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
}
```

* ==Great for optional dependencies==
* Requires default constructor

---

### ‚úÖ 3. Field Injection (==Not Recommended==)

```java
@Component
public class AuthService {
    @Autowired
    private TokenManager tokenManager;
}
```

* Fast and concise
* ==**Not ideal for unit testing**==
* ==Breaks encapsulation and immutability==

---

## üîÑ How Spring Manages IoC Internally

### IoC Container Types:

| Container Type       | Description                                                |
| -------------------- | ---------------------------------------------------------- |
| `BeanFactory`        | Basic IoC container (lazy loading)                         |
| `ApplicationContext` | Full-featured container (eager loading, events, AOP, etc.) |

---

### Bean Lifecycle (Managed by IoC)

```
1. Object Instantiation
2. Dependency Injection
3. Bean Initialization (`@PostConstruct`, init-method)
4. Ready-to-use
5. Bean Destruction (`@PreDestroy`, destroy-method)
```

Spring intercepts all lifecycle phases using the IoC container.

---

## üõ† Bean Configuration Approaches in Spring

### 1. **Annotation-Based (Recommended)**

```java
@Component
public class OrderRepository {}

@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
}
```

* `@Component`, `@Service`, `@Repository`, `@Controller` auto-register beans
* `@Autowired` or constructor injection resolves dependencies

---

### 2. **Java-based Configuration**

```java
@Configuration
public class AppConfig {

    @Bean
    public UserRepository userRepository() {
        return new UserRepository();
    }

    @Bean
    public UserService userService(UserRepository repo) {
        return new UserService(repo); // constructor injection
    }
}
```

* Type-safe
* IDE-friendly
* Preferred for explicit configuration (e.g., external libraries)

---

### 3. **XML Configuration** (Legacy)

```xml
<bean id="userService" class="com.app.UserService">
    <constructor-arg ref="userRepository"/>
</bean>

<bean id="userRepository" class="com.app.UserRepository"/>
```

* Verbose and less maintainable
* Still used in legacy enterprise systems


> <ins>Note</ins>: __Legacy__ in software refers to outdated computer programs or applications that are still in use due to their critical function within an organization, despite being built on older technologies and lacking support, updates, or compatibility with modern systems. These systems often continue to be used because replacing them is complex, expensive, or involves significant disruption to existing business processes.

---

## üì¶ Spring's Dependency Resolution

* Uses **reflection** and **type-matching** to wire beans
* Supports **@Qualifier** for disambiguation
* Supports **@Primary** to define default bean among multiple candidates
* Enables **profiles** for environment-specific bean loading

---

### Bean Scope in IoC

| Scope         | Description                            |
| ------------- | -------------------------------------- |
| `singleton`   | Single shared instance (default)       |
| `prototype`   | New instance every time                |
| `request`     | One per HTTP request (web-aware beans) |
| `session`     | One per HTTP session                   |
| `application` | One per ServletContext                 |

---

## üß™ Testing IoC and DI

* Use `@MockBean` to replace actual beans in `@SpringBootTest`
* Use constructor injection to easily inject mocks
* Use `@ContextConfiguration` to provide test-specific beans
* Bean post-processors can simulate lifecycle hooks

---

## üìä Advantages of Spring IoC and DI

| Benefit               | Explanation                                            |
| --------------------- | ------------------------------------------------------ |
| Decoupling            | Components depend on abstractions, not implementations |
| Testability           | Easy mocking and unit testing                          |
| Reusability           | Reuse components with different configurations         |
| Lifecycle Management  | Spring handles full object lifecycle and cleanup       |
| Integration Readiness | Easily integrate with DB, web, messaging, etc.         |

---

## ‚ö†Ô∏è Common Pitfalls

| Problem                             | Cause                                        |
| ----------------------------------- | -------------------------------------------- |
| `NoSuchBeanDefinitionException`     | Missing component scan or manual config      |
| `BeanCurrentlyInCreationException`  | Circular dependency in constructor injection |
| `NullPointerException` on autowired | Field injection without proper context       |
| Too many responsibilities per bean  | Violates SRP; makes unit testing harder      |
| Overusing field injection           | Breaks testability and encapsulation         |

---

## üîç Summary

| Topic                      | Key Insight                                                   |
| -------------------------- | ------------------------------------------------------------- |
| Inversion of Control (IoC) | Spring framework manages object creation and lifecycle        |
| Dependency Injection (DI)  | Spring injects dependencies via constructor, setter, or field |
| DI Types                   | Constructor (preferred), Setter, Field (least preferred)      |
| Bean Scopes                | Singleton (default), Prototype, Request, Session              |
| Configuration Modes        | Annotations, Java Config, XML                                 |
| Container Types            | `BeanFactory`, `ApplicationContext`                           |

