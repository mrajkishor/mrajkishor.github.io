

# **Palindrome Checking**

## **Concept**

A palindrome is a string that reads the same forward and backward.
Examples: `"madam"`, `"racecar"`, `"level"`.
Non-palindrome examples: `"hello"`, `"world"`.

The task: **determine whether a given string is a palindrome**.

---

## **Approaches**

### **1. Reverse and Compare**

* **Idea**: Reverse the string and check if it equals the original.
* **Steps**:

  1. Convert string into reversed form.
  2. Compare original with reversed.
   
    ```java
    public class PalindromeCheck {
        // Method 1: Reverse and Compare
        public static boolean isPalindromeReverse(String s) {
            String reversed = new StringBuilder(s).reverse().toString();
            return s.equals(reversed);
        }

        public static void main(String[] args) {
            String str = "madam";
            System.out.println(isPalindromeReverse(str)); // true
        }
    }
    ```

* **Complexity**:

  * Time: `O(n)` (reversing + comparison).
  * Space: `O(n)` (extra memory for reversed string).
* **Example**: `"madam"` → reversed `"madam"` → match → palindrome.

---

### **2. Two-Pointer Approach**

* **Idea**: Compare characters from start and end moving inward.
* **Steps**:

  1. Initialize two pointers: `left = 0`, `right = n-1`.
  2. While `left < right`:

     * Compare `s[left]` and `s[right]`.
     * If mismatch → Not palindrome.
     * Else, move inward (`left++`, `right--`).
  3. If loop finishes without mismatch → Palindrome.

  ```java
    public class PalindromeCheck {
        // Method 2: Two-Pointer
        public static boolean isPalindromeTwoPointer(String s) {
            int left = 0, right = s.length() - 1;
            while (left < right) {
                if (s.charAt(left) != s.charAt(right)) {
                    return false;
                }
                left++;
                right--;
            }
            return true;
        }

        public static void main(String[] args) {
            String str = "racecar";
            System.out.println(isPalindromeTwoPointer(str)); // true
        }
    }
  ```

* **Complexity**:

  * Time: `O(n)` (single pass).
  * Space: `O(1)` (in-place check).
* **Most efficient**.

---

### **3. Recursive Approach**

* **Idea**: Check first and last characters, then recursively check the substring.
* **Steps**:

  1. Base case: if string length ≤ 1 → palindrome.
  2. If first ≠ last → Not palindrome.
  3. Else → Recurse on substring `s[1...n-2]`.
   
    ```java
    public class PalindromeCheck {
        // Method 3: Recursive
        public static boolean isPalindromeRecursive(String s, int left, int right) {
            if (left >= right) return true; // base case
            if (s.charAt(left) != s.charAt(right)) return false;
            return isPalindromeRecursive(s, left + 1, right - 1);
        }

        public static void main(String[] args) {
            String str = "level";
            System.out.println(isPalindromeRecursive(str, 0, str.length() - 1)); // true
        }
    }   
    ```

* **Complexity**:

  * Time: `O(n)`.
  * Space: `O(n)` (due to recursion stack).
* **Example**: `"level"`

  * Compare `'l'` and `'l'` → recurse `"eve"` → compare `'e'` and `'e'` → recurse `"v"` → palindrome.

---

### **4. Using Stack**

* **Idea**: Palindrome symmetry can be validated by stack reversal.
* **Steps**:

  1. Push all characters onto a stack.
  2. Pop characters one by one and form reversed string.
  3. Compare with original.
* **Complexity**:

  * Time: `O(n)`.
  * Space: `O(n)` (stack storage).
* **Less efficient than two-pointers but demonstrates stack usage.**

---

### **5. Using Queue + Stack (for understanding symmetry)**

* **Idea**: Queue reads forward, stack reads backward.
* **Steps**:

  1. Enqueue all characters in a queue.
  2. Push all characters in a stack.
  3. Compare dequeue vs pop for all characters.
  4. If all match → palindrome.
* **Complexity**: `O(n)` time, `O(n)` space.
* **Educational but redundant in practice.**

---

### **6. Case-Insensitive / Alphanumeric Palindrome**

* **Real-world enhancement**: Often we need to check ignoring spaces, punctuation, and case (like in phrases).
* **Example**: `"A man, a plan, a canal: Panama"` → palindrome if non-alphanumeric and cases are ignored.
* **Approach**:

  * Preprocess string: keep only letters/numbers, convert to lowercase.
  * Then apply two-pointer or reverse method.

---

### **7. XOR / Hashing Based Idea (Theoretical)**

* **Observation**: If string is palindrome, first half matches second half in reverse order.
* **XOR Check**: Compare `s[i]` XOR `s[n-1-i]` for all pairs → must be `0`.
* Not practical for Unicode / complex chars, but a fun trick for fixed alphabets.

---

## **Comparison of Approaches**

| Approach               | Time | Space | Practicality                      |
| ---------------------- | ---- | ----- | --------------------------------- |
| Reverse & Compare      | O(n) | O(n)  | Simple, direct                    |
| Two-Pointer            | O(n) | O(1)  | **Best**                          |
| Recursive              | O(n) | O(n)  | Educational, not memory efficient |
| Stack                  | O(n) | O(n)  | Conceptual                        |
| Queue + Stack          | O(n) | O(n)  | Overkill                          |
| Case-insensitive check | O(n) | O(1)  | Real-world usage                  |
| XOR trick              | O(n) | O(1)  | Rarely used                       |

---

✅ **In practice**:

* Use **two-pointer approach** for optimal memory and speed.
* Use **reverse+compare** for quick coding (especially in Python/JS).
* Use **case-insensitive cleaned string** for real-world text validation.

---

# Code



# ✅ Java Implementations

### **1. Reverse & Compare**

```java
public class PalindromeCheck {
    // Method 1: Reverse and Compare
    public static boolean isPalindromeReverse(String s) {
        String reversed = new StringBuilder(s).reverse().toString();
        return s.equals(reversed);
    }

    public static void main(String[] args) {
        String str = "madam";
        System.out.println(isPalindromeReverse(str)); // true
    }
}
```

---

### **2. Two-Pointer**

```java
public class PalindromeCheck {
    // Method 2: Two-Pointer
    public static boolean isPalindromeTwoPointer(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    public static void main(String[] args) {
        String str = "racecar";
        System.out.println(isPalindromeTwoPointer(str)); // true
    }
}
```

---

### **3. Recursive Approach**

```java
public class PalindromeCheck {
    // Method 3: Recursive
    public static boolean isPalindromeRecursive(String s, int left, int right) {
        if (left >= right) return true; // base case
        if (s.charAt(left) != s.charAt(right)) return false;
        return isPalindromeRecursive(s, left + 1, right - 1);
    }

    public static void main(String[] args) {
        String str = "level";
        System.out.println(isPalindromeRecursive(str, 0, str.length() - 1)); // true
    }
}
```

---

# ✅ TypeScript Implementations

### **1. Reverse & Compare**

```typescript
function isPalindromeReverse(s: string): boolean {
  const reversed = s.split("").reverse().join("");
  return s === reversed;
}

// Example
console.log(isPalindromeReverse("madam")); // true
```

---

### **2. Two-Pointer**

```typescript
function isPalindromeTwoPointer(s: string): boolean {
  let left = 0;
  let right = s.length - 1;

  while (left < right) {
    if (s[left] !== s[right]) {
      return false;
    }
    left++;
    right--;
  }
  return true;
}

// Example
console.log(isPalindromeTwoPointer("racecar")); // true
```

---

### **3. Recursive Approach**

```typescript
function isPalindromeRecursive(s: string, left: number, right: number): boolean {
  if (left >= right) return true; // base case
  if (s[left] !== s[right]) return false;
  return isPalindromeRecursive(s, left + 1, right - 1);
}

// Example
console.log(isPalindromeRecursive("level", 0, "level".length - 1)); // true
```

---

⚡ **Key Notes**:

* Java `StringBuilder.reverse()` is handy for method 1.
* TypeScript `split("") + reverse() + join("")` is the quick way.
* Two-pointer method is **most efficient** (O(1) space).
* Recursive method is elegant, but **not memory optimal** for very long strings.





