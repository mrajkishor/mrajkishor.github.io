
## Encapsulation and Access Modifiers

---

### 🔹 1. **What Is Encapsulation?**

**Encapsulation** is one of the four pillars of OOP (alongside Inheritance, Polymorphism, and Abstraction). It refers to **bundling data (attributes) and behavior (methods)** inside a class while **restricting direct access** to some internal parts of the object.

> 🔒 Goal: **Hide internal state** and expose only what’s necessary.

---

### 🧊 2. **Encapsulation in Python**

Unlike languages like Java or C++, **Python does not enforce access control strictly**. Instead, it relies on **naming conventions** and **developer discipline**.

#### Python supports 3 levels of attribute access:

| Modifier      | Syntax           | Access Level                   | Usage                           |
| ------------- | ---------------- | ------------------------------ | ------------------------------- |
| **Public**    | `self.attribute` | Accessible from anywhere       | Default for most attributes     |
| **Protected** | `_attribute`     | Conventionally private         | Internal use only; not enforced |
| **Private**   | `__attribute`    | Name mangled, harder to access | True encapsulation              |

---

### 🔍 3. **Public Members** – Open to All

```python
class User:
    def __init__(self, name):
        self.name = name  # Public

u = User("Kishore")
print(u.name)  # ✅ Accessible
```

🔓 Public members are **freely accessible** and modifiable:

```python
u.name = "Raj"  # ✅ Allowed
```

---

### 🔐 4. **Protected Members** – `_single_underscore`

```python
class User:
    def __init__(self):
        self._balance = 100  # Convention: for internal use

u = User()
print(u._balance)  # ✅ Technically allowed, but discouraged
```

🧠 ***Convention only*** — This tells other devs: “This is internal; don’t touch unless you know what you’re doing.”

---

### 🔒 5. **Private Members** – `__double_underscore`

```python
class User:
    def __init__(self):
        self.__secret = "password123"

u = User()
print(u.__secret)  # ❌ AttributeError
```

📦 But it’s still **accessible via name mangling**:

```python
print(u._User__secret)  # ✅ Accesses the private variable
```

### 🚫 Private does **not mean secure** – it just reduces accidental access.

---

### 🧠 6. **Why Use Encapsulation?**

| Reason                        | Benefit                                            |
| ----------------------------- | -------------------------------------------------- |
| ✅ Hide implementation details | Prevent misuse and bugs                            |
| ✅ Enforce invariants          | Ensure object remains valid                        |
| ✅ Cleaner API surface         | Only expose what matters                           |
| ✅ Enable future changes       | Implementation can change without breaking callers |
| ✅ Enable validation logic     | Use properties to validate data                    |

---

### ⚙️ 7. **Encapsulation via Getters and Setters (Pythonic Way)**

In Python, use the `@property` decorator for **controlled access**:

```python
class User:
    def __init__(self):
        self._age = 0

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("Age must be positive")
        self._age = value
```

```python
u = User()
u.age = 25     # Calls setter
print(u.age)   # Calls getter
```

🧠 This allows encapsulation **without changing interface**. Later, you can switch to a property **without affecting existing code**.

---

### 🔄 8. **Encapsulation + Inheritance Consideration**

Private members (`__var`) are **not directly accessible** in subclasses:

```python
class Parent:
    def __init__(self):
        self.__token = "abc123"

class Child(Parent):
    def show(self):
        print(self.__token)  # ❌ AttributeError
```

✔️ Solution:

```python
print(self._Parent__token)  # works via name mangling
```

But best practice: use `_protected` and `@property` for extensibility.

---

### 🚨 9. **Common Pitfalls**

| Mistake                   | Why It's Dangerous                                            |
| ------------------------- | ------------------------------------------------------------- |
| Directly exposing state   | Leads to tight coupling and hard-to-maintain code             |
| Overusing private members | Breaks inheritance flexibility                                |
| Skipping validation logic | Opens room for invalid or insecure object state               |
| Abusing `@property`       | Can lead to performance issues or hard-to-debug state changes |

---

### 🔬 10. **Real-World Applications**

| Domain          | Encapsulation Usage                                              |
| --------------- | ---------------------------------------------------------------- |
| Banking Systems | Protecting `balance`, `pin`, and transaction history             |
| E-commerce      | Hiding cart pricing logic or discount calculations               |
| Game Engines    | Keeping player health or status private                          |
| APIs            | Exposing only limited surface area, hiding internal computations |

---

### 💼 Example

In an internal **payment microservice**, encapsulation was used to:

* Hide account state (`__balance`)
* Restrict access to `set_balance()` to internal audit modules only
* Expose balance via `@property` while logging every access attempt
* Allow team to later switch balance backend from float to `Decimal` **without breaking public API**

---

### ✅ Summary Table

| Concept                             | Mastery Indicator                       |
| ----------------------------------- | --------------------------------------- |
| Public / Protected / Private naming | ✅ Clear and consistent usage            |
| `@property` with validation         | ✅ Encapsulated access control           |
| Inheritance-aware access modifiers  | ✅ Subclass-safe encapsulation           |
| Encapsulation + API design          | ✅ Clean object contracts                |
| Security & Invariants               | ✅ Internal logic guarded against misuse |

---

## 🚀 Final Verdict

Python’s access modifiers are **soft but powerful**. When combined with:

* `@property`
* `_protected` convention
* Clear method-level APIs

They enable **robust encapsulation** suitable for any **enterprise-grade, multi-team system**.


