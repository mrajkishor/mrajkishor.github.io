

# ðŸ”· Concept: Procedural Constructs in MySQL

MySQL is not just a query language; inside **Stored Procedures (SPs)** and **Functions**, it also supports **procedural programming constructs** that make SQL behave like a lightweight programming language.
These constructs enable **control flow**, **conditional logic**, and **iteration**, which are critical for writing **complex business logic directly inside the database**.

Key constructs include:

* **DECLARE** â†’ defines variables, cursors, and handlers.
* **IF / CASE** â†’ conditional branching.
* **WHILE / REPEAT / LOOP** â†’ iterative execution.
* **LEAVE / ITERATE** â†’ control statements inside loops.

This allows developers to design logic-heavy, data-close applications without excessive round trips between app and DB.

---

# ðŸ”· DECLARE

`DECLARE` is used to define local variables, cursors, and handlers within a **BEGIN â€¦ END block**.
Variables declared via `DECLARE` exist only inside the block scope.

### Syntax

```sql
DECLARE var_name data_type [DEFAULT value];
```

### Example

```sql
DELIMITER $$

CREATE PROCEDURE declare_example()
BEGIN
    DECLARE total_orders INT DEFAULT 0;
    SELECT COUNT(*) INTO total_orders FROM orders;
    SELECT total_orders AS orders_count;
END$$

DELIMITER ;
```

### Enterprise-level Notes

* Variables must be declared **before any executable statements**.
* Default values are optional but highly recommended to avoid NULL surprises.
* Often paired with `SET` or `SELECT â€¦ INTO` for assignment.

---

# ðŸ”· IF â€¦ ELSEIF â€¦ ELSE

Used for conditional branching.

### Syntax

```sql
IF condition THEN
    statements;
ELSEIF condition THEN
    statements;
ELSE
    statements;
END IF;
```

### Example

```sql
CREATE PROCEDURE discount_check(IN p_amount DECIMAL(10,2))
BEGIN
    IF p_amount > 1000 THEN
        SELECT 'High Discount' AS status;
    ELSEIF p_amount > 500 THEN
        SELECT 'Medium Discount' AS status;
    ELSE
        SELECT 'No Discount' AS status;
    END IF;
END;
```

### Enterprise-level Notes

* Mirrors application `if-else` semantics.
* Nesting multiple `IF`s should be avoided; use `CASE` for readability.
* Ideal for **business rule enforcement** directly at DB layer.

---

# ðŸ”· WHILE Loop

Executes statements as long as the condition remains true.

### Syntax

```sql
WHILE condition DO
    statements;
END WHILE;
```

### Example

```sql
CREATE PROCEDURE while_example()
BEGIN
    DECLARE counter INT DEFAULT 1;
    WHILE counter <= 5 DO
        SELECT CONCAT('Iteration: ', counter) AS msg;
        SET counter = counter + 1;
    END WHILE;
END;
```

### Enterprise-level Notes

* Useful for **bounded iterations**.
* Avoid misuse for large sets â†’ prefer set-based SQL operations for efficiency.
* Often combined with **cursors** for row-by-row processing.

---

# ðŸ”· LOOP (Unconditional)

`LOOP` provides a flexible looping construct without an inherent condition. You must explicitly **LEAVE** (exit) or **ITERATE** (restart) it.

### Syntax

```sql
[loop_label:] LOOP
    statements;
    IF exit_condition THEN
        LEAVE loop_label;
    END IF;
END LOOP;
```

### Example

```sql
CREATE PROCEDURE loop_example()
BEGIN
    DECLARE counter INT DEFAULT 1;

    simple_loop: LOOP
        IF counter > 5 THEN
            LEAVE simple_loop;
        END IF;

        SELECT CONCAT('Counter = ', counter);
        SET counter = counter + 1;
    END LOOP;
END;
```

### Enterprise-level Notes

* Provides **maximum control** (similar to `for(;;)` in C/Java).
* Useful when exit conditions are **dynamic** or complex.
* Should always be paired with a termination strategy to avoid infinite loops.

---

# ðŸ”· Supporting Constructs (LEAVE, ITERATE, REPEAT)

* **LEAVE** â†’ exits from a loop or block prematurely.
* **ITERATE** â†’ skips to the next iteration of the loop.
* **REPEAT â€¦ UNTIL â€¦ END REPEAT** â†’ do-while style loop.

Example:

```sql
CREATE PROCEDURE repeat_example()
BEGIN
    DECLARE counter INT DEFAULT 1;
    REPEAT
        SELECT CONCAT('Counter = ', counter);
        SET counter = counter + 1;
    UNTIL counter > 5
    END REPEAT;
END;
```

---

# ðŸ”· Advanced Example: Combining Constructs with DECLARE & Cursor

```sql
DELIMITER $$

CREATE PROCEDURE process_orders()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE v_order_id INT;
    DECLARE v_amount DECIMAL(10,2);

    DECLARE cur CURSOR FOR SELECT order_id, amount FROM orders;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    OPEN cur;

    order_loop: LOOP
        FETCH cur INTO v_order_id, v_amount;
        IF done = 1 THEN
            LEAVE order_loop;
        END IF;

        IF v_amount > 1000 THEN
            UPDATE orders SET priority = 'HIGH' WHERE order_id = v_order_id;
        ELSE
            UPDATE orders SET priority = 'NORMAL' WHERE order_id = v_order_id;
        END IF;
    END LOOP;

    CLOSE cur;
END$$

DELIMITER ;
```

This shows **DECLARE (variables + cursor + handler)**, **IF**, and **LOOP** working together to apply business rules.

---

# ðŸ”· Best Practices (Enterprise-Level Insights)

1. **Prefer Set-Based SQL**

   * Loops (WHILE/LOOP) should be last resortâ€”row-by-row is slower.
   * Use them only for **cursor-driven tasks** or logic not expressible in SQL.

2. **Keep Loops Bounded**

   * Always include `LEAVE` or condition checks to avoid infinite loops.

3. **Variable Scoping Discipline**

   * Use clear, consistent naming (e.g., `v_` prefix for variables).
   * Avoid over-declaring variables.

4. **Modularization**

   * Break complex conditions into **helper procedures/functions** for readability.

5. **Error Handling Integration**

   * Combine with `DECLARE HANDLER` for robust procedures (e.g., cursor NOT FOUND).

6. **Readability Matters**

   * Use labels (`loop_label:`) when nesting multiple loops.

---

# ðŸ”· Summary

* **DECLARE** introduces scoped variables, cursors, and handlers.
* **IF â€¦ ELSEIF â€¦ ELSE** enables conditional branching.
* **WHILE / REPEAT / LOOP** provide iterative control.
* **LEAVE / ITERATE** manage execution inside loops.
* Together, these constructs allow MySQL stored procedures to mimic application-level control flow, crucial for **data-close business logic**.

At a Enterprise level, mastery of these constructs means:

* Knowing **when to use them vs set-based SQL**.
* Designing for **transactional safety** and **performance awareness**.
* Writing **readable, maintainable** procedural SQL that integrates with error handling and application code.

