

# ðŸ”· Recursion â€“ A Deep Dive

## 1. Concept

Recursion is the process where a function calls itself directly or indirectly until a **base condition** is satisfied.
It transforms a large problem into smaller subproblems of the same type. Recursion is widely used in algorithms, problem-solving, and real-world programming.

* **Formal definition**: A recursive function is one that solves a problem by reducing it into one or more smaller instances of the same problem, and combining their results.
* **Core principle**: Every recursive solution must have:

  1. **Base Case** â†’ Stops recursion and prevents infinite loops.
  2. **Recursive Case** â†’ Defines how the problem reduces in each step.

---

## 2. Recursion Stack & Memory Model

When a recursive call is made:

* The current function execution is **pushed onto the call stack**.
* Each function must complete before control returns to its caller.
* Without a base case, recursion runs indefinitely â†’ leading to **Stack Overflow**.

ðŸ”¹ Example:
A function `f()` calling itself infinitely will keep stacking frames until memory is exhausted, resulting in:

* **Segmentation Fault (C/C++)**
* **StackOverflowError (Java)**
* **RecursionError (Python)**

---

## 3. Base Condition

The **termination point** of recursion.
Without it, recursion becomes infinite.

Example (printing numbers from 0 to 2):

```cpp
int count = 0;

void func() {
    if (count == 3) return;   // base case
    cout << count << endl;    // work
    count++;                  // move towards base case
    func();                   // recursive call
}

int main() {
    func();
}
```

Output:

```
0
1
2
```

---

## 4. Recursive Tree

A **recursive tree** is the visual expansion of recursive calls. It represents:

* How each function call spawns further calls.
* How execution eventually **returns back** up the stack.

Example:

```
f(0)
 â””â”€â”€ f(1)
      â””â”€â”€ f(2)
           â””â”€â”€ base condition â†’ return
```

Execution unwinds in **reverse order**, returning control from the deepest call back to the root.

---

## 5. Practical Insights

* **Recursion â‰  Iteration**
  Recursion is elegant but may not always be efficient due to stack overhead. Iterative solutions may be preferable when memory constraints exist.

* **Tail Recursion Optimization (TRO)**
  Some compilers/languages (e.g., functional languages, GCC under flags) optimize *tail-recursive* calls by reusing stack frames.
  Example of tail recursion:

  ```cpp
  void print(int n) {
      if (n == 0) return;
      cout << n << " ";
      print(n-1);   // tail call
  }
  ```

* **Space Complexity**
  Recursive algorithms consume O(depth) stack space. For deep recursion, this can lead to crashes. For example:

  * Binary tree DFS â†’ O(h) space (h = height).
  * MergeSort â†’ O(log n) recursion depth.

* **Time Complexity**
  Often easier to analyze using **recurrence relations** (e.g., T(n) = 2T(n/2) + O(n)).

---

## 6. Use Cases of Recursion

Recursion appears in many core interview problems:

* **Divide and Conquer** â†’ MergeSort, QuickSort, Binary Search.
* **Tree Traversals** â†’ Preorder, Inorder, Postorder.
* **Backtracking** â†’ N-Queens, Sudoku Solver, Word Search.
* **Dynamic Programming (Top-Down Memoization)** â†’ Fibonacci, Coin Change.
* **Graph Traversals** â†’ DFS, Connected Components.

---

## 7. Common Pitfalls in Interviews

1. **Missing base case** â†’ Leads to infinite recursion.
2. **Not moving towards base case** â†’ Stuck in endless loop.
3. **Ignoring stack overflow risk** â†’ Candidate fails to discuss limitations.
4. **Not explaining recursion tree** â†’ Interviewers expect visualization.
5. **Inefficient recursion** â†’ Fibonacci naive recursion (O(2^n)) unless optimized with memoization.

---

## 8. Interview-Ready Checklist

When solving recursion problems in interviews:

* âœ… Clearly define base case(s).
* âœ… Write recurrence relation (time complexity).
* âœ… Discuss space overhead due to recursion stack.
* âœ… Mention iterative alternative (if exists).
* âœ… Draw recursion tree (for clarity).
* âœ… Optimize with **memoization** or **tail recursion** if required.

---

## 9. Example Question

**Q:** Write a recursive function to compute the factorial of `n`.

```cpp
int factorial(int n) {
    if (n == 0 || n == 1) return 1;   // base case
    return n * factorial(n-1);        // recursive case
}
```

* Recurrence: T(n) = T(n-1) + O(1) â†’ O(n)
* Space: O(n) stack depth
* Follow-up: Optimize using tail recursion or iterative approach.

---

## ðŸ”‘ Summary

Recursion is:

* A **powerful abstraction** to simplify problems.
* Must always include **base condition** to terminate.
* **Stack space** is a critical limitation.
* Visualized best with **recursive trees**.
* Applied in **divide & conquer, trees, graphs, DP, and backtracking**.

Mastery of recursion is fundamental for level interviews because it tests **problem decomposition, complexity analysis, and clear communication of ideas**.

