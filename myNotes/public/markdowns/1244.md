

# Approaches to Reverse an Array

Reversing an array is a fundamental problem in programming, often used to test one‚Äôs understanding of **iteration, recursion, data structures, and in-place operations**. The goal is to rearrange the elements of the array such that the first becomes last, the second becomes second-last, and so on.

---

## 1. **Iterative Two-Pointer Approach (In-Place Swap)**

**Idea:** Use two pointers, one starting from the beginning (`left`) and one from the end (`right`). Swap the values and move the pointers closer until they meet.

**Steps:**

1. Initialize `left = 0`, `right = n-1`.
2. Swap `arr[left]` and `arr[right]`.
3. Increment `left`, decrement `right`.
4. Repeat until `left >= right`.

```java
public static void reverseIterative(int[] arr) {
    int left = 0, right = arr.length - 1;
    while (left < right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
        left++;
        right--;
    }
}
```


**Example:**
Input: `[1, 2, 3, 4, 5]`
Output: `[5, 4, 3, 2, 1]`

**Complexity:**

* Time: O(n) (each element is swapped once).
* Space: O(1) (no extra memory).

**Pros/Cons:**
‚úÖ Most efficient and widely used.
‚ùå Requires manual implementation.

---

## 2. **Using a Temporary Array**

**Idea:** Create a new array and fill it with elements from the original in reverse order.

**Steps:**

1. Create `temp[n]`.
2. Traverse original array from `n-1` to `0`.
3. Copy elements into `temp`.
4. If needed, copy `temp` back into original array.

```java
public static int[] reverseWithTemp(int[] arr) {
    int n = arr.length;
    int[] temp = new int[n];
    for (int i = 0; i < n; i++) {
        temp[i] = arr[n - 1 - i];
    }
    return temp;
}
```


**Example:**
Input: `[10, 20, 30]`
Output: `[30, 20, 10]`

**Complexity:**

* Time: O(n).
* Space: O(n) (extra array used).

**Pros/Cons:**
‚úÖ Very easy to implement.
‚ùå Not memory-efficient.

---

## 3. **Recursive Approach**

**Idea:** Reverse by swapping first and last, then recursively reverse the remaining sub-array.

**Steps:**

1. Base case: if `start >= end`, stop.
2. Swap `arr[start]` with `arr[end]`.
3. Recurse with `start+1, end-1`.

```java
public static void reverseRecursive(int[] arr, int left, int right) {
    if (left >= right) return;
    int temp = arr[left];
    arr[left] = arr[right];
    arr[right] = temp;
    reverseRecursive(arr, left + 1, right - 1);
}
```

**Example:**
Input: `[1, 2, 3, 4]`
Recursion steps:

* Swap `1 ‚Üî 4 ‚Üí [4, 2, 3, 1]`
* Swap `2 ‚Üî 3 ‚Üí [4, 3, 2, 1]`

**Complexity:**

* Time: O(n).
* Space: O(n) (recursive call stack).

**Pros/Cons:**
‚úÖ Elegant and showcases recursion.
‚ùå Not suitable for very large arrays (stack overflow).

---

## 4. **Using Stack**

**Idea:** Stack follows **LIFO (Last-In-First-Out)** principle, which naturally reverses the order.

**Steps:**

1. Push all elements into a stack.
2. Pop elements one by one and put them back into the array.

```java
public static void reverseWithStack(int[] arr) {
    Stack<Integer> stack = new Stack<>();
    for (int num : arr) stack.push(num);
    for (int i = 0; i < arr.length; i++) arr[i] = stack.pop();
}
```

**Example:**
Input: `[1, 2, 3]`
Stack Push: `[1, 2, 3]`
Pop into array: `[3, 2, 1]`

**Complexity:**

* Time: O(n).
* Space: O(n) (stack used).

**Pros/Cons:**
‚úÖ Easy to understand for beginners.
‚ùå Wastes extra memory.

---

## 5. **Using Built-in Functions / Libraries**

Most programming languages provide utilities to reverse arrays/lists.

* **Python:**

  * `arr.reverse()` (in-place).
  * `arr[::-1]` (slicing).
* **Java:** `Collections.reverse(Arrays.asList(arr))`.
* **C++:** `reverse(arr.begin(), arr.end())`.

**Complexity:**

* Time: O(n).
* Space: O(1) (usually in-place).

**Pros/Cons:**
‚úÖ Very fast and clean.
‚ùå Depends on library, not always available in low-level coding rounds.

---

## 6. **Using XOR Swap (Without Temporary Variable)**

**Idea:** ==Swap elements without a third variable, using XOR.==

**Steps:**
For `arr[i]` and `arr[j]`:

```c
arr[i] = arr[i] ^ arr[j];
arr[j] = arr[i] ^ arr[j];
arr[i] = arr[i] ^ arr[j];
```

Then move `i++`, `j--`.

**Example:**
Input: `[1, 2, 3]`
Output: `[3, 2, 1]`

**Complexity:**

* Time: O(n).
* Space: O(1).

**Pros/Cons:**
‚úÖ Clever, saves a temporary variable.
‚ùå Readability suffers, can cause confusion.

---

# üìå Summary Table

| Approach              | Time | Space | Suitable For                    |
| --------------------- | ---- | ----- | ------------------------------- |
| Two-pointer Iterative | O(n) | O(1)  | Best choice, simple + efficient |
| Temporary Array       | O(n) | O(n)  | Easy but memory-heavy           |
| Recursive             | O(n) | O(n)  | Recursion practice              |
| Stack                 | O(n) | O(n)  | Data structure illustration     |
| Built-in Functions    | O(n) | O(1)  | Real-world programming          |
| XOR Swap              | O(n) | O(1)  | Tricky, interview puzzle        |

---

üëâ In real-world software development, the **two-pointer iterative approach** or **built-in reverse functions** are preferred, since they are both efficient and clean.

---


# Code



# ‚úÖ Java Implementations

```java
import java.util.*;

public class ReverseArray {

    // 1. Iterative Two-Pointer (In-place)
    public static void reverseIterative(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }

    // 2. Using Temporary Array
    public static int[] reverseWithTemp(int[] arr) {
        int n = arr.length;
        int[] temp = new int[n];
        for (int i = 0; i < n; i++) {
            temp[i] = arr[n - 1 - i];
        }
        return temp;
    }

    // 3. Recursive Approach
    public static void reverseRecursive(int[] arr, int left, int right) {
        if (left >= right) return;
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
        reverseRecursive(arr, left + 1, right - 1);
    }

    // 4. Using Stack
    public static void reverseWithStack(int[] arr) {
        Stack<Integer> stack = new Stack<>();
        for (int num : arr) stack.push(num);
        for (int i = 0; i < arr.length; i++) arr[i] = stack.pop();
    }

    // 5. Using Collections (works for Integer[] not int[])
    public static void reverseWithCollections(Integer[] arr) {
        List<Integer> list = Arrays.asList(arr);
        Collections.reverse(list);
        list.toArray(arr);
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};

        reverseIterative(arr);
        System.out.println("Iterative: " + Arrays.toString(arr));

        int[] temp = reverseWithTemp(arr);
        System.out.println("Temp Array: " + Arrays.toString(temp));

        reverseRecursive(arr, 0, arr.length - 1);
        System.out.println("Recursive: " + Arrays.toString(arr));

        reverseWithStack(arr);
        System.out.println("Stack: " + Arrays.toString(arr));

        Integer[] arrObj = {10, 20, 30, 40};
        reverseWithCollections(arrObj);
        System.out.println("Collections: " + Arrays.toString(arrObj));
    }
}
```

---

# ‚úÖ TypeScript Implementations

```typescript
// 1. Iterative Two-Pointer (In-place)
function reverseIterative(arr: number[]): void {
  let left = 0, right = arr.length - 1;
  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
}

// 2. Using Temporary Array
function reverseWithTemp(arr: number[]): number[] {
  const temp: number[] = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    temp.push(arr[i]);
  }
  return temp;
}

// 3. Recursive Approach
function reverseRecursive(arr: number[], left: number, right: number): void {
  if (left >= right) return;
  [arr[left], arr[right]] = [arr[right], arr[left]];
  reverseRecursive(arr, left + 1, right - 1);
}

// 4. Using Stack
function reverseWithStack(arr: number[]): void {
  const stack: number[] = [];
  arr.forEach(el => stack.push(el));
  for (let i = 0; i < arr.length; i++) {
    arr[i] = stack.pop()!;
  }
}

// 5. Using Built-in Functions
function reverseBuiltin(arr: number[]): number[] {
  return arr.slice().reverse(); // returns new reversed copy
}

// Demo
let arr1 = [1, 2, 3, 4, 5];
reverseIterative(arr1);
console.log("Iterative:", arr1);

let arr2 = [1, 2, 3, 4, 5];
console.log("Temp Array:", reverseWithTemp(arr2));

let arr3 = [1, 2, 3, 4, 5];
reverseRecursive(arr3, 0, arr3.length - 1);
console.log("Recursive:", arr3);

let arr4 = [1, 2, 3, 4, 5];
reverseWithStack(arr4);
console.log("Stack:", arr4);

let arr5 = [1, 2, 3, 4, 5];
console.log("Builtin:", reverseBuiltin(arr5));
```

---

üëâ In **coding interviews**, Java iterative + recursive are most expected.
üëâ In **real projects**, TypeScript `reverse()` (built-in) or slice/functional methods are more common.


---

## **XOR swap approach** in both **Java** and **TypeScript**.  

==This is a ‚Äútrick‚Äù method often asked in interviews to test knowledge of bitwise operations.==



# üîπ Java ‚Äì XOR Swap Array Reversal  

```java
public class ReverseArrayXOR {

    // XOR Swap based reversal
    public static void reverseWithXOR(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            // Swap using XOR (no temp variable)
            arr[left] = arr[left] ^ arr[right];
            arr[right] = arr[left] ^ arr[right];
            arr[left] = arr[left] ^ arr[right];
            
            left++;
            right--;
        }
    }

    public static void main(String[] args) {
        int[] arr = {5, 10, 15, 20};
        reverseWithXOR(arr);
        System.out.println("XOR Swap: " + java.util.Arrays.toString(arr));
    }
}
```

**Output:**  
```
XOR Swap: [20, 15, 10, 5]
```

---

# üîπ TypeScript ‚Äì XOR Swap Array Reversal  

```typescript
function reverseWithXOR(arr: number[]): void {
  let left = 0, right = arr.length - 1;
  while (left < right) {
    // XOR swap trick
    arr[left] = arr[left] ^ arr[right];
    arr[right] = arr[left] ^ arr[right];
    arr[left] = arr[left] ^ arr[right];

    left++;
    right--;
  }
}

// Demo
let arr = [5, 10, 15, 20];
reverseWithXOR(arr);
console.log("XOR Swap:", arr);
```

**Output:**  
```
XOR Swap: [20, 15, 10, 5]
```

---

## ‚ö° Notes on XOR Swap Approach:
- Works only with **integer values** (since XOR is bitwise).  
- Avoid when `arr[left]` and `arr[right]` refer to the **same memory location** ‚Äî it will zero out the value.  
- **Time:** O(n), **Space:** O(1).  
- Clever but **less readable** than a normal swap with a temp variable.  

---

## Dry Run (of XOR approach):


Let‚Äôs do a **step-by-step dry run** of the **XOR swap approach** to reverse an array.

We‚Äôll use the array:

```
arr = [5, 10, 15, 20]
```

---

## üîπ Step 1: Initialization

```
left = 0   ‚Üí arr[left] = 5
right = 3  ‚Üí arr[right] = 20
```

---

## üîπ Step 2: First XOR Swap (between 5 and 20)

1. `arr[left] = arr[left] ^ arr[right]`
   ‚Üí `arr[0] = 5 ^ 20 = 17`
   Now: `arr = [17, 10, 15, 20]`

2. `arr[right] = arr[left] ^ arr[right]`
   ‚Üí `arr[3] = 17 ^ 20 = 5`
   Now: `arr = [17, 10, 15, 5]`

3. `arr[left] = arr[left] ^ arr[right]`
   ‚Üí `arr[0] = 17 ^ 5 = 20`
   Now: `arr = [20, 10, 15, 5]`

‚úÖ Successfully swapped `5 ‚Üî 20`.

Update pointers:

```
left = 1, right = 2
```

---

## üîπ Step 3: Second XOR Swap (between 10 and 15)

1. `arr[left] = arr[left] ^ arr[right]`
   ‚Üí `arr[1] = 10 ^ 15 = 5`
   Now: `arr = [20, 5, 15, 5]`

2. `arr[right] = arr[left] ^ arr[right]`
   ‚Üí `arr[2] = 5 ^ 15 = 10`
   Now: `arr = [20, 5, 10, 5]`

3. `arr[left] = arr[left] ^ arr[right]`
   ‚Üí `arr[1] = 5 ^ 10 = 15`
   Now: `arr = [20, 15, 10, 5]`

‚úÖ Successfully swapped `10 ‚Üî 15`.

Update pointers:

```
left = 2, right = 1 ‚Üí stop
```

---

## üîπ Final Array

```
[20, 15, 10, 5]
```

---

## ‚ö° Key Observations:

* At each swap, we used **3 XOR operations** instead of a temporary variable.
* The array is reversed **in-place** with **O(1) extra space**.
* Be careful: if `left == right` (same index), XOR will **zero out the value**, so we must stop when `left >= right`.

