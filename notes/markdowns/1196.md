

# üìò Chapter 4 ‚Äì The Relational Model

---

## 1. Brief History of the Relational Model

* Proposed by **E. F. Codd in 1970** in his landmark paper *‚ÄúA Relational Model of Data for Large Shared Data Banks.‚Äù*
* Before relational databases, data was stored in **hierarchical (tree-like)** or **network models** (pointers/links).
* Problems with older models: complex navigation, low flexibility, and poor scalability.
* Relational model introduced a **mathematical foundation** based on **set theory** and **first-order predicate logic**.
* Today, relational databases are the **dominant standard** (Oracle, MySQL, PostgreSQL, SQL Server).

---

## 2. Terminology

The relational model uses precise terms.

### 2.1 Relational Data Structure

* A **relation** = table.
* A **tuple** = row.
* An **attribute** = column.
* A **domain** = set of valid values for an attribute.
* A **schema** = structure/blueprint of the database.
* An **instance** = actual data at a given moment.

### 2.2 Mathematical Relations

* Relation = a **subset of Cartesian product** of domains.
* Example: Relation STUDENT(Name, Age, Major) ‚äÜ Domain(Name) √ó Domain(Age) √ó Domain(Major).

### 2.3 Database Relations

* A relational database is a **collection of relations**.
* Each relation has a unique **name**.
* Tuples are **unordered**, attributes are **unordered**.

### 2.4 Properties of Relations

1. Each relation has a unique name.
2. Tuples (rows) are distinct (no duplicates).
3. Attributes have unique names within a relation.
4. Values are atomic (no repeating groups / multi-valued attributes).
5. Ordering of tuples and attributes is irrelevant.

### 2.5 Relational Keys

* **Superkey**: Any set of attributes that uniquely identifies a tuple.
* **Candidate Key**: Minimal superkey.
* **Primary Key**: Chosen candidate key (main identifier).
* **Alternate Key**: Candidate key not chosen as primary.
* **Foreign Key**: Attribute(s) referencing a primary key in another relation.
* **Composite Key**: Key formed by multiple attributes.

### 2.6 Representing Schemas

* Schema notation: **RelationName(Attribute1, Attribute2, ‚Ä¶)**
* Example: EMPLOYEE(EmpNo, Name, DeptNo, Salary).

---

## 3. Integrity Constraints

Integrity constraints ensure **data accuracy and consistency**.

### 3.1 Nulls

* Null = missing/unknown/undefined value.
* Issues: interpretation ambiguity, affects queries and aggregates.
* SQL treats NULLs specially (e.g., `NULL ‚â† NULL`).

### 3.2 Entity Integrity

* Every relation must have a **primary key**.
* Primary key cannot contain NULL.

### 3.3 Referential Integrity

* If attribute(s) in one relation reference another relation‚Äôs primary key ‚Üí must match existing value.
* Example: DEPT(DeptNo) must exist if EMP(DeptNo) refers to it.

### 3.4 General Constraints

* Any business rule expressed as a condition (e.g., ‚Äúsalary > 0‚Äù).
* Enforced through **CHECK constraints, triggers, assertions**.

---

## 4. Views

A **view** = a virtual table defined by a query.

### 4.1 Terminology

* View does not physically store data ‚Üí instead it **presents data derived from base tables**.

### 4.2 Purpose of Views

* **Security**: restricts access to specific columns/rows.
* **Simplicity**: provides a customized subset of data.
* **Logical independence**: shields users from schema changes.
* **Consistency**: presents derived/aggregated data.

### 4.3 Updating Views

* Some views are **updatable** (if based on a single table, no aggregates).
* Complex views (joins, aggregates) are often **read-only**.

---

## üîë Key Takeaways

1. The **relational model** is based on set theory and logic, replacing hierarchical/network models.
2. **Relation = table**, with tuples (rows), attributes (columns), and domains (valid values).
3. **Keys** (primary, foreign, candidate) enforce uniqueness and relationships.
4. **Integrity constraints** (entity, referential, general) ensure correctness.
5. **Views** allow flexibility, security, and abstraction but may not always be updatable.

