
# ðŸ“˜ Custom Implementations â†’ Class for LinkedList Node

---

## 1. Why You Need a LinkedList Node Class in JS

* Unlike Java/C++/Python, JavaScript **does not have a built-in LinkedList structure**.
* LeetCode frequently uses linked list problems (e.g. LC #21 Merge Two Sorted Lists, LC #206 Reverse Linked List, LC #141 Linked List Cycle).
* On LeetCode, linked lists are typically provided as **custom classes**, so itâ€™s useful to know how to **define your own** for practice, debugging, and custom testing.

---

## 2. Minimal LinkedList Node Definition

A singly linked list node contains:

* `val`: the value stored in the node.
* `next`: pointer (reference) to the next node, or `null` if end of list.

```js
class ListNode {
  constructor(val, next = null) {
    this.val = val;   // node value
    this.next = next; // pointer to next node
  }
}
```

---

## 3. Building Linked Lists (Helper Functions)

### ðŸ”¹ Convert Array â†’ Linked List

```js
function buildLinkedList(arr) {
  let dummy = new ListNode(0);
  let current = dummy;
  for (let val of arr) {
    current.next = new ListNode(val);
    current = current.next;
  }
  return dummy.next; // skip dummy head
}
```

### ðŸ”¹ Convert Linked List â†’ Array

```js
function listToArray(head) {
  let result = [];
  while (head) {
    result.push(head.val);
    head = head.next;
  }
  return result;
}
```

These helpers are invaluable for **unit testing your LeetCode solutions locally**.

---

## 4. Doubly Linked List Node (For Advanced Problems)

Some Interview problems (like LRU Cache, LC #146) need **fast removal + traversal**, so youâ€™ll need a **doubly linked list**:

```js
class DoublyListNode {
  constructor(val, prev = null, next = null) {
    this.val = val;
    this.prev = prev;
    this.next = next;
  }
}
```

---

## 5. Interview-Level Patterns with LinkedList Nodes

### âœ… Reverse a Linked List (LC #206)

```js
function reverseList(head) {
  let prev = null, curr = head;
  while (curr) {
    let nextTemp = curr.next;
    curr.next = prev;
    prev = curr;
    curr = nextTemp;
  }
  return prev;
}
```

### âœ… Detect Cycle (LC #141)

```js
function hasCycle(head) {
  let slow = head, fast = head;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) return true;
  }
  return false;
}
```

### âœ… Merge Two Sorted Lists (LC #21)

```js
function mergeTwoLists(l1, l2) {
  let dummy = new ListNode(0), curr = dummy;
  while (l1 && l2) {
    if (l1.val < l2.val) {
      curr.next = l1;
      l1 = l1.next;
    } else {
      curr.next = l2;
      l2 = l2.next;
    }
    curr = curr.next;
  }
  curr.next = l1 || l2;
  return dummy.next;
}
```

---

## 6. Interview-Level Gotchas & Insights

1. **References vs Values**

   * In JS, `head` is a reference. Modifying `head.next` mutates the original list.
   * Be cautious when reusing nodes across multiple lists.

2. **Dummy Head Trick**

   * Always use a dummy head node for easier edge case handling (empty lists, merges).

3. **Garbage Collection**

   * Unlike C/C++, you donâ€™t need to free nodes manually. Node.js GC reclaims unreachable nodes automatically.

4. **Testing & Debugging**

   * Use `listToArray()` to quickly verify intermediate states in debugging.

5. **Doubly List for Cache Problems**

   * Leetcode cache/queue problems (like **LRU Cache**) almost always require a **doubly linked list + hashmap** combo.

---

## 7. Time & Space Complexity

* **Node operations** (insert at head, delete, update pointer): **O(1)**.
* **Traversals** (print, convert to array): **O(n)**.
* **Memory overhead**: Each node stores `val + pointer(s)`.

---

## âœ… In Summary

* **`ListNode`** is the fundamental building block for linked list problems in Node.js.
* For most LeetCode problems, define:

  ```js
  class ListNode {
    constructor(val, next = null) {
      this.val = val;
      this.next = next;
    }
  }
  ```
* Write helper functions `buildLinkedList(arr)` and `listToArray(head)` to test your logic.
* Master these patterns: reverse list, cycle detection, merging lists, and dummy head usage.
* For advanced problems (LRU cache, deque), extend to **DoublyListNode**.

---



# âš¡ LinkedList Utility for Node.js (LeetCode Ready)

```javascript
// ===============================
// ðŸ“˜ LinkedList Utilities
// ===============================

// ðŸ”¹ Singly Linked List Node
class ListNode {
  constructor(val, next = null) {
    this.val = val;
    this.next = next;
  }
}

// ðŸ”¹ Doubly Linked List Node (for LRU/Deque problems)
class DoublyListNode {
  constructor(val, prev = null, next = null) {
    this.val = val;
    this.prev = prev;
    this.next = next;
  }
}

// ===============================
// ðŸ“Œ Helper Functions
// ===============================

// Build a linked list from array
function buildLinkedList(arr) {
  let dummy = new ListNode(0);
  let curr = dummy;
  for (let val of arr) {
    curr.next = new ListNode(val);
    curr = curr.next;
  }
  return dummy.next;
}

// Convert linked list to array
function listToArray(head) {
  let res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

// Print list (debugging)
function printList(head) {
  console.log(listToArray(head).join(" -> "));
}

// ===============================
// ðŸ”‘ Common Patterns
// ===============================

// Reverse Linked List (LC #206)
function reverseList(head) {
  let prev = null, curr = head;
  while (curr) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
}

// Detect Cycle (LC #141)
function hasCycle(head) {
  let slow = head, fast = head;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) return true;
  }
  return false;
}

// Merge Two Sorted Lists (LC #21)
function mergeTwoLists(l1, l2) {
  let dummy = new ListNode(0), curr = dummy;
  while (l1 && l2) {
    if (l1.val < l2.val) {
      curr.next = l1;
      l1 = l1.next;
    } else {
      curr.next = l2;
      l2 = l2.next;
    }
    curr = curr.next;
  }
  curr.next = l1 || l2;
  return dummy.next;
}

// ===============================
// âœ… Export (for modular use)
// ===============================
module.exports = {
  ListNode,
  DoublyListNode,
  buildLinkedList,
  listToArray,
  printList,
  reverseList,
  hasCycle,
  mergeTwoLists
};
```

---

## ðŸ”‘ Example Usage in LeetCode-style Testing

```javascript
const {
  buildLinkedList,
  listToArray,
  reverseList,
  mergeTwoLists,
  hasCycle,
  printList
} = require("./linkedlist-utils");

// Build list [1,2,3,4,5]
let head = buildLinkedList([1,2,3,4,5]);
printList(head); // 1 -> 2 -> 3 -> 4 -> 5

// Reverse list
let rev = reverseList(head);
printList(rev); // 5 -> 4 -> 3 -> 2 -> 1

// Merge two sorted lists
let l1 = buildLinkedList([1,3,5]);
let l2 = buildLinkedList([2,4,6]);
let merged = mergeTwoLists(l1, l2);
printList(merged); // 1 -> 2 -> 3 -> 4 -> 5 -> 6

// Detect cycle
let cycleHead = buildLinkedList([1,2,3]);
cycleHead.next.next.next = cycleHead.next; // create cycle
console.log(hasCycle(cycleHead)); // true
```

---

## âœ… Why This is Interview-Ready

* Covers **Singly & Doubly ListNode** (essential for LRU / cache problems).
* Provides **builder + converter helpers** for quick local testing.
* Implements **core linked list algorithms** (`reverse`, `merge`, `detectCycle`).
* Modular â†’ You can `require("./linkedlist-utils")` in your Node.js workspace.

---


# âš¡ Doubly LinkedList Utility (Node.js / LeetCode Ready)

```javascript
// ===============================
// ðŸ“˜ Doubly Linked List Utilities
// ===============================

class DoublyListNode {
  constructor(val, prev = null, next = null) {
    this.val = val;
    this.prev = prev;
    this.next = next;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = new DoublyListNode(null); // dummy head
    this.tail = new DoublyListNode(null); // dummy tail
    this.head.next = this.tail;
    this.tail.prev = this.head;
    this.size = 0;
  }

  // Insert at head (O(1))
  insertAtHead(node) {
    node.next = this.head.next;
    node.prev = this.head;
    this.head.next.prev = node;
    this.head.next = node;
    this.size++;
  }

  // Insert at tail (O(1))
  insertAtTail(node) {
    node.prev = this.tail.prev;
    node.next = this.tail;
    this.tail.prev.next = node;
    this.tail.prev = node;
    this.size++;
  }

  // Remove node (O(1))
  removeNode(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
    node.prev = null;
    node.next = null;
    this.size--;
  }

  // Remove from head (useful for dequeue, LRU eviction)
  removeFromHead() {
    if (this.head.next === this.tail) return null; // empty
    let node = this.head.next;
    this.removeNode(node);
    return node;
  }

  // Remove from tail (useful for LRU eviction)
  removeFromTail() {
    if (this.tail.prev === this.head) return null; // empty
    let node = this.tail.prev;
    this.removeNode(node);
    return node;
  }

  // Debug print (for testing)
  printList() {
    let res = [];
    let curr = this.head.next;
    while (curr !== this.tail) {
      res.push(curr.val);
      curr = curr.next;
    }
    console.log("DLL:", res.join(" <-> "));
  }
}

module.exports = { DoublyListNode, DoublyLinkedList };
```

---

## ðŸ”‘ Usage Examples

### âœ… Insert & Remove

```javascript
const { DoublyListNode, DoublyLinkedList } = require("./dll-utils");

let dll = new DoublyLinkedList();
let n1 = new DoublyListNode(1);
let n2 = new DoublyListNode(2);
let n3 = new DoublyListNode(3);

dll.insertAtHead(n1);
dll.insertAtTail(n2);
dll.insertAtTail(n3);

dll.printList(); // DLL: 1 <-> 2 <-> 3

dll.removeNode(n2);
dll.printList(); // DLL: 1 <-> 3
```

---

### âœ… LRU Cache Core Operations

* Insert new node at **head** when accessed.
* Remove from **tail** when evicting least recently used.

```javascript
// Insert new node
let n4 = new DoublyListNode(4);
dll.insertAtHead(n4);
dll.printList(); // DLL: 4 <-> 1 <-> 3

// Evict from tail
let evicted = dll.removeFromTail();
console.log("Evicted:", evicted.val); // Evicted: 3
dll.printList(); // DLL: 4 <-> 1
```

---

## âœ… Why This is Interview-Ready

* **Dummy head & tail** â†’ simplifies edge cases (no need to check null pointers).
* **O(1) insert/remove** at head, tail, or middle â†’ crucial for LRU Cache / deque.
* **Size tracking** â†’ supports capacity-based data structures.
* **Reusable** â†’ Can drop into any system design or LeetCode implementation.

---

## ðŸ§  Interview Insights

* **LRU Cache (#146)** â†’ implemented with **Map (for key â†’ node)** + **DoublyLinkedList (for order)**.
* **All O(1) Data Structures (#460 LFU Cache, #432 All O(1) DS)** â†’ build on top of this DLL foundation.
* **Deque problems** â†’ sliding window maximum (#239) can be implemented using a DLL-like deque.

