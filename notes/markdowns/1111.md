

# **Reactive Streams, Mono, and Flux**

---

## 🚀 Introduction to Reactive Programming in Spring

Traditional Spring MVC applications use a **thread-per-request** model, which can lead to thread blocking and poor scalability under high load. Spring WebFlux introduces **reactive programming** as a first-class citizen to build **non-blocking, asynchronous, and event-driven applications** using **Reactive Streams**.

It is particularly useful in:

* High-concurrency, I/O-bound systems (e.g., microservices)
* Streaming APIs (e.g., WebSocket, SSE)
* Low-latency APIs (e.g., trading platforms, chat apps)

---

## 🔄 What are Reactive Streams?

**Reactive Streams** is a **standard specification** (Java 9+ and part of Project Reactor in Spring) that defines a **non-blocking, backpressure-aware** asynchronous stream processing mechanism between:

* **Publisher** (emits data)
* **Subscriber** (consumes data)
* **Subscription** (controls flow)
* **Processor** (intermediary)

### 📜 Core Principles:

1. **Asynchronous & Non-blocking**: Data is pushed to consumers without blocking threads.
2. **Backpressure Support**: Subscribers can request how much data they are ready to consume.
3. **Lazy Evaluation**: Data is processed only when subscribed to.
4. **Stream Composition**: Reactive types can be composed using operators (`map`, `flatMap`, `zip`, etc.)

---

## 🌐 Reactive Frameworks in Spring

* **Project Reactor** – Core library behind Spring WebFlux
* **Mono** and **Flux** – Building blocks for reactive types
* **Netty** – Default non-blocking runtime (can use Undertow, Jetty)

---

## 🔷 Mono and Flux – The Reactive Types

| Type      | Description                 | Common Use                         |
| --------- | --------------------------- | ---------------------------------- |
| `Mono<T>` | Represents **0 or 1** item  | REST responses, optional lookups   |
| `Flux<T>` | Represents **0 to N** items | Collections, streaming, WebSockets |

---

### 🧱 Mono – A Single Result (like `Optional` or `CompletableFuture`)

```java
Mono<String> monoHello = Mono.just("Hello");
```

📌 Can emit:

* **`onNext`** with value
* **`onError`** with exception
* **`onComplete`** when done

Example:

```java
Mono.just("Spring")
    .map(String::toUpperCase)
    .subscribe(System.out::println); // Output: SPRING
```

---

### 🔁 Flux – A Sequence of Results (like `Stream` or `List`)

```java
Flux<String> fluxNames = Flux.just("Alice", "Bob", "Charlie");
```

Flux can emit:

* 0 to N `onNext` events
* Then `onComplete` or `onError`

Example:

```java
Flux.range(1, 5)
    .map(i -> "Number: " + i)
    .subscribe(System.out::println);
```

---

## ⚙️ Operators in Mono & Flux

| Operator    | Purpose                    | Example                                 |
| ----------- | -------------------------- | --------------------------------------- |
| `map()`     | Transform values           | `.map(String::toUpperCase)`             |
| `flatMap()` | Async transform            | `.flatMap(repo::findById)`              |
| `filter()`  | Filter items               | `.filter(name -> name.startsWith("A"))` |
| `zip()`     | Combine publishers         | `Flux.zip(flux1, flux2)`                |
| `then()`    | Trigger action on complete | `.then(Mono.just("Done"))`              |
| `retry()`   | Retry on error             | `.retry(3)`                             |

---

## 🔄 Backpressure: Controlling the Flow

**Backpressure** lets a `Subscriber` tell the `Publisher` how many items it can handle at a time to **prevent memory overload**.

Example:

```java
flux.subscribe(new BaseSubscriber<Integer>() {
    protected void hookOnSubscribe(Subscription subscription) {
        request(1); // backpressure: request 1 item
    }

    protected void hookOnNext(Integer value) {
        System.out.println("Received: " + value);
        request(1); // ask for next
    }
});
```

---

## 📦 Spring WebFlux Controller with Mono/Flux

```java
@RestController
public class UserController {

    @GetMapping("/users")
    public Flux<User> getAllUsers() {
        return userRepository.findAll(); // returns Flux<User>
    }

    @GetMapping("/users/{id}")
    public Mono<ResponseEntity<User>> getUserById(@PathVariable String id) {
        return userRepository.findById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}
```

---

## 🧪 Testing with StepVerifier (Project Reactor Test)

```java
StepVerifier.create(Mono.just("Spring"))
    .expectNext("Spring")
    .expectComplete()
    .verify();
```

---

## 🧠 Enterprise-level Takeaways

| Insight                                                                                  | Impact                                    |
| ---------------------------------------------------------------------------------------- | ----------------------------------------- |
| Reactive programming improves **resource utilization** under heavy I/O                   | ⚡ Handles 10x more concurrent connections |
| `Mono`/`Flux` replaces traditional `Future`/`List` with **lazy, async, streamable APIs** | 🧩 Clean APIs with backpressure           |
| Integrated with **WebClient**, Mongo, Kafka, R2DBC                                       | 🧠 End-to-end reactive stack              |
| Reactor context provides **thread-safe contextual data**                                 | 🛡️ Good for tracing, logging             |
| Error handling (`onErrorResume`, `onErrorMap`) must be **explicitly chained**            | 🪓 Failure recovery planning is critical  |

---

## 🔐 Common  Interview Questions

1. **What is the difference between `Mono`, `Flux`, and traditional `Future`?**
2. **How does backpressure work in Reactor?**
3. **Can you explain lazy vs eager in reactive programming?**
4. **When would you prefer reactive over imperative Spring MVC?**
5. **Design a non-blocking reactive API to stream data from a database continuously.**

---

## ✅ Summary

| Concept            | Description                                           |
| ------------------ | ----------------------------------------------------- |
| `Reactive Streams` | Specification for async, non-blocking data processing |
| `Mono<T>`          | Emits 0 or 1 element                                  |
| `Flux<T>`          | Emits 0 to N elements                                 |
| `Backpressure`     | Control flow from subscriber to prevent overload      |
| `Project Reactor`  | Reactive library powering Spring WebFlux              |


---

### 🔑 Answer to the Common Interview Questions (Given above)



### 🔐 **1. What is the difference between Mono, Flux, and traditional Future?**

| Feature              | `Mono`                                    | `Flux`                   | `Future` (Java 8)               |
| -------------------- | ----------------------------------------- | ------------------------ | ------------------------------- |
| Type                 | Reactive (0–1 items)                      | Reactive (0–N items)     | Imperative (1 item)             |
| Laziness             | ✅ Yes                                     | ✅ Yes                    | ❌ No (executes immediately)     |
| Non-blocking         | ✅ Yes                                     | ✅ Yes                    | ❌ No (`get()` blocks)           |
| Backpressure support | ✅ Yes                                     | ✅ Yes                    | ❌ No                            |
| Error handling       | Built-in with operators (`onErrorResume`) | Same                     | Limited (`try-catch`)           |
| Chaining             | Declarative & composable                  | Declarative & composable | Verbose (`thenApply`, `handle`) |
| Use case             | Fetch single object (e.g., by ID)         | Fetch stream or list     | Simple async tasks              |

**Example:**

```java
Mono<User> userMono = userRepository.findById("123"); // Reactive, non-blocking

Flux<User> allUsers = userRepository.findAll(); // Reactive stream of users

Future<User> userFuture = executor.submit(() -> getUser()); // Imperative, blocking
```

> 🔥 **Insight:** Mono and Flux are **lazy, event-driven**, and **chainable**, while `Future` is **eager and blocking** — making Mono/Flux more suitable for scalable microservices and reactive architectures.

---

### 🔐 **2. How does backpressure work in Reactor?**

**Backpressure** is a strategy in reactive streams that allows **consumers (Subscribers)** to signal how much data they are ready to process, thus preventing overload and **OutOfMemoryErrors**.

### 🔄 How it works:

* The **Subscriber** sends a `request(n)` to the **Publisher**
* The **Publisher** emits **only `n` items** until more are requested
* It enables **non-blocking flow control**

**Custom backpressure example:**

```java
flux.subscribe(new BaseSubscriber<Integer>() {
    protected void hookOnSubscribe(Subscription subscription) {
        request(1); // backpressure: request 1 item at a time
    }

    protected void hookOnNext(Integer value) {
        process(value);
        request(1); // only ask for next after processing
    }
});
```

> 🧠 **In enterprise-scale systems**, this prevents buffer overflow when dealing with high-throughput event streams like Kafka or WebSockets.

---

### 🔐 **3. Can you explain lazy vs eager in reactive programming?**

| Term                        | Lazy Evaluation                                      | Eager Evaluation                              |
| --------------------------- | ---------------------------------------------------- | --------------------------------------------- |
| When does execution happen? | Only when subscribed                                 | As soon as called                             |
| Resource usage              | Efficient, only used if needed                       | May waste computation                         |
| Reactive types              | `Mono`, `Flux`                                       | Java Streams (partial), Future                |
| Operator behavior           | Chained ops are **not executed** until `subscribe()` | Executed immediately in many imperative cases |

**Example:**

```java
Mono<String> lazyMono = Mono.fromSupplier(() -> {
    System.out.println("Generating...");
    return "Hello";
});
// Nothing happens until:
lazyMono.subscribe(System.out::println); // Triggers execution
```

> ⚠️ **Lazy** makes reactive programming composable and optimizable — especially important for efficient resource use in distributed systems.

---

### 🔐 **4. When would you prefer reactive over imperative Spring MVC?**

✅ **Choose Reactive (WebFlux)** when:

* You have **high-concurrency** or **I/O-bound workloads**
* You're working with **streaming data**, **WebSockets**, or **SSE**
* You need **non-blocking integration** with downstream systems (e.g., Kafka, NoSQL, HTTP APIs)
* You aim for **resource-efficient scalability**

❌ Avoid Reactive if:

* You’re working with **blocking APIs** (e.g., JDBC)
* The application is **simple and CPU-bound**
* Your team is not trained in **reactive programming paradigms**

> 🎯 **Enterprise Principle:** Use reactive when your bottlenecks are I/O — it scales better with fewer threads (e.g., Netty instead of Tomcat).

---

### 🔐 **5. Design a non-blocking reactive API to stream data from a database continuously**

**🧩 Problem:**
Design an API that streams data **as it becomes available**, e.g., live transactions or logs from DB.

---

### ✅ Solution: Spring WebFlux + R2DBC + Flux + `SSE`

#### ⚙️ Tools:

* `Flux<T>` to stream results
* `R2DBC` for reactive DB access (non-blocking)
* `SseEmitter` or `produces = MediaType.TEXT_EVENT_STREAM_VALUE`

#### 📄 Code Example:

```java
@RestController
@RequiredArgsConstructor
public class LogStreamController {

    private final ReactiveLogRepository logRepository;

    @GetMapping(value = "/logs/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<LogEntry> streamLogs() {
        return logRepository.findLogsInRealTime(); // Returns Flux<LogEntry>
    }
}
```

#### 💾 Reactive Repository:

```java
public interface ReactiveLogRepository extends ReactiveCrudRepository<LogEntry, String> {
    
    @Query("SELECT * FROM logs WHERE timestamp > now() - interval '10 seconds'")
    Flux<LogEntry> findLogsInRealTime();
}
```

> 🔥 This creates a **hot stream**, efficiently serving logs as they're written to DB — great for observability dashboards or live alerts.

---

### 🧠 Bonus: Scaling Considerations

| Area               | Design                                               |
| ------------------ | ---------------------------------------------------- |
| **Backpressure**   | Use `.limitRate(n)` or `.onBackpressureBuffer()`     |
| **Error handling** | `.onErrorResume()` with fallbacks                    |
| **Security**       | JWT or OAuth2 gating                                 |
| **Observability**  | Use **Reactor context** + Micrometer + Zipkin/Sleuth |
| **Database**       | Use **R2DBC** not JPA for non-blocking access        |



