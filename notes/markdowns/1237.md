
# ðŸ”· Factorial of N â€“ All Approaches

---

## 1. Problem Statement
Given an integer `N`, compute its factorial:

\[
N! = N \times (N-1) \times (N-2) \times \dots \times 1
\]

Example:  
- Input: `N = 5`  
- Output: `120`  
(Because 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120)

---

## 2. Approaches

---

### âœ… Approach 1: Iterative (Loop)
The most straightforward solution is to multiply numbers in a loop.

```java
long factorialIterative(int n) {
    long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

- **Time Complexity**: O(N)  
- **Space Complexity**: O(1)  
- **Pros**: Safe from stack overflow, efficient.  
- **Cons**: Verbose compared to formula-based problems (but factorial has no closed form).  

---

### âœ… Approach 2: Recursive (Basic Recursion)
Direct definition of factorial.

```java
long factorialRecursive(int n) {
    if (n == 0 || n == 1) return 1;  // base case
    return n * factorialRecursive(n - 1);
}
```

- **Time Complexity**: O(N)  
- **Space Complexity**: O(N) (due to recursion stack)  
- **Pros**: Elegant, mirrors mathematical definition.  
- **Cons**: StackOverflowError for large `n` (e.g., >10^5).  

---

### âœ… Approach 3: Tail Recursion
Pass along an accumulator to eliminate pending multiplications.

```java
long factorialTail(int n, long acc) {
    if (n == 0 || n == 1) return acc;
    return factorialTail(n - 1, acc * n);
}

// Call: factorialTail(5, 1) â†’ 120
```

- **Time Complexity**: O(N)  
- **Space Complexity**:  
  - With **TCO (Tail Call Optimization)** â†’ O(1)  
  - Without TCO (Java/Python) â†’ O(N) stack  
- **Pros**: Optimizable in functional languages.  
- **Cons**: Java doesnâ€™t support TCO, so still stack heavy.  

---

### âœ… Approach 4: Functional Programming (Streams / Reduce)
Modern Java 8+ style using streams.

```java
import java.util.stream.LongStream;

long factorialStream(int n) {
    return LongStream.rangeClosed(1, n)
                     .reduce(1, (a, b) -> a * b);
}
```

- **Time Complexity**: O(N)  
- **Space Complexity**: O(1)  
- **Pros**: Concise, declarative style.  
- **Cons**: Slight overhead from streams; not better than iteration in performance.  

---

### âœ… Approach 5: Memoization (Top-Down DP)
Cache intermediate results to avoid recomputation across multiple queries.

```java
import java.util.HashMap;

class FactorialMemo {
    static HashMap<Integer, Long> cache = new HashMap<>();

    static long factorial(int n) {
        if (n == 0 || n == 1) return 1;
        if (cache.containsKey(n)) return cache.get(n);
        long result = n * factorial(n - 1);
        cache.put(n, result);
        return result;
    }
}
```

- **Time Complexity**: O(N)  
- **Space Complexity**: O(N) for cache + stack  
- **Pros**: Useful when factorial is queried multiple times.  
- **Cons**: Overkill for a single computation.  

---

### âœ… Approach 6: Bottom-Up Dynamic Programming
Build factorial iteratively while storing intermediate results.

```java
long[] factorialDP(int n) {
    long[] dp = new long[n + 1];
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        dp[i] = dp[i - 1] * i;
    }
    return dp;  // dp[n] is factorial(n)
}
```

- **Time Complexity**: O(N)  
- **Space Complexity**: O(N)  
- **Pros**: Useful when multiple factorial queries are needed.  
- **Cons**: Extra memory usage.  

---

### âœ… Approach 7: BigInteger (Handling Large N)
For very large `N`, factorial exceeds `long`. Use `BigInteger`.

```java
import java.math.BigInteger;

BigInteger factorialBig(int n) {
    BigInteger result = BigInteger.ONE;
    for (int i = 2; i <= n; i++) {
        result = result.multiply(BigInteger.valueOf(i));
    }
    return result;
}
```

- **Time Complexity**: O(N Ã— M)  
  (M = cost of multiplying big integers, grows with digits)  
- **Space Complexity**: Depends on size of result (~ O(N log N) digits)  
- **Pros**: Handles extremely large factorials (e.g., 1000!).  
- **Cons**: Slower due to arbitrary-precision arithmetic.  

---

### âœ… Approach 8: Approximation (Stirlingâ€™s Formula)
When exact values arenâ€™t required (e.g., probability calculations).

\[
n! \approx \sqrt{2 \pi n}\left(\frac{n}{e}\right)^n
\]

- **Time Complexity**: O(1)  
- **Space Complexity**: O(1)  
- **Pros**: Works for very large `N` without overflow.  
- **Cons**: Approximate only.  

---

## 3. Complexity & Comparison

| Approach              | Time     | Space    | Notes |
|-----------------------|----------|----------|-------|
| Iterative Loop        | O(N)    | O(1)     | Most practical, safe |
| Basic Recursion       | O(N)    | O(N)     | Elegant, but stack risk |
| Tail Recursion        | O(N)    | O(1) if TCO, else O(N) | Great in FP languages |
| Streams / Reduce      | O(N)    | O(1)     | Modern, concise |
| Memoization (Top-Down)| O(N)    | O(N)     | Useful across multiple queries |
| DP (Bottom-Up)        | O(N)    | O(N)     | Precompute for range queries |
| BigInteger            | O(NÂ·M)  | O(M)     | Handles huge values (e.g., 1000!) |
| Stirlingâ€™s Approx     | O(1)    | O(1)     | Approximation for large N |

---

## 4. Interview Insights

- **Warm-up Q**: Write recursive factorial.  
- **Follow-up Q**: Avoid stack overflow â†’ suggest iterative / tail recursion.  
- **Advanced Q**: Compute factorial of very large numbers â†’ use `BigInteger`.  
- **Math Q**: Approximate factorial â†’ Stirlingâ€™s formula.  
- **Optimization Q**: Multiple queries â†’ precompute with DP.  
- **System Q**: What happens if N=10^6? â†’ Discuss stack overflow, overflow in int/long, BigIntegerâ€™s cost.  

ðŸ‘‰ Strong candidates donâ€™t just code â€” they discuss **time, space, overflow, and language-specific limitations**.  

---

## ðŸ”‘ Summary

- **Iteration (O(N), O(1))** â†’ Best practical approach.  
- **Recursion (O(N), O(N))** â†’ Elegant but unsafe for large N.  
- **Tail Recursion** â†’ Safe in FP languages with TCO.  
- **BigInteger** â†’ Required for large factorials.  
- **Stirlingâ€™s Formula** â†’ Approximation for large N.  
- **DP/Memoization** â†’ Useful for repeated factorial queries.  

