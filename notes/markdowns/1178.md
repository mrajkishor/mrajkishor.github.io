Here’s a list of **commonly asked interview questions** for the topics you listed under **"Objects and Prototypes"** in JavaScript:

---

### ==**Creating & Accessing Objects**==



## 1) What are the different ways to create an object in JavaScript?

**Most common:**

* **Object literal**

  ```js
  const user = { id: 1, name: "Ada" };
  ```
* **Constructor function + `new`**

  ```js
  function Person(name) { this.name = name; }
  const p = new Person("Ada");
  ```
* **ES6 `class` + `new`** (sugar over prototypes)

  ```js
  class Person { constructor(name) { this.name = name; } }
  const p = new Person("Ada");
  ```
* **`Object.create(proto, [descriptors])`** (control the prototype directly)

  ```js
  const dict = Object.create(null);           // no prototype (safe “dictionary”)
  const child = Object.create(parentProto);   // pure prototypal inheritance
  ```
* **From key–value pairs: `Object.fromEntries`**

  ```js
  const obj = Object.fromEntries([["a", 1], ["b", 2]]);
  ```

**Less common but useful:**

* **`new Object()`** (equivalent to `{}`, rarely preferred)
* **Cloning/merging to create:**

  ```js
  const clone = { ...source };               // shallow
  const merged = Object.assign({}, a, b);    // shallow
  ```

**Why `Object.create(null)` matters:** it avoids inherited keys like `toString`, minimizing prototype-pollution issues for “map/dictionary”-like uses.

---

## 2) How do you access object properties? Dot vs bracket notation.

* **Dot notation** (simple, static identifiers only):

  ```js
  obj.name
  ```

  Works when the key is a **valid identifier** (no spaces, no hyphens, doesn’t start with a number).

* **Bracket notation** (dynamic and more flexible):

  ```js
  const key = getField();         // dynamic
  obj[key];
  obj["first-name"];              // special characters / spaces
  obj[1];                         // numeric key (actually a string "1")
  const SECRET = Symbol("s");
  obj[SECRET];                    // Symbols must use brackets
  ```

**Lookups & fallbacks:**

* Missing property ⇒ `undefined` (unless found on the prototype chain).
* Safe access:

  ```js
  const city = user.address?.city ?? "Unknown"; // optional chaining + nullish coalescing
  ```
* Existence checks:

  ```js
  "name" in obj           // checks own + prototype
  obj.hasOwnProperty("x") // own only
  Object.hasOwn(obj, "x") // safer modern alternative to hasOwnProperty
  ```

---

## 3) How would you create an object with a dynamic property name?

**Computed property names in object literals:**

```js
const field = "score";
const obj = {
  id: 1,
  [field]: 100,      // -> { id: 1, score: 100 }
};
```

**Assign after creation:**

```js
const obj = {};
const k = Math.random() > 0.5 ? "a" : "b";
obj[k] = 42;
```

**Using Symbols as dynamic, non-colliding keys:**

```js
const ID = Symbol("id");
const obj = { [ID]: 123 };
```

---

## 4) What happens if you access a property that doesn’t exist on an object?

* You get **`undefined`** if the property isn’t on the object **or anywhere on its prototype chain**.

  ```js
  const o = {};
  o.missing; // undefined
  ```

* If the key exists on the **prototype**, you’ll get that value:

  ```js
  const proto = { x: 1 };
  const o = Object.create(proto);
  o.x; // 1 (inherited)
  ```

* **Pitfalls:**

  * Accessing deeper paths can throw if an intermediate is `null`/`undefined`. Use `?.`:

    ```js
    user.address?.city // undefined (safe) instead of TypeError
    ```
  * Distinguish **“missing”** from **“present but value is undefined”**:

    ```js
    "x" in obj          // true if present (own or inherited), even if value is undefined
    Object.hasOwn(obj, "x"); // own only
    ```

---

## 5) How can you clone an object? Compare shallow vs deep cloning.

### Shallow clone

Copies **only one level**; nested objects are **shared references**.

* **Spread** (own, enumerable props; copies symbol keys too):

  ```js
  const copy = { ...source };
  ```
* **`Object.assign`** (own, enumerable props; strings & symbols):

  ```js
  const copy = Object.assign({}, source);
  ```
* **Arrays**:

  ```js
  const copyArr = [...arr]; // or arr.slice()
  ```

**Caveat:** getters are **invoked** as values are read; result becomes a plain data property on the target. **Property descriptors**, **prototype**, and **non-enumerable** props are **not preserved** by spread/assign.

### Deep clone

Recursively copies nested structures so mutations don’t affect the original.

**Practical options:**

* **`structuredClone(value)`** (modern browsers/Node 17+):

  * Handles cycles and many built-ins (**Map, Set, Date, RegExp, ArrayBuffer, TypedArrays**, etc.).
  * **Does not clone functions**, DOM nodes, or certain exotic objects; will throw a `DataCloneError`.
  * Does **not** preserve custom property descriptors; focuses on the data graph.

  ```js
  const deep = structuredClone(original);
  ```
* **`JSON.parse(JSON.stringify(obj))`** (legacy workaround; many gotchas):

  * Loses functions, `undefined`, `Symbol` keys.
  * Dates become strings; `NaN`/`Infinity` become `null`.
  * Drops non-enumerable props; no cycles.
* **Library** (e.g., `lodash.cloneDeep`)—battle-tested, customizable.
* **Custom deep clone** (to preserve **prototype** + **descriptors**):

  ```js
  function deepCloneWithProto(src, seen = new Map()) {
    if (typeof src !== "object" || src === null) return src;
    if (seen.has(src)) return seen.get(src);

    const clone = Array.isArray(src)
      ? []
      : Object.create(Object.getPrototypeOf(src),
          Object.getOwnPropertyDescriptors(src));

    seen.set(src, clone);

    for (const key of Reflect.ownKeys(src)) {
      const desc = Object.getOwnPropertyDescriptor(src, key);
      if (!desc) continue;

      // Rewrap accessors as-is (don’t invoke getters)
      if ("get" in desc || "set" in desc) {
        Object.defineProperty(clone, key, desc);
      } else {
        Object.defineProperty(clone, key, {
          ...desc,
          value: deepCloneWithProto(desc.value, seen),
        });
      }
    }
    return clone;
  }
  ```

  This approach:

  * Preserves **prototype chain**.
  * Preserves **property descriptors** (writable/configurable/enumerable, getters/setters).
  * Handles **circular references** via `seen`.

**Choosing the right tool:**

* **Pure data** (no functions/DOM, want reliability & cycles): `structuredClone`.
* **Need descriptors/prototypes preserved**: custom deep clone (like above).
* **Quick & simple** (no nested mutation concerns): spread / `Object.assign` (shallow).
* **Legacy or constrained envs**: lodash’s `cloneDeep`.

**Quick demo of shallow vs deep:**

```js
const src = { a: { n: 1 } };

const shallow = { ...src };
shallow.a.n = 2;
console.log(src.a.n); // 2  (shared reference)

const deep = structuredClone(src);
deep.a.n = 3;
console.log(src.a.n); // 2  (independent)
```

---

If you want, I can continue with **Property Descriptors & `defineProperty`** next (with code illustrating `writable/enumerable/configurable`, getters/setters, and iteration effects), or bundle everything into a printable cheat sheet.


---

### **Property Descriptors & `defineProperty`**

6. What is a property descriptor in JavaScript?
7. What is the difference between `writable`, `enumerable`, and `configurable` in property descriptors?
8. How does `Object.defineProperty()` work? Give an example.
9. Can you make a property read-only or non-enumerable? How?
10. How do `get` and `set` accessors work in `defineProperty`?

---

### **Prototype Chain & Inheritance**

11. What is the prototype chain in JavaScript?
12. How does JavaScript perform property lookup using the prototype chain?
13. How is prototypal inheritance different from classical inheritance?
14. How do you implement inheritance using prototypes?
15. What is the role of `__proto__` and how is it different from `prototype`?

---

### **`Object.create` vs Class Syntax**

16. How does `Object.create()` work?
17. When would you prefer `Object.create()` over class syntax?
18. What’s the difference between constructor functions and ES6 classes?
19. Can classes be used for prototypal inheritance? How?
20. Is class syntax just syntactic sugar over prototypes? Explain.

---

### **Mixins**

21. What is a mixin pattern in JavaScript?
22. How do you implement a mixin?
23. What are some use cases for mixins?
24. How do mixins differ from multiple inheritance?
25. Are there any drawbacks of using mixins?

---

### **Object Utilities (`assign`, `keys`, `values`, `entries`)**

26. How does `Object.assign()` work? Does it do deep cloning?
27. What is the difference between `Object.keys()`, `Object.values()`, and `Object.entries()`?
28. How would you convert an object to an array of key-value pairs and back?
29. What’s the difference between `for...in` and `Object.keys()`?
30. Are the order of keys guaranteed in `Object.keys()`?

---

### **`freeze`, `seal`, `preventExtensions`**

31. What’s the difference between `Object.freeze()`, `Object.seal()`, and `Object.preventExtensions()`?
32. Can you unfreeze a frozen object?
33. How do you check if an object is frozen or sealed?
34. What happens when you try to add a new property to a sealed object?
35. Does `Object.freeze()` apply to nested objects?

---

### **`getPrototypeOf` vs `setPrototypeOf`**

36. What does `Object.getPrototypeOf()` return?
37. How does `Object.setPrototypeOf()` work, and why is it discouraged in performance-critical code?
38. How do you change the prototype of an object after creation?
39. Can you set `null` as an object’s prototype? Why would you do that?
40. What is the difference between `obj.__proto__` and `Object.getPrototypeOf(obj)`?


