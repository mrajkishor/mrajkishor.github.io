

# Data Structures via JS Objects → `Set` & `Map`

---

## 1. Why `Set` and `Map` Matter in LeetCode

* **Sets**: Efficiently track **uniqueness, membership, and deduplication**.
* **Maps**: Store **key–value associations** with **any type of key**, unlike objects (`{}`) that only use string/symbol keys.

👉 Both are implemented as **hash tables** internally (O(1) average for insert, lookup, delete).

---

## 2. `Set` in JavaScript

### 🔹 Basics

```js
let s = new Set([1, 2, 3]);
s.add(4);
console.log(s.has(2)); // true
s.delete(1);
console.log([...s]);   // [2,3,4]
```

### 🔑 Properties

* **Unique values only** (auto-deduplication).
* Keys & values are the same.
* Iteration order = insertion order.

### 🔹 Time Complexities

* Insert: **O(1)** average.
* Lookup: **O(1)** average.
* Delete: **O(1)** average.

### 📌  Use Cases

* **Contains check** (Two Sum, Subarray problems):

  ```js
  let seen = new Set();
  for (let num of nums) {
    if (seen.has(target - num)) return true;
    seen.add(num);
  }
  ```
* **Remove duplicates**:

  ```js
  let unique = [...new Set(nums)];
  ```
* **Sliding window uniqueness** (Longest Substring Without Repeating Characters).

---

## 3. `Map` in JavaScript

### 🔹 Basics

```js
let m = new Map();
m.set("a", 1);
m.set(42, "answer");
m.set({ id: 1 }, "objectKey");

console.log(m.get("a")); // 1
console.log(m.has(42));  // true
m.delete("a");
```

### 🔑 Properties

* Keys can be **any type** (string, number, object, array, function).
* Preserves **insertion order** when iterating.
* `Map.size` gives entry count.

### 🔹 Time Complexities

* Insert: **O(1)** average.
* Lookup: **O(1)** average.
* Delete: **O(1)** average.

### 📌  Use Cases

* **Index maps** (Two Sum with indices):

  ```js
  let map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) return [map.get(target - nums[i]), i];
    map.set(nums[i], i);
  }
  ```
* **Frequency maps**:

  ```js
  let freq = new Map();
  for (let ch of s) freq.set(ch, (freq.get(ch) || 0) + 1);
  ```
* **Graph adjacency lists**:

  ```js
  let graph = new Map();
  graph.set(1, [2,3]);
  graph.set(2, [4]);
  ```

---

## 4. `Object` vs `Map` vs `Set`

| Feature             | Object `{}`               | Map                      | Set                     |
| ------------------- | ------------------------- | ------------------------ | ----------------------- |
| Key types           | String / Symbol           | Any type                 | Values only             |
| Maintains order?    | ES6+ insertion order      | Yes                      | Yes                     |
| Iteration           | `for..in`, `Object.keys`  | `for..of`, `.entries()`  | `for..of`               |
| Size                | Must compute manually     | `.size` property         | `.size` property        |
| Performance (large) | Good, but slower than Map | Faster for 100k+ entries | Fast lookups            |
| Leetcode Use           | Small hash maps           | Complex key mapping      | Membership & uniqueness |

👉 Rule of thumb for LeetCode:

* Use **`Set`** → uniqueness checks, duplicates, sliding windows.
* Use **`Map`** → frequency counters, index lookups, adjacency lists.
* Use **`Object`** → small frequency maps (strings/numbers only) if you want brevity.

---

## 5. Gotchas

1. **Object Coercion in `{}` but not in `Map`**

   ```js
   let obj = {};
   obj[1] = "x";
   console.log(obj["1"]); // "x" (coerced)

   let map = new Map();
   map.set(1, "x");
   console.log(map.get("1")); // undefined ✅
   ```

2. **Duplicate keys in `Map`**

   * Setting the same key overwrites the value, not adds new.

3. **Set does not allow indexing**

   ```js
   let s = new Set([1,2,3]);
   console.log(s[0]); // undefined
   ```

   Must spread (`[...s]`) or iterate.

4. **Performance**

   * `Map` is generally **faster** than `{}` for large datasets.
   * `Set` is faster than `Array.includes()` for large membership checks.

---

## 6. Typical LeetCode Patterns

* **Longest Substring Without Repeating Characters** (Sliding Window + `Set`).
* **Two Sum / Index Problems** (O(n) solution with `Map`).
* **Group Anagrams** (Hash key → list of words using `Map`).
* **Course Schedule / Graph problems** (Adjacency list with `Map`).
* **Remove Duplicates from Array** (Deduplicate with `Set`).

---

## ✅ In Summary

* **Set** = store unique values, check membership in O(1).
* **Map** = key–value store with keys of any type, O(1) operations.
* Both are **hash table–based** and crucial for **frequency counting, indexing, and uniqueness checks**.
* For  interviews, know **when to prefer `Set`/`Map` over Object/Array**:

  * **`Set`** → uniqueness problems.
  * **`Map`** → frequency, adjacency, index lookups.
  * **Object** → small/simple string key–value maps.

---



# ⚡ Set & Map Cheat Sheet (LeetCode)

---

## 🔹 Use **`Set`** When:

👉 You need **uniqueness** or **membership checks**.

| Problem Type                              | Example LeetCode                                                       | Why `Set`?                                                    |
| ----------------------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------- |
| **Remove Duplicates**                     | LC #26 Remove Duplicates from Sorted Array, LC #217 Contains Duplicate | `Set` auto-dedupes, membership check in O(1).                 |
| **Sliding Window Uniqueness**             | LC #3 Longest Substring Without Repeating Characters                   | Track unique chars in current window. Add/remove in O(1).     |
| **Union / Intersection of Arrays**        | LC #349 Intersection of Two Arrays                                     | Convert to `Set` for O(1) lookups, then compute intersection. |
| **Seen Elements / Visited States**        | LC #202 Happy Number, BFS/DFS graph traversal                          | Prevent cycles/duplicates with `.has()` checks.               |
| **Check Completeness / Missing Elements** | LC #268 Missing Number                                                 | Add all nums into `Set`, check missing in O(1).               |

---

## 🔹 Use **`Map`** When:

👉 You need **frequency counts, indices, or key → value association**.

| Problem Type                          | Example LeetCode                             | Why `Map`?                                               |
| ------------------------------------- | -------------------------------------------- | -------------------------------------------------------- |
| **Two Sum (Index Map)**               | LC #1 Two Sum                                | Store `num → index` for O(1) complement lookup.          |
| **Frequency Counter**                 | LC #242 Valid Anagram, LC #383 Ransom Note   | Count chars with `.get()` + `.set()`.                    |
| **Top K / Sorting by Frequency**      | LC #347 Top K Frequent Elements              | Count with `Map`, then sort entries.                     |
| **Group Anagrams**                    | LC #49 Group Anagrams                        | Canonical sorted string → list of words.                 |
| **Graph Problems**                    | LC #207 Course Schedule, LC #133 Clone Graph | Build adjacency list with `Map(node → neighbors)`.       |
| **Dynamic Programming (Memoization)** | LC #70 Climbing Stairs, LC #139 Word Break   | Store state → result mappings for O(1) lookups.          |
| **LRU Cache / State Mapping**         | LC #146 LRU Cache                            | Efficient key → value tracking with `.get()` + `.set()`. |

---

## 🔹 Combined Usage (Set + Map)

Some problems benefit from **both**:

| Problem Type                   | Example LeetCode                                 | How Both Work                                                      |
| ------------------------------ | ------------------------------------------------ | ------------------------------------------------------------------ |
| **Word Pattern / Isomorphism** | LC #290 Word Pattern, LC #205 Isomorphic Strings | `Map` for char→word mapping, `Set` for uniqueness of mapped words. |
| **Graph Traversal**            | LC #133 Clone Graph                              | `Map` for node → clone mapping, `Set` for visited nodes.           |
| **Backtracking**               | LC #212 Word Search II                           | `Map` for Trie structure, `Set` for visited cells.                 |

---

## 🔹 Performance Comparison

| Operation | `Set`   | `Map`   | `Object {}`                  | `Array`     |
| --------- | ------- | ------- | ---------------------------- | ----------- |
| Insert    | O(1)    | O(1)    | O(1)                         | O(1) (push) |
| Lookup    | O(1)    | O(1)    | O(1)                         | O(n)        |
| Delete    | O(1)    | O(1)    | O(1)                         | O(n)        |
| Iteration | Ordered | Ordered | Keys only, unordered pre-ES6 | Sequential  |

---

## ✅ Quick Rules of Thumb

* Use **`Set`** when the key is the **value itself**.
* Use **`Map`** when you need to associate **key → value**.
* Use **both** for **bijection/isomorphism problems** (pattern ↔ word, graph ↔ clone).

---

## 🎯 Memory Hack for LeetCode

* For **small constraints (≤10⁴)**, `{}` object often suffices.
* For **larger constraints (≥10⁵, graph problems, complex keys)** → prefer `Map`/`Set`.
* Always remember:

  * `new Set(nums)` dedupes an array in one line.
  * `Map` is faster than `{}` for huge datasets (100k+ entries).

