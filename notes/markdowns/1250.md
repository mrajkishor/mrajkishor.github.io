
# Arrays → map, filter, reduce, sort, splice

---

## 1. Why Arrays Matter in LeetCode  

Arrays are the **most common input/output structure** in algorithmic problems.  

- Inputs are often space-separated integers → parsed into arrays.  
- Many interview questions (e.g., **Two Sum, Sliding Window, Subarrays, Sorting, DP**) rely on efficient array usage.  
- Node.js provides **high-order methods (`map`, `filter`, `reduce`)** that make transformations concise, but in **large inputs (10⁵–10⁶)**, careless use can cause TLE or memory blowups.  

---

## 2. Node.js Array Essentials  

### 2.1 Array Creation  
```js
let arr = [1, 2, 3];
let empty = new Array(5); // [ , , , , ]
let filled = Array(5).fill(0); // [0,0,0,0,0]
```

👉 `Array(n)` creates sparse arrays (uninitialized). Always `fill()` before using `.map()` to avoid `undefined`.  

---

## 3. Core Methods 

### 🔹 **1. `map()`**
Transforms each element → returns a **new array**.  

```js
const arr = [1, 2, 3];
const squared = arr.map(x => x * x); // [1, 4, 9]
```

- **Time Complexity**: `O(n)`  
- **Space Complexity**: `O(n)`  

####  Use Cases:
- Transform input quickly → e.g., parsing strings to numbers:
  ```js
  const nums = "1 2 3".split(" ").map(Number); // [1, 2, 3]
  ```
- Construct DP states or transformed arrays.  

⚠️ Pitfall: On **huge arrays**, `map()` creates a new array. For memory-critical problems, prefer in-place loops.  

---

### 🔹 **2. `filter()`**
Returns elements matching a condition.  

```js
const arr = [1, 2, 3, 4];
const evens = arr.filter(x => x % 2 === 0); // [2, 4]
```

- **Time Complexity**: `O(n)`  
- **Space Complexity**: Up to `O(n)` (worst case all pass).  

####  Use Cases:
- Extract positive numbers, valid indices, or nodes.  
- Remove duplicates (with `Set` + `filter`).  

⚠️ Pitfall: Avoid chaining `filter + map` on massive arrays. Use a single loop for efficiency.  

---

### 🔹 **3. `reduce()`**
Accumulates values into a single result.  

```js
const arr = [1, 2, 3, 4];
const sum = arr.reduce((acc, x) => acc + x, 0); // 10
```

- **Time Complexity**: `O(n)`  
- **Space Complexity**: `O(1)` (if accumulator is primitive).  

####  Use Cases:
- Summation, products, min/max.  
- Prefix/suffix computations.  
- Building hash maps:  
  ```js
  const freq = arr.reduce((map, x) => {
    map[x] = (map[x] || 0) + 1;
    return map;
  }, {});
  ```

⚠️ Pitfall: Avoid overly complex reducers (nested loops inside `reduce`). That turns into `O(n²)`.  

---

### 🔹 **4. `sort()`**
Sorts array **in-place** (mutates). Default = **lexicographic (string)**.  

```js
const nums = [5, 1, 10];
nums.sort(); // [1, 10, 5] ❌ wrong for numbers
nums.sort((a, b) => a - b); // [1, 5, 10] ✅
```

- **Time Complexity**: `O(n log n)` (Timsort).  
- **Space Complexity**: `O(n)` (depending on engine).  

####  Use Cases:
- Sorting intervals, edges (Kruskal’s MST).  
- Sorting strings/characters for anagram problems.  

⚡ Tricks:
- Descending: `(b - a)`.  
- Sort by multiple keys:
  ```js
  arr.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
  ```

⚠️ Pitfall: Sorting is expensive. If only need **k smallest/largest elements**, use **heap** or `quickselect`.  

---

### 🔹 **5. `splice(start, deleteCount, ...items)`**
Mutates the array → adds/removes elements.  

```js
let arr = [1, 2, 3, 4];
arr.splice(1, 2); // removes [2,3], arr = [1,4]
arr.splice(1, 0, 99); // inserts at index 1, arr = [1,99,4]
```

- **Time Complexity**: `O(n)` (shifts elements).  
- **Space Complexity**: `O(1)` (mutates in place).  

####  Use Cases:
- Removing elements dynamically in simulation problems.  
- In-place modifications when memory is tight.  

⚠️ Pitfall: Avoid frequent splicing in large arrays. Use **linked lists** or build a new array.  

---

## 4. Tradeoffs  

- `map` vs `for` → `map` is concise but less memory-efficient on large inputs.  
- `filter` + `map` chaining → elegant, but `2n` traversals. Replace with `reduce` or one loop.  
- `reduce` → powerful, but readability suffers. Prefer explicit loops in interviews if clarity > brevity.  
- `sort` → use only when needed. Sorting `10⁵` elements is fine, but sorting inside loops = TLE.  
- `splice` → costly; prefer **slice (non-mutating)** for extraction.  

---

## 5. Interview-Level Code Patterns  

### 5.1 Array Sum with Reduce
```js
const sum = arr.reduce((a, b) => a + b, 0);
```

### 5.2 Frequency Counter
```js
const freq = arr.reduce((map, x) => {
  map[x] = (map[x] || 0) + 1;
  return map;
}, {});
```

### 5.3 Filter Unique Elements
```js
const unique = arr.filter((x, i) => arr.indexOf(x) === i);
```

### 5.4 Sort Intervals
```js
intervals.sort((a, b) => a[0] - b[0]);
```

### 5.5 Remove Element In-Place
```js
let arr = [1, 2, 3, 4];
arr.splice(arr.indexOf(3), 1); // [1,2,4]
```

---

## 6. Complexity Summary  

| Method     | Time | Space | Mutates? | Best Use |
|------------|------|-------|----------|----------|
| `map()`    | O(n) | O(n)  | ❌ | Transform arrays |
| `filter()` | O(n) | O(n)  | ❌ | Extract subset |
| `reduce()` | O(n) | O(1)  | ❌ | Aggregation |
| `sort()`   | O(n log n) | O(n) | ✅ | Ordering, greedy algorithms |
| `splice()` | O(n) | O(1)  | ✅ | Insert/remove in place |

---

## ✅ In Summary  

- **`map`** → transformations (concise but creates new array).  
- **`filter`** → subset extraction (avoid chaining for performance).  
- **`reduce`** → aggregations & building maps.  
- **`sort`** → `O(n log n)` ordering (use comparator for numbers).  
- **`splice`** → in-place modifications (use sparingly on large arrays).  

For **interviews**, balance **readability vs performance**:
- Use high-order methods for clarity in coding rounds.  
- Use **loops/in-place ops** in time-critical sections.  

---



# 🚀 Node.js Array Utilities Template 

```javascript
// ===============================
// 📘 Node.js Array Utilities
// ===============================

// 1️⃣ Transform Array (map)
function squareArray(arr) {
  return arr.map(x => x * x);
}

// 2️⃣ Filter Array
function filterEvens(arr) {
  return arr.filter(x => x % 2 === 0);
}

// 3️⃣ Aggregate with Reduce
function sumArray(arr) {
  return arr.reduce((acc, x) => acc + x, 0);
}

function productArray(arr) {
  return arr.reduce((acc, x) => acc * x, 1);
}

// 4️⃣ Sort Utilities
function sortAscending(arr) {
  return arr.sort((a, b) => a - b);
}

function sortDescending(arr) {
  return arr.sort((a, b) => b - a);
}

// Sort by multiple keys
function sortByTwoKeys(arr) {
  return arr.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
}

// 5️⃣ Splice (In-place Insert/Remove)
function removeElement(arr, value) {
  const idx = arr.indexOf(value);
  if (idx !== -1) arr.splice(idx, 1);
  return arr;
}

function insertAt(arr, index, value) {
  arr.splice(index, 0, value);
  return arr;
}

// ===============================
// 🛠 Common LeetCode Helpers
// ===============================

// Frequency counter
function frequencyCounter(arr) {
  return arr.reduce((map, x) => {
    map[x] = (map[x] || 0) + 1;
    return map;
  }, {});
}

// Unique elements
function uniqueElements(arr) {
  return arr.filter((x, i) => arr.indexOf(x) === i);
}

// Prefix sums
function prefixSum(arr) {
  const ps = [0];
  for (let x of arr) ps.push(ps[ps.length - 1] + x);
  return ps; // length = n+1
}

// K smallest elements (heap alternative for small k)
function kSmallest(arr, k) {
  return arr.sort((a, b) => a - b).slice(0, k);
}
```

---

## 🔑 Usage Examples

```javascript
console.log(squareArray([1,2,3])); // [1,4,9]
console.log(filterEvens([1,2,3,4])); // [2,4]
console.log(sumArray([1,2,3,4])); // 10
console.log(sortAscending([5,1,3])); // [1,3,5]
console.log(removeElement([1,2,3,4], 3)); // [1,2,4]

console.log(frequencyCounter([1,1,2,3,3])); // {1:2, 2:1, 3:2}
console.log(uniqueElements([1,2,2,3])); // [1,2,3]
console.log(prefixSum([1,2,3])); // [0,1,3,6]
console.log(kSmallest([5,1,9,3], 2)); // [1,3]
```

---

## ✅ Why This is Interview-Ready

- **Covers core methods**: `map`, `filter`, `reduce`, `sort`, `splice`.  
- **Optimized helpers** for frequent interview tasks (prefix sums, frequency maps, unique values).  
- **Readable + Reusable** → Copy once, reuse in any problem.  
- **Handles edge cases** (missing element in `removeElement`, stable sorting with two keys).  

---



# 📘 Node.js String & Array Methods: `slice` vs `splice` vs `substring`

---

## 1. **slice()**

* **Works on both Arrays & Strings**.
* Returns a **shallow copy** of a portion of the array/string.
* **Non-mutating** (original remains unchanged).

### ✅ Syntax:

```js
array.slice(start, end)   // elements from start to end-1
string.slice(start, end)  // substring from start to end-1
```

### 🔹 Examples:

```js
let arr = [1,2,3,4,5];
console.log(arr.slice(1,4)); // [2,3,4]
console.log(arr);            // [1,2,3,4,5] (unchanged)

let s = "leetcode";
console.log(s.slice(0,4));   // "leet"
console.log(s.slice(-3));    // "ode"
```

### ⚡ Key Points:

* Accepts **negative indices** (counts from end).
* Time Complexity: `O(k)` (copies `k` elements).
* Space Complexity: `O(k)` (new array/string).

### 📌 Use Cases:

* Subarray/substring extraction.
* String rotation problems:

  ```js
  s.slice(k) + s.slice(0, k);
  ```
* Slicing arrays in divide-and-conquer (binary search, mergesort).

---

## 2. **splice()**

* **Only works on Arrays**.
* Changes the **original array (mutating)**.
* Used to **insert/remove/replace** elements.

### ✅ Syntax:

```js
array.splice(start, deleteCount, item1, item2, ...)
```

### 🔹 Examples:

```js
let arr = [1,2,3,4,5];
arr.splice(2, 2);           // remove 2 elements at index 2
console.log(arr);           // [1,2,5]

arr.splice(1, 0, 99, 100);  // insert at index 1
console.log(arr);           // [1,99,100,2,5]
```

### ⚡ Key Points:

* Mutates the array.
* Can **add/remove/replace** elements.
* Time Complexity: `O(n)` (shifts elements).

### 📌 Use Cases:

* In-place simulation problems (like “remove element in-place” on LeetCode).
* Dynamic array updates when immutability is not required.
* Simulating linked-list behavior in array-based problems.

---

## 3. **substring()**

* **Only works on Strings**.
* Extracts characters between two indices.
* **Non-mutating**.

### ✅ Syntax:

```js
string.substring(start, end)   // substring from start to end-1
```

### 🔹 Examples:

```js
let s = "leetcode";
console.log(s.substring(0,4));  // "leet"
console.log(s.substring(4,0));  // "leet" (⚠️ swaps arguments)
console.log(s.substring(2,2));  // "" (empty string)
```

### ⚡ Key Points:

* **No negative indices** (unlike `slice`).
* If `start > end`, it automatically swaps them.
* Time Complexity: `O(k)`.

### 📌 Use Cases:

* Rarely preferred (because `slice` is more powerful).
* Useful when interviewer expects safe handling of swapped indices.

---

## 4. ⚡ Quick Comparison Table

| Feature         | **slice()**      | **splice()**          | **substring()**               |
| --------------- | ---------------- | --------------------- | ----------------------------- |
| Works On        | Array + String   | Array only            | String only                   |
| Mutates?        | ❌ No             | ✅ Yes                 | ❌ No                          |
| Negative Index? | ✅ Yes            | ❌ No                  | ❌ No                          |
| Return Value    | New array/string | Removed elements      | New string                    |
| Use Case        | Copy/Extract     | Insert/Remove/Replace | Extract (safe index handling) |
| TC / SC         | O(k) / O(k)      | O(n) / O(1)           | O(k) / O(k)                   |

---

## 5. Tips

1. **Interview Trick** → If interviewer asks for substring extraction:

   * Use `slice()` unless explicitly told to use `substring()`.

2. **Mutation Awareness**:

   * `splice` modifies original array → can cause bugs in DFS/recursion if not cloned.

3. **Negative Index Gotcha**:

   * `slice(-3)` works.
   * `substring(-3)` → treated as `0`.

4. **Performance**:

   * For subarray problems, `slice` is safe.
   * Avoid repeated `splice` in big arrays (O(n²) if used inside loops).

---

✅ **In summary**:

* Use **`slice`** → non-mutating, supports negatives → best for subarrays/substrings.
* Use **`splice`** → mutating, for in-place modifications (insert/remove).
* Use **`substring`** → legacy safe method (no negatives, swaps indices).


# 📘 What Does Mutation Mean in JavaScript/Node.js?

### **Definition**

👉 **Mutation means changing the original data structure in place** (instead of returning a new copy).

* If a method **mutates**, the original array or object is modified.
* If a method is **non-mutating (immutable)**, it creates and returns a new array/string/object, leaving the original unchanged.

---

## 🔹 Mutation with Arrays

```js
let arr = [1, 2, 3];

// Mutating method → changes arr directly
arr.splice(1, 1);   
console.log(arr); // [1, 3] ✅ original array modified

// Non-mutating method → returns new array
let sliced = arr.slice(0, 1);
console.log(sliced); // [1]
console.log(arr);    // [1, 3] ✅ unchanged
```

* `splice()` → **mutates** (removes/updates inside original array).
* `slice()` → **non-mutating** (creates a copy).

---

## 🔹 Mutation with Strings

⚠️ Strings in JS are **immutable** — you **cannot mutate** them.
All methods (`slice`, `substring`, `replace`, etc.) return a **new string**.

```js
let s = "hello";
let newS = s.replace("h", "y");
console.log(s);   // "hello" ✅ unchanged
console.log(newS); // "yello"
```

---

## 🔹 Mutation with Objects

```js
let obj = {a: 1};

// Mutating → changes the same reference
obj.a = 2;
console.log(obj); // {a: 2}

// Non-mutating → clone, then change
let copy = {...obj, a: 3};
console.log(copy); // {a: 3}
console.log(obj);  // {a: 2} ✅ unchanged
```

---

## 🔑 Why Mutation Matters in Interviews

1. **Side Effects**

   * ==Mutating arrays inside recursion/backtracking may break logic if you forget to undo changes.==

   ```js
   function backtrack(arr) {
     arr.push(99);   // mutating!
     arr.pop();      // must undo to restore state
   }
   ```

2. **Time Complexity**

   * Mutating operations like `splice` may **shift elements** → `O(n)`.

3. **Predictability**

   * Non-mutating functions (`map`, `filter`, `slice`) are **safer in interviews** since they don’t surprise you by altering original data.

---

## ✅ Quick Mutation Reference

| Method          | Mutates? | Notes                          |
| --------------- | -------- | ------------------------------ |
| `splice()`      | ✅ Yes    | Adds/removes/replaces in array |
| `sort()`        | ✅ Yes    | Reorders array in place        |
| `push/pop`      | ✅ Yes    | Stack operations               |
| `shift/unshift` | ✅ Yes    | Queue operations               |
| `slice()`       | ❌ No     | Copies subarray                |
| `map()`         | ❌ No     | Returns new array              |
| `filter()`      | ❌ No     | Returns new array              |
| `reduce()`      | ❌ No     | Returns single value           |
| Strings         | ❌ No     | Always immutable               |

---

✅ **In summary**:

* **Mutation = changing the original data structure in place.**
* Arrays have mutating methods (`splice`, `sort`, `push`) and non-mutating ones (`slice`, `map`, `filter`).
* Strings are **never mutated** → always new copies.
