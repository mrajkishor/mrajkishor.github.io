**Full list of JavaScript coding tasks** companies typically ask in interviews, especially at **senior/frontend engineer** level.


## **1Ô∏è‚É£ JavaScript Core Language Implementations (Polyfills & Core Methods)**

These are **must-know** ‚Äî Interviewers love asking these to test deep understanding.

* Implement `Array.prototype.map`
* Implement `Array.prototype.filter`
* Implement `Array.prototype.reduce`
* Implement `Array.prototype.forEach`
* Implement `Function.prototype.bind`
* Implement `Function.prototype.call`
* Implement `Function.prototype.apply`
* Implement `Promise.all`
* Implement `Promise.any`
* Implement `Promise.race`
* Implement a **debounce** function
* Implement a **throttle** function
* Implement a **memoization** function
* Implement a **curry** function
* Implement a **once** function (runs only once)
* Implement a **deep clone** function (with support for nested objects, arrays, Dates, RegExp, circular refs)
* Implement `setTimeout` using `requestAnimationFrame`
* Implement your own **event emitter** (on, off, emit, once)
* Implement a **retry** mechanism for async calls with exponential backoff

---

## **2Ô∏è‚É£ Asynchronous JavaScript Challenges**

These test **event loop understanding**, **promises**, and **timing**.

* Create a **sleep** function with Promises & async/await
* Chain promises in sequence from an array of async functions
* Run multiple promises in parallel with a concurrency limit
* Cancel a promise after a timeout (Promise timeout wrapper)
* Implement a polling mechanism (e.g., check server until success or timeout)
* Schedule tasks using `setTimeout` in the correct order
* Implement a **time-limited cache** function

---

## **3Ô∏è‚É£ Event Loop & Execution Order Gotchas**

These often appear as **tricky output prediction** or ‚Äúfix the bug‚Äù questions.

* Given a mix of `setTimeout`, `Promise.resolve`, `console.log` ‚Äî predict output
* Fix async loops to avoid closure issues (`for(var i...) setTimeout`)
* Explain why a particular output order happens and fix it

---

## **4Ô∏è‚É£ DOM & Browser API Coding**

Mostly for frontend roles ‚Äî often in **onsite practical rounds**.

* Implement infinite scroll
* Implement a drag-and-drop element
* Build a search input with debounce
* Implement a countdown timer
* Create a modal dialog without libraries
* Implement a simple SPA router from scratch
* Implement lazy loading of images with `IntersectionObserver`
* Create a pub-sub mechanism in browser context
* Implement a tab-switcher component
* Build a sticky header that changes on scroll

---

## **5Ô∏è‚É£ Data Structure & Algorithm Problems in JavaScript**

Same as DSA, but **implemented in JS** ‚Äî they test if you can **marry DSA knowledge with JS language quirks**.

**Arrays & Strings**

* Reverse a string/array
* Find duplicates in an array
* Flatten a deeply nested array
* Rotate an array in place
* Two sum problem
* Group anagrams
* Longest substring without repeating characters
* Sliding window max sum problem

**Objects & Maps**

* Deep merge two objects
* Count occurrences of elements in an array
* Implement LRU Cache in JS using `Map`

**Stacks & Queues**

* Implement a stack using arrays
* Implement a queue using arrays
* Implement a browser history (back/forward) using stacks

**Trees & Graphs**

* BFS and DFS traversal in JS
* Find shortest path in a graph
* Serialize and deserialize a binary tree (JS objects)

---

## **6Ô∏è‚É£ System / Architecture-level JS Tasks**

These are **senior-level** ‚Äî used in onsite system design for frontend.

* Design a **type-ahead/autocomplete** service in JS
* Implement a **scheduler** that runs tasks at specified intervals
* Build a **virtual DOM** and diffing algorithm (simplified React-like)
* Implement **state management** from scratch (store, subscribe, dispatch)
* Implement a **module loader** (like CommonJS `require`)

---

üí° **Tip:**
If you can solve **all of these from scratch** in **vanilla JS** (no libraries), you‚Äôll be extremely prepared.

At **senior role**, they‚Äôll expect:

* Clean, modular, testable code
* Optimal performance (time & space complexity awareness)
* Ability to **explain design choices**


