
# üìò Chapter 3 ‚Äì Database Architectures and the Web

---

## 1. Multi-User DBMS Architectures

Databases are rarely single-user. Most are **multi-user systems** where many people interact with the database at the same time. The architecture defines how requests are handled between **clients** and the **DBMS server**.

### 1.1 Teleprocessing

* Oldest form of centralized computing.
* All processing is done on a **central mainframe computer**.
* **Terminals** are ‚Äúdumb‚Äù devices with no processing power, just input/output.
* Limitations: bottlenecks, single point of failure, difficult to scale.

### 1.2 File-Server Architecture

* An early improvement, where a **file server** stored database files.
* Clients ran applications that accessed these files over a LAN.
* Issues:

  * High **network traffic** (entire files transferred).
  * Poor **security** (files exposed to client machines).
  * No **concurrency control** (conflicts when multiple users modify data).
* Considered **inefficient** and **obsolete** today.

### 1.3 Traditional Two-Tier Client‚ÄìServer

* DBMS runs on a **server**, clients run application programs.
* Clients send **SQL queries** ‚Üí server executes ‚Üí returns results.
* Advantages:

  * Reduced network load.
  * Server handles concurrency and transaction management.
* Limitations:

  * Applications must be installed/updated on every client.
  * Doesn‚Äôt scale well when many users connect.

### 1.4 Three-Tier Client‚ÄìServer Architecture

* Separates into three layers:

  1. **Presentation layer** (GUI, web browser, or app).
  2. **Application layer** (business logic, often an application server).
  3. **Database layer** (DBMS server).
* Benefits:

  * Easier maintenance (business logic centralized).
  * Better **scalability** than two-tier.
  * Security improved (DB server hidden behind application layer).

### 1.5 N-Tier Architectures

* Extension of three-tier with more distributed layers (e.g., caching servers, load balancers, microservices).
* Used in **large enterprise and web apps**.
* Enables **flexibility** and **horizontal scaling**.

### 1.6 Middleware

* **Glue software** that connects different systems.
* Provides **API or communication protocols** so clients and servers can interact without knowing technical details.
* Examples: ODBC, JDBC, CORBA.

### 1.7 Transaction Processing Monitors

* Middleware specialized in **coordinating transactions** across multiple applications/DBs.
* Ensures **ACID properties** even in distributed environments.
* Example: CICS (IBM), Tuxedo (Oracle).

---

## 2. Web Services and Service-Oriented Architectures (SOA)

The **Web** changed database architectures by enabling remote access and **interoperability** between systems.

### 2.1 Web Services

* ==A **self-contained, modular application** accessible via standard web protocols (HTTP, XML, JSON).==
* Allow applications to **communicate across platforms**.
* Examples: REST APIs, SOAP services.

__Note:__ 

SOAP (Simple Object Access Protocol) and REST (Representational State Transfer) are two distinct approaches for building web services, facilitating communication between different applications. 

<ins>__SOAP__: 

‚Ä¢ __Protocol__: SOAP is a standardized protocol with strict rules for message structure and processing, primarily using XML for messaging. 
‚Ä¢ __Function-driven__: It focuses on exposing specific operations or functions an application can perform. 
‚Ä¢ __Stateful or Stateless__: While stateless by default, it can be made stateful. 
‚Ä¢ __Security__: Offers built-in security features like WS-Security, providing robust security for enterprise-level applications.
‚Ä¢ __Bandwidth__: Generally requires more bandwidth due to the XML-based message format and additional overhead. 
‚Ä¢ __Complexity__: Can have a steeper learning curve and requires adherence to its defined standards. 

<ins>__REST__: 

‚Ä¢ __Architectural Style__: REST is an architectural style based on __principles for building distributed systems__, leveraging standard HTTP methods (GET, POST, PUT, DELETE) to interact with resources. 
‚Ä¢ __Data-driven__: It focuses on representing and manipulating resources (data) through URIs. 
‚Ä¢ __Stateless__: Designed to be stateless, where each request is independent of previous ones. 
‚Ä¢ __Security__: Relies on transport-level security like HTTPS and can incorporate application-level security mechanisms (e.g., OAuth). 
‚Ä¢ __Bandwidth__: Typically requires less bandwidth due to its flexibility in data formats (e.g., JSON, ==XML==, plain text) and lighter message payloads. 
‚Ä¢ __Simplicity__: Generally easier to implement, understand, and use, especially for public APIs. 
‚Ä¢ __Caching__: Supports caching of responses, which can improve performance and reduce server load.  

Key Differences Summarized: 

| Feature | SOAP | REST  |
| --- | --- | --- |
| Nature | Protocol | Architectural Style  |
| Focus | Function-driven (operations) | Data-driven (resources)  |
| Messaging | Primarily XML | XML, JSON, HTML, plain text, etc.  |
| State | Can be stateful | Stateless  |
| Security | Built-in (WS-Security) | Relies on HTTPS and other mechanisms  |
| Bandwidth | Higher | Lower  |
| Complexity | More complex, steeper learning curve | Simpler, easier to implement  |
| Caching | Not supported by default | Supported  |
| Protocol(s) | HTTP, SMTP, UDP, etc. | Primarily HTTP  |

__When to Choose:__

‚Ä¢ __SOAP__: Preferred for enterprise-level applications requiring high security, reliability, and strict contract enforcement, often in environments with legacy systems or specific compliance needs. 
‚Ä¢ __REST__: Favored for public APIs, mobile applications, and web services where simplicity, flexibility, performance, and broad compatibility are crucial. 

> Ref: https://www.servicenow.com/community/developer-forum/what-is-difference-between-between-rest-and-soap-in-servicenow/m-p/2857321




### 2.2 Service-Oriented Architecture (SOA)

* Systems are built as a collection of **loosely coupled services**.
* Each service performs a specific business function and can be reused.
* Benefits:

  * Modularity ‚Üí easier to maintain.
  * Interoperability ‚Üí works across technologies.
  * Scalability ‚Üí services can be distributed.

---

## 3. Distributed DBMSs (DDBMS)

* A database logically appears as a **single system**, but data is **distributed** across multiple servers.
* Benefits: reliability, availability, and locality of data.
* Challenges:

  * Complexity of synchronization.
  * Maintaining consistency.
* Forms part of modern **cloud database systems**.

---

## 4. Data Warehousing

* A **data warehouse** stores historical and integrated data for **decision-making**.
* Focus: **read-heavy workloads** (queries, analysis), not transactions.
* Supports **OLAP (Online Analytical Processing)** for reporting and analytics.
* Often separate from the operational database.

---

## 5. Cloud Computing and Databases

### 5.1 Cloud Computing

* Provides **on-demand access** to computing resources via the Internet.
* Models:

  * **IaaS**: Infrastructure as a Service (AWS EC2).
  * **PaaS**: Platform as a Service (AWS RDS, Google Cloud SQL).
  * **SaaS**: Software as a Service (Salesforce, Office 365).

### 5.2 Benefits

* Elastic scalability.
* Pay-as-you-go pricing.
* Reduced hardware and maintenance costs.

### 5.3 Risks

* Data privacy/security.
* Vendor lock-in.
* Internet dependency.

### 5.4 Cloud-Based Database Solutions

* **Amazon RDS, DynamoDB, Google BigQuery, Microsoft Azure SQL**.
* Offer automatic **backup, replication, and scaling**.
* Enable global accessibility.

---

## 6. Components of a DBMS

Key internal components of a DBMS (applies regardless of architecture):

* **Query processor** ‚Üí parses and optimizes SQL queries.
* **Storage manager** ‚Üí manages files, indexes, and data structures.
* **Transaction manager** ‚Üí ensures ACID properties.
* **Recovery manager** ‚Üí restores data after crashes.
* **Catalog/Metadata manager** ‚Üí stores schema definitions.
* **Buffer manager** ‚Üí handles memory management.

---

## 7. Oracle DBMS Architecture (Case Example)

* **Logical Structure**:

  * Tablespaces ‚Üí segments ‚Üí extents ‚Üí blocks.
  * Provides logical independence from physical storage.

* **Physical Structure**:

  * Datafiles, redo log files, control files.
  * Manages actual persistence on disk.

This example shows how a **real enterprise DBMS** organizes its components.

---

## üîë Key Takeaways

1. DBMS architecture evolved from **teleprocessing ‚Üí file-server ‚Üí client‚Äìserver ‚Üí n-tier ‚Üí web/cloud systems**.
2. Middleware and transaction monitors ensure **smooth communication and ACID guarantees**.
3. **Web services and SOA** make databases interoperable across distributed systems.
4. **Cloud databases** represent the latest trend: scalable, elastic, and cost-efficient, but with risks.
5. A DBMS always relies on **core internal components** like query processor, storage manager, and recovery manager.


