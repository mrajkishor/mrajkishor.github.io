
> Heavily tested in GATE.


# **Chapter 5 – Process Synchronization (Sections 5.1–5.8)**

---

## **5.1 Background**

### **Why Synchronization?**

* In multiprogramming & multi-core systems, multiple processes/threads **execute concurrently**.
* If they share **data/resources**, unsynchronized access can cause **data inconsistency**.
* Goal: **Ensure correct, predictable results** despite concurrency.

---

### **Race Condition**

* Occurs when multiple processes access and modify shared data **concurrently**, and the **final result depends on execution order**.
* Example:

  ```c
  balance = balance + deposit;
  ```

  If two threads execute this without protection → lost updates.

---

### **Solution:**

* **Critical Section**: A section of code where shared data is accessed/modified.
* Must allow **only one process at a time** in its critical section.

---

## **5.2 The Critical-Section Problem**

### **General Structure (n processes)**

```plaintext
do {
    entry_section();     // request to enter critical section
    critical_section();  // access shared data
    exit_section();      // leave critical section
    remainder_section(); // non-critical work
} while (true);
```

---

### **Requirements for a Correct Solution**

1. **Mutual Exclusion** – Only one process in CS at a time.
2. **Progress** – If no process is in CS, selection of next entrant can’t be postponed indefinitely.
3. **Bounded Waiting** – There’s a limit on the number of times other processes can enter CS before a requesting process is allowed in.

---

## **5.3 Peterson’s Solution**

### **Assumptions**

* Works for **two processes**.
* Shared variables:

  ```c
  boolean flag[2]; // true if process wants to enter CS
  int turn;        // whose turn it is
  ```

### **Algorithm**

```c
// process i
flag[i] = true;
turn = j;
while (flag[j] && turn == j) ;
critical section
flag[i] = false;
```

### **Properties**

* Satisfies **mutual exclusion**, **progress**, and **bounded waiting**.
* Requires strict alternation of turn.
* Only works with **atomic** read/write to shared variables.

---

## **5.4 Synchronization Hardware**

### **Why Hardware Support?**

* In multiprocessors, disabling interrupts is impractical.
* Hardware instructions can provide **atomicity**.

### **Atomic Instructions**

1. **Test-and-Set (TAS)**

   ```c
   bool test_and_set(bool *target) {
       bool rv = *target;
       *target = true;
       return rv;
   }
   ```

   * Can be used to implement locks.

2. **Compare-and-Swap (CAS)**

   ```c
   int compare_and_swap(int *value, int expected, int new_value) {
       int temp = *value;
       if (*value == expected) *value = new_value;
       return temp;
   }
   ```

**Note:** These primitives are **atomic** → no other process can interrupt during execution.

---

## **5.5 Mutex Locks**

### **Concept**

* A **mutex (mutual exclusion) lock** is a synchronization tool to protect critical sections.
* Has two operations:

  * **acquire()** – lock before entering CS.
  * **release()** – unlock after leaving CS.

**Problem:** Simple mutex locks cause **busy waiting** (CPU cycles wasted while waiting).

---

## **5.6 Semaphores**

### **Definition**

* Integer variable accessed via **atomic operations** `wait()` and `signal()`.

### **Types**

1. **Counting Semaphore** – Integer can range over unrestricted domain.
2. **Binary Semaphore** – Value = 0 or 1 (similar to mutex).

---

### **Operations**

```c
wait(S) {
    while (S <= 0) ; // busy wait
    S--;
}

signal(S) {
    S++;
}
```

---

### **Avoiding Busy Waiting**

* Use **block/wake-up** mechanism:

  * Processes waiting are placed in a queue.
  * `wait()` → block process if `S <= 0`.
  * `signal()` → wake up a blocked process.

---

## **5.7 Classic Problems of Synchronization**

These are **canonical problems** GATE loves — test your ability to apply semaphores/mutex.

---

### **1. Bounded-Buffer (Producer–Consumer) Problem**

* **n buffers** → producer adds, consumer removes.
* Shared variables protected by semaphores:

  * `mutex` = 1 (for mutual exclusion)
  * `empty` = n (count of empty slots)
  * `full` = 0 (count of full slots)

---

### **2. Readers–Writers Problem**

* **Multiple readers** can read simultaneously.
* **Writers** need exclusive access.
* Semaphore-based solutions control read-count & mutual exclusion.

---

### **3. Dining Philosophers Problem**

* **5 philosophers** alternating between thinking and eating.
* Each needs **two forks** to eat (represented by semaphores).
* Naive solution can cause **deadlock**.

---

## **5.8 Monitors**

### **Concept**

* High-level synchronization construct.
* Encapsulates:

  * Shared variables
  * Procedures that operate on them
* Only one process can execute monitor code at a time.

---

### **Condition Variables**

* Used inside monitors for synchronization.
* Operations:

  * `wait()` → releases monitor lock, suspends process.
  * `signal()` → resumes one waiting process.

---

## **GATE Exam Pointers**

* **Peterson’s solution** conditions & working → classic 2–4 mark question.
* **TAS vs CAS** difference and example use.
* **Binary vs Counting semaphores**.
* Application of semaphores in **producer–consumer** is a must-practice.
* **Dining philosophers** → deadlock avoidance techniques.
* Monitors vs Semaphores is often asked in theory questions.

