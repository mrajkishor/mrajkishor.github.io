

# ðŸ”· MySQL User-Defined Functions (UDFs)

## 1. Concept

In MySQL, a **User-Defined Function (UDF)** is a custom function you create to extend SQLâ€™s built-in capabilities. Unlike stored procedures (which are invoked with `CALL`), UDFs behave like **built-in functions** and can be used directly inside `SELECT`, `WHERE`, `ORDER BY`, `HAVING`, and other SQL clauses.

They allow developers to **encapsulate reusable logic** and **integrate application-specific rules** into SQL queries, making them extremely powerful for analytics, business rules, and performance optimization.

---

## 2. Stored Procedure vs UDF â€” Key Differences

| Aspect                  | Stored Procedure                             | User-Defined Function (UDF)                                   |
| ----------------------- | -------------------------------------------- | ------------------------------------------------------------- |
| **Invocation**          | Called with `CALL procedure_name(...)`       | Invoked like a function inside SQL (`SELECT myFunction(col)`) |
| **Return**              | Can return multiple values using OUT params  | Must return exactly **one scalar value**                      |
| **Usage in Queries**    | Cannot be used in `SELECT`, `WHERE` directly | Can be embedded anywhere an expression is allowed             |
| **Side Effects**        | Can modify DB state (INSERT/UPDATE/DELETE)   | Must be deterministic, cannot modify DB state                 |
| **Transaction Control** | Supports transactions                        | Cannot start/commit/rollback transactions                     |

ðŸ‘‰ **Takeaway**: UDFs are meant for *calculations and transformations*, not for DML or transactional logic.

---

## 3. Syntax of UDFs

### Basic Structure

```sql
DELIMITER //

CREATE FUNCTION function_name (
    param1 datatype,
    param2 datatype
)
RETURNS return_datatype
DETERMINISTIC
BEGIN
    -- Logic goes here
    DECLARE result INT;
    SET result = param1 + param2;
    RETURN result;
END //

DELIMITER ;
```

### Key Clauses

* `RETURNS` â†’ specifies return data type (`INT`, `DECIMAL`, `VARCHAR`, `DATE`, etc.).
* `DETERMINISTIC` vs `NOT DETERMINISTIC` â†’

  * `DETERMINISTIC`: guarantees same output for same input (required for replication & optimization).
  * `NOT DETERMINISTIC`: output may vary (e.g., using `NOW()`, `RAND()`).
* `NO SQL` / `READS SQL DATA` â†’ required for function classification.

  * `NO SQL` â†’ function does not read/write DB.
  * `READS SQL DATA` â†’ function may query data but not modify it.

---

## 4. Creating and Using UDFs

### Example 1: Simple Mathematical Function

```sql
DELIMITER //
CREATE FUNCTION SquareNum (num INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN num * num;
END //
DELIMITER ;

-- Use it
SELECT SquareNum(5);   -- Output: 25
```

---

### Example 2: String Formatting Function

```sql
DELIMITER //
CREATE FUNCTION FormatName (
    firstName VARCHAR(50),
    lastName VARCHAR(50)
)
RETURNS VARCHAR(120)
DETERMINISTIC
BEGIN
    RETURN CONCAT(UPPER(firstName), ' ', INITCAP(lastName));
END //
DELIMITER ;

-- Use it
SELECT FormatName('kishor', 'maharana'); 
-- Output: KISHOR Maharana
```

---

### Example 3: Business Logic Function

```sql
DELIMITER //
CREATE FUNCTION TaxCalculator (amount DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    DECLARE taxRate DECIMAL(3,2) DEFAULT 0.18; -- 18% GST
    RETURN amount + (amount * taxRate);
END //
DELIMITER ;

-- Use it
SELECT product_name, TaxCalculator(price) AS final_price
FROM products;
```

ðŸ“Œ This embeds business rules **directly in SQL queries** for consistency across applications.

---

### Example 4: Date Utility Function

```sql
DELIMITER //
CREATE FUNCTION DaysBetween (
    startDate DATE,
    endDate DATE
)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN DATEDIFF(endDate, startDate);
END //
DELIMITER ;

-- Use it
SELECT DaysBetween('2025-01-01', '2025-08-24');  -- Output: 235
```

---

## 5. Managing UDFs

* **View all functions**

```sql
SHOW FUNCTION STATUS WHERE Db = 'my_database';
```

* **Show function definition**

```sql
SHOW CREATE FUNCTION FormatName;
```

* **Drop a function**

```sql
DROP FUNCTION IF EXISTS SquareNum;
```

---

## 6. Advanced Use Cases in Enterprise-scale Systems

* âœ… **Reusable Data Transformations**
  Convert text formats, normalize phone numbers, mask sensitive data.

* âœ… **Business Rule Enforcement**
  Tax, commission, discount rules embedded consistently across services.

* âœ… **Analytics Pipelines**
  Compute custom KPIs directly in SQL queries.

* âœ… **Integration with ORMs**
  Use UDFs to simplify queries at ORM layer instead of writing raw SQL repeatedly.

---

## 7. Best Practices

1. **Keep UDFs Pure** â†’ No side effects, only return values.
2. **Deterministic Functions** â†’ Always declare deterministic if possible, helps query optimizer.
3. **Performance Consideration** â†’ Avoid heavy loops inside UDFs; let SQL set-based operations handle large data.
4. **Version Control** â†’ Track UDFs with schema migration tools (Liquibase, Flyway).
5. **Security** â†’ Ensure UDFs donâ€™t leak sensitive logic (e.g., hashing passwords securely instead of writing your own).
6. **Replace with Built-ins when Possible** â†’ MySQL already has many built-ins (`CONCAT_WS`, `DATEDIFF`, etc.).

---

## 8. Common Interview Questions

1. **Difference between Stored Procedures and User-Defined Functions in MySQL?**
   â†’ Procedures can return multiple values and modify DB state; functions must return a single value and cannot modify DB.

2. **Why declare a function as DETERMINISTIC?**
   â†’ Ensures the optimizer knows output depends only on inputs â†’ critical for caching, replication, and performance.

3. **Can a UDF perform INSERT/UPDATE/DELETE? Why or why not?**
   â†’ No. Functions must be pure and side-effect free to maintain consistency.

4. **Where would you use UDFs in a distributed system?**
   â†’ Data consistency rules, reusable KPIs, secure masking (PII anonymization).

---


# ðŸ“‘ Code Samples: Creating and Using UDFs in MySQL

---

## 1. Simple Mathematical UDF

```sql
-- Drop if exists
DROP FUNCTION IF EXISTS SquareNum;

DELIMITER //
CREATE FUNCTION SquareNum (num INT)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN num * num;
END //
DELIMITER ;

-- Usage
SELECT SquareNum(7);  -- Output: 49
```

ðŸ“Œ **Use case**: Extend SQL with custom math functions.

---

## 2. String Manipulation UDF

```sql
DROP FUNCTION IF EXISTS ProperCase;

DELIMITER //
CREATE FUNCTION ProperCase (inputStr VARCHAR(100))
RETURNS VARCHAR(100)
DETERMINISTIC
BEGIN
    RETURN CONCAT(UPPER(LEFT(inputStr,1)), LOWER(SUBSTRING(inputStr,2)));
END //
DELIMITER ;

-- Usage
SELECT ProperCase('kishor');  -- Output: Kishor
```

ðŸ“Œ **Use case**: Normalize customer names, email formatting, etc.

---

## 3. Business Logic Function

```sql
DROP FUNCTION IF EXISTS ApplyDiscount;

DELIMITER //
CREATE FUNCTION ApplyDiscount (
    price DECIMAL(10,2),
    discountRate DECIMAL(3,2)
)
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    RETURN price - (price * discountRate);
END //
DELIMITER ;

-- Usage
SELECT product_name, ApplyDiscount(price, 0.10) AS discounted_price
FROM products;
```

ðŸ“Œ **Use case**: Consistent discount rules across queries and applications.

---

## 4. Date Utility Function

```sql
DROP FUNCTION IF EXISTS AgeCalculator;

DELIMITER //
CREATE FUNCTION AgeCalculator (dob DATE)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN TIMESTAMPDIFF(YEAR, dob, CURDATE());
END //
DELIMITER ;

-- Usage
SELECT name, AgeCalculator(dob) AS age
FROM customers;
```

ðŸ“Œ **Use case**: Age calculation for HR, customer onboarding, analytics.

---

## 5. Validation Function

```sql
DROP FUNCTION IF EXISTS IsValidEmail;

DELIMITER //
CREATE FUNCTION IsValidEmail (email VARCHAR(255))
RETURNS BOOLEAN
DETERMINISTIC
BEGIN
    RETURN email REGEXP '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$';
END //
DELIMITER ;

-- Usage
SELECT email, IsValidEmail(email) AS is_valid
FROM users;
```

ðŸ“Œ **Use case**: Basic validation rules enforced at database level.

---

## 6. Masking Sensitive Data (Security-Oriented UDF)

```sql
DROP FUNCTION IF EXISTS MaskPhone;

DELIMITER //
CREATE FUNCTION MaskPhone (phone VARCHAR(15))
RETURNS VARCHAR(15)
DETERMINISTIC
BEGIN
    RETURN CONCAT('XXXXXX', RIGHT(phone, 4));
END //
DELIMITER ;

-- Usage
SELECT name, MaskPhone(phone) AS masked_phone
FROM customers;
```

ðŸ“Œ **Use case**: Hide sensitive details while still making data usable (GDPR/PII compliance).

---

## 7. Dropping a Function

```sql
DROP FUNCTION IF EXISTS AgeCalculator;
```

ðŸ“Œ **Use case**: Clean up old UDFs or replace with new versions.

---

# ðŸš€ Best Practices in Practice

* **Use Deterministic Functions** unless randomness is required.
* **Validate Input** inside functions to avoid unexpected errors.
* **Performance Tip**: Keep UDFs lightweight; avoid loops or heavy logic inside them.
* **Security Tip**: Useful for masking/anonymization in compliance-heavy environments.



