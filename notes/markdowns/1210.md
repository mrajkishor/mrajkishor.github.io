
# ðŸ”· Spring Data JPA and Repositories

## 1. Concept

Spring Data JPA is a **high-level abstraction over JPA (Java Persistence API)** that eliminates boilerplate DAO code by providing a consistent repository programming model. It integrates seamlessly with Spring Boot, Hibernate (default JPA provider), and other persistence frameworks.

At its core, Spring Data JPA allows developers to:

* Work with **domain entities** directly (no manual JDBC/SQL).
* Use **repositories** that generate implementations automatically at runtime.
* Express queries using **derived method names, JPQL, Criteria API, or native SQL**.
* Handle **pagination, sorting, transactions, and caching** with minimal configuration.

---

## 2. Repository Abstractions

Spring Data introduces a hierarchy of repository interfaces:

1. **`Repository<T, ID>`**

   * Marker interface for generic CRUD operations.

2. **`CrudRepository<T, ID>`**

   * Provides basic CRUD methods: `save`, `findById`, `delete`, `existsById`, etc.

3. **`PagingAndSortingRepository<T, ID>`**

   * Adds pagination (`Pageable`) and sorting (`Sort`) support.

4. **`JpaRepository<T, ID>`**

   * Extends all above, adds JPA-specific methods like `flush`, `saveAndFlush`, `deleteInBatch`.
   * This is the most commonly used base interface in enterprise projects.

---

## 3. Querying Mechanisms

Spring Data JPA supports multiple ways of querying:

1. **Query Derivation by Method Name**

   * Methods like `findByEmail(String email)` automatically translate to SQL:

     ```java
     interface UserRepository extends JpaRepository<User, Long> {
         Optional<User> findByEmail(String email);
         List<User> findByAgeGreaterThan(int age);
     }
     ```

2. **JPQL / Native Queries with `@Query`**

   ```java
   @Query("SELECT u FROM User u WHERE u.status = :status")
   List<User> findActiveUsers(@Param("status") String status);

   @Query(value = "SELECT * FROM users WHERE created_at > :date", nativeQuery = true)
   List<User> findRecentUsers(@Param("date") LocalDate date);
   ```

3. **Named Queries**

   * Defined at the entity level using `@NamedQuery`.
   * Spring Data looks them up automatically by method name.

4. **Criteria API and Specifications**

   * For **dynamic queries**, use `Specification<T>` or QueryDSL integration.

---

## 4. Advanced Features

### a) Pagination and Sorting

* Works seamlessly with REST APIs.

```java
Page<User> findByStatus(String status, Pageable pageable);
```

* Clients can request `/users?page=0&size=20&sort=age,desc`.

---

### b) Projections

* Fetch only required fields for optimization.

```java
interface UserSummary {
    String getName();
    String getEmail();
}
List<UserSummary> findByActiveTrue();
```

---

### c) Auditing

* Auto-populate fields like `createdDate`, `lastModifiedDate`, `createdBy`.
* Enable with `@EnableJpaAuditing`.

```java
@Entity
@EntityListeners(AuditingEntityListener.class)
class User {
    @CreatedDate LocalDateTime createdAt;
    @LastModifiedDate LocalDateTime updatedAt;
}
```

---

### d) Transactions

* Declarative with `@Transactional`.
* Repository methods are transactional by default for write operations.
* Supports **propagation, isolation levels, and rollback rules**.

---

### e) Entity Graphs and Fetch Strategies

* Avoid N+1 query problems by defining **fetch plans**.

```java
@EntityGraph(attributePaths = {"orders", "roles"})
List<User> findAll();
```

---

### f) Custom Repository Implementation

* If repository abstraction is insufficient, you can provide a manual implementation:

```java
interface UserRepositoryCustom {
    List<User> searchUsers(String keyword);
}

class UserRepositoryImpl implements UserRepositoryCustom {
    @PersistenceContext EntityManager em;
    public List<User> searchUsers(String keyword) {
        return em.createQuery("SELECT u FROM User u WHERE u.name LIKE :kw", User.class)
                 .setParameter("kw", "%" + keyword + "%")
                 .getResultList();
    }
}
```

---

## 5. Performance Considerations

* **Batch Inserts/Updates**: Use `saveAll()` and tune Hibernate settings (`hibernate.jdbc.batch_size`).
* **Caching**: Integrates with 2nd-level caches (Ehcache, Hazelcast, Redis).
* **Lazy vs Eager Loading**: Avoid unnecessary eager fetches, use DTO projections.
* **Streaming Results**: Use `Stream<T>` for handling large result sets.

---

## 6. Real-World Use Cases

* **Microservices with Spring Boot + JPA**: Persist domain aggregates with minimal DAO boilerplate.
* **E-Commerce**: Orders, Products, Customers with complex relationships (OneToMany, ManyToMany).
* **Banking/FinTech**: Transactional consistency with ACID guarantees.
* **Analytics**: Paginated and projected queries for dashboards.

---

## 7. Common Interview Questions

1. Difference between `CrudRepository`, `JpaRepository`, and `PagingAndSortingRepository`.
2. How does Spring Data JPA generate queries from method names?
3. How to optimize JPA queries to avoid N+1 select problem?
4. Explain projections in Spring Data JPA.
5. How would you implement dynamic filtering in repositories?
6. What are the trade-offs between `@Query` and derived queries?
7. How do entity graphs help improve performance?
8. Can you mix custom repository logic with auto-generated methods? How?
9. How does `@Transactional` behave at repository vs service layer?
10. What are the differences between native queries, JPQL, and Criteria API?

---

## Code example: 

**Spring Data JPA and Repositories**

Let's simulate a **Microservice for an E-Commerce system** (Users, Orders, Products). It will cover:

* Entity mappings
* Derived queries
* JPQL / Native queries
* Pagination & Sorting
* Projections
* Entity Graphs
* Custom Repository Implementation

---

# ðŸ›’ E-Commerce Microservice with Spring Data JPA

## 1. Entities

### `User`

```java
@Entity
@Table(name = "users")
@EntityListeners(AuditingEntityListener.class)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private List<Order> orders = new ArrayList<>();

    // getters and setters
}
```

---

### `Product`

```java
@Entity
@Table(name = "products")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private double price;

    @ManyToMany(mappedBy = "products")
    private List<Order> orders = new ArrayList<>();

    // getters and setters
}
```

---

### `Order`

```java
@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDateTime orderDate;
    private String status;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToMany
    @JoinTable(
        name = "order_products",
        joinColumns = @JoinColumn(name = "order_id"),
        inverseJoinColumns = @JoinColumn(name = "product_id")
    )
    private List<Product> products = new ArrayList<>();

    // getters and setters
}
```

---

## 2. Repositories

### `UserRepository`

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    // Derived query
    Optional<User> findByEmail(String email);

    // JPQL query
    @Query("SELECT u FROM User u WHERE SIZE(u.orders) > :minOrders")
    List<User> findActiveCustomers(@Param("minOrders") int minOrders);

    // Native query
    @Query(value = "SELECT * FROM users WHERE created_at > :date", nativeQuery = true)
    List<User> findNewUsers(@Param("date") LocalDateTime date);

    // Projection
    List<UserSummary> findByNameContaining(String keyword, Pageable pageable);
}
```

---

### `OrderRepository`

```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    // Derived query with pagination
    Page<Order> findByStatus(String status, Pageable pageable);

    // EntityGraph to avoid N+1 problem
    @EntityGraph(attributePaths = {"products", "user"})
    List<Order> findAllWithDetails();
}
```

---

### `ProductRepository`

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, ProductRepositoryCustom {

    // Derived query
    List<Product> findByPriceBetween(double min, double max);

    // Projection for performance
    List<ProductInfo> findByNameContainingIgnoreCase(String keyword);
}
```

---

## 3. Projections

### Interface-based projection

```java
public interface UserSummary {
    String getName();
    String getEmail();
}
```

### DTO-based projection

```java
public record ProductInfo(String name, double price) {}
```

---

## 4. Custom Repository Implementation

### Custom Interface

```java
public interface ProductRepositoryCustom {
    List<Product> searchProducts(String keyword);
}
```

### Implementation

```java
public class ProductRepositoryImpl implements ProductRepositoryCustom {

    @PersistenceContext
    private EntityManager em;

    @Override
    public List<Product> searchProducts(String keyword) {
        return em.createQuery("SELECT p FROM Product p WHERE LOWER(p.name) LIKE :kw", Product.class)
                 .setParameter("kw", "%" + keyword.toLowerCase() + "%")
                 .getResultList();
    }
}
```

---

## 5. Usage in Service Layer

```java
@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepo;
    private final UserRepository userRepo;
    private final ProductRepository productRepo;

    @Transactional
    public Order placeOrder(Long userId, List<Long> productIds) {
        User user = userRepo.findById(userId).orElseThrow();
        List<Product> products = productRepo.findAllById(productIds);

        Order order = new Order();
        order.setOrderDate(LocalDateTime.now());
        order.setStatus("PLACED");
        order.setUser(user);
        order.setProducts(products);

        return orderRepo.save(order);
    }

    public Page<Order> getOrders(String status, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("orderDate").descending());
        return orderRepo.findByStatus(status, pageable);
    }

    public List<ProductInfo> searchProducts(String keyword) {
        return productRepo.findByNameContainingIgnoreCase(keyword);
    }
}
```

---

## 6. Example REST Controller

```java
@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final OrderService orderService;

    @PostMapping("/place/{userId}")
    public ResponseEntity<Order> placeOrder(
            @PathVariable Long userId,
            @RequestBody List<Long> productIds) {
        return ResponseEntity.ok(orderService.placeOrder(userId, productIds));
    }

    @GetMapping
    public ResponseEntity<Page<Order>> getOrders(
            @RequestParam String status,
            @RequestParam int page,
            @RequestParam int size) {
        return ResponseEntity.ok(orderService.getOrders(status, page, size));
    }

    @GetMapping("/search-products")
    public ResponseEntity<List<ProductInfo>> searchProducts(@RequestParam String keyword) {
        return ResponseEntity.ok(orderService.searchProducts(keyword));
    }
}
```

---

# ðŸ”‘ Key Enterprise-Level Takeaways

1. **Domain-driven design (DDD)** â†’ Entities represent aggregates (`User`, `Order`, `Product`).
2. **Repositories** â†’ Abstract persistence, follow interface-driven design.
3. **Query derivation + JPQL + Native** â†’ Mix flexibility with simplicity.
4. **Pagination + Projection** â†’ Enterprise expects scalable patterns, not just CRUD.
5. **Entity Graphs** â†’ Critical for solving N+1 select issues.
6. **Custom Repositories** â†’ Show you can extend beyond the framework when needed.
7. **Transactional boundaries** â†’ Service layer controls consistency.
8. **DTOs and projections** â†’ Prevents overfetching and improves performance.

