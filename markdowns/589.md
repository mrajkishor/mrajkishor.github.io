
# ğŸ”„ Transactions in MongoDB: A Complete Guide

MongoDB has long been recognized for its flexibility, scalability, and developer-friendly document model. But one major feature that elevated it to enterprise-grade database status is its support for **ACID transactions** â€” a game-changer for applications that need atomicity across multiple operations or documents.

In this post, weâ€™ll explore what transactions are in MongoDB, how they work, when to use them, and best practices to avoid performance pitfalls.

---

## ğŸ§  What is a Transaction?

A **transaction** is a group of read and/or write operations that are executed **as a single atomic unit**. Either **all operations succeed**, or **none are applied** â€” ensuring **ACID** properties:

* **Atomicity** â€“ all-or-nothing execution
* **Consistency** â€“ data remains valid after the transaction
* **Isolation** â€“ operations appear isolated from other clients
* **Durability** â€“ committed changes persist even after failures

> âœ… In MongoDB, transactions ensure multiple documents or collections are **updated safely together**.

---

## ğŸ”„ Single vs Multi-document Operations

MongoDB writes to **a single document are atomic by default**.

```js
db.accounts.updateOne(
  { _id: "123" },
  { $inc: { balance: -100 } }
)
```

This operation is already atomic.

But for **multi-document operations** â€” for example, transferring money between accounts â€” youâ€™ll need transactions:

```js
session.startTransaction()
try {
  db.accounts.updateOne({ _id: "A" }, { $inc: { balance: -100 } }, { session })
  db.accounts.updateOne({ _id: "B" }, { $inc: { balance: 100 } }, { session })
  session.commitTransaction()
} catch (error) {
  session.abortTransaction()
}
```

---

## âš™ï¸ How to Use Transactions in MongoDB

MongoDB supports transactions in:

* **Replica sets** (since v4.0)
* **Sharded clusters** (since v4.2)

### ğŸ”§ Basic Syntax with Node.js

```js
const session = client.startSession()

try {
  session.startTransaction()
  
  await users.updateOne({ _id: 1 }, { $set: { status: "active" } }, { session })
  await orders.insertOne({ userId: 1, item: "Book" }, { session })

  await session.commitTransaction()
} catch (err) {
  await session.abortTransaction()
  throw err
} finally {
  await session.endSession()
}
```

> ğŸ§© The same pattern applies in other drivers like Java, Python, and Go.

---

## ğŸ”„ Retryable Writes vs Transactions

| Feature  | Retryable Write    | Multi-document Transaction        |
| -------- | ------------------ | --------------------------------- |
| Scope    | Single operation   | Multiple operations               |
| ACID     | No                 | Yes                               |
| Use case | Idempotent inserts | Consistency across many documents |

---

## ğŸ§ª Real-World Use Cases

* ğŸ¦ **Banking systems**: debit one account, credit another
* ğŸ›’ **E-commerce checkout**: create order, reduce inventory, log payment
* ğŸ“Š **Analytics**: write to multiple collections in sync
* ğŸ¢ **ERP/CRM apps**: updating multiple user-related documents

---

## ğŸ§± Important Considerations

| Constraint  | Description                                                               |
| ----------- | ------------------------------------------------------------------------- |
| Performance | Transactions are **slower** than single writes; use only when needed      |
| Duration    | Max transaction lifetime: **60 seconds**                                  |
| Size Limit  | 16MB document size per operation; \~1000 document changes recommended max |
| Locking     | Transactions hold locks â€” **can block other operations**                  |
| Sessions    | Transactions must be run inside an **active session**                     |
| Indexes     | Ensure involved collections are **indexed** for better performance        |

---

## ğŸ“Š Monitoring and Debugging

Use these tools to trace transactions:

* **MongoDB Atlas Performance Advisor**
* **MongoDB Profiler**:

```js
db.system.profile.find({ "command.startTransaction": { $exists: true } })
```

* **Mongo shell logs**:
  Check logs for `txnNumber`, `commitTransaction`, and `abortTransaction`

---

## âœ… Best Practices

| Best Practice                     | Why It Matters                       |
| --------------------------------- | ------------------------------------ |
| Keep transactions short           | Long transactions can lock resources |
| Use retries with backoff          | Transactions may fail on conflicts   |
| Prefer single-document operations | They are atomic and much faster      |
| Log failed/aborted transactions   | For debugging and recovery           |
| Use write concern `"majority"`    | To ensure durability on commit       |

---

## ğŸ”š Conclusion

MongoDB transactions bring **relational-style data safety** to NoSQL systems, allowing developers to confidently perform complex multi-document operations without risking data inconsistency. However, with great power comes responsibility: use transactions wisely and sparingly to maintain performance and scalability.

> ğŸ’¡ **Rule of thumb**: Prefer single-document operations when possible, use transactions only when necessary.

