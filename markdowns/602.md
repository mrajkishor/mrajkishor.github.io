
## üß† DSA Pattern Recognition Cheatsheet ‚Äì Interview-Oriented Guide

This mindmap helps you **quickly identify the right algorithm or pattern** based on input type and problem behavior. It's a must-have for LeetCode, Codeforces, and Enterprise interviews.



![alt text](dsa02873402hlhf.jpg)

---

### üü£ 1. **Array / String Inputs**
Choose your approach based on the problem type:

- **Sorted?** ‚Üí Use **Binary Search**, **Two Pointers**, or **Prefix Sums**
- **Optimization Problem?** ‚Üí Try **Sliding Window**, **Dynamic Programming**, or **Greedy**
- **Duplicates/Frequencies?** ‚Üí Go for **HashMap**, **HashSet**, or **Count Array**
- **Substrings/Subarrays?** ‚Üí Use **Sliding Window** or **Two Pointers**
- **Frequent min/max?** ‚Üí Use **Monotonic Queue**, **Deque**, or **Heap**
- **Subsets/Permutations?** ‚Üí Use **Backtracking**
- **Matching/Parsing (e.g. brackets)?** ‚Üí Use a **Stack**

---

### üîµ 2. **Graph Inputs**
Depends on whether the graph is weighted, directed, etc.

- **Unweighted Shortest Path** ‚Üí **BFS**
- **Weighted Shortest Path** ‚Üí **Dijkstra**, **Bellman-Ford**, or **A\***
- **Connected Components/Cycles** ‚Üí **DFS**, **Union-Find**
- **Topological Sort** ‚Üí **Kahn's Algorithm**, **DFS with visited**
- **Minimum Spanning Tree (MST)** ‚Üí **Kruskal**, **Prim**

---

### üü¢ 3. **Tree Inputs**
Great for recursion-based logic:

- **Traversals** ‚Üí **Inorder**, **Preorder**, **Postorder**, **Level Order**
- **Diameter / Balance Check** ‚Üí **Postorder traversal** with height tracking
- **LCA (Lowest Common Ancestor)** ‚Üí **DFS** or **Parent Map**

---

### üü† 4. **Linked List Inputs**

- **Cycle Detection** ‚Üí Use **Slow/Fast pointers** (Floyd‚Äôs Algorithm)
- **Reversal** ‚Üí Use three pointers: `prev`, `curr`, `next`
- **Find Middle / Intersection** ‚Üí Use **Two Pointers**

---

### üî¥ 5. **Dynamic Programming (DP)**

- **Optimal Substructure** ‚Üí Use **Memoization** or **Tabulation**
- **Knapsack / Subset problems** ‚Üí 1D/2D DP Table
- **Edit Distance, LCS** ‚Üí **DP Matrix**

### üî∂ Kadane‚Äôs Algorithm (Max Subarray ‚Äì Dynamic Programming)

- **Use case**: Find the maximum sum of a contiguous subarray in a given array.
- **Technique**: Track local max at each step and update global max.
- **Core Idea**:  

---

### üü° 6. **Range Queries / Updates**

- **Static Array** ‚Üí Use **Prefix Sums**
- **Dynamic Updates** ‚Üí Use **Segment Tree**, **Fenwick Tree**

---

### üü£ 7. **Bit Manipulation**

- **Subsets / XOR Logic** ‚Üí Use **Bit Masks**
- **Bitwise Checks** ‚Üí `&`, `|`, `^`, `~`, `>>`, `<<`, etc.

---

### üü§ 8. **Recursion Limits**

- Risk of stack overflow? ‚Üí Convert to **Iterative** using **Explicit Stack**

---

### üü¢ 9. **Top K / Least K Elements**

- Use **Heap** (Min/Max Heap) or **Quick Select**

---

### ‚ö´ 10. **Special Techniques**

- **Sliding Window** ‚Üí For **Subarrays** or **Fixed-size windows**
- **Monotonic Stack** ‚Üí **Next Greater/Smaller Element**
- **Greedy** ‚Üí When **local opt = global opt**
- **Trie** ‚Üí For **Prefix-based problems**

---

## ‚úÖ Final Note:

This cheatsheet is like a **DSA radar**:  
> ‚ÄúWhen I see _this type of input_ and _this kind of question_, I should try _this technique_.‚Äù

Use it to **reduce brute force** and move straight to **pattern-based efficient solutions**.


## üìå Additional Classic Patterns (Not in Mindmap)

### üî∂ Merge Intervals
- **Use case**: Overlapping intervals, time slots
- **Technique**: Sort + Merge if overlapping
- **Common Problems**: Merge Intervals, Insert Interval, Interval List Intersections

### üî∂ Cyclic Sort
- **Use case**: Arrays with elements 1 to N
- **Technique**: Place elements at correct indices
- **Common Problems**: Find Missing Number, Find Duplicate, All Duplicates in Array

### üî∂ In-Place Linked List Reversal
- **Use case**: Reverse a list without extra space
- **Technique**: Use `prev`, `curr`, `next` pointers
- **Common Problems**: Reverse Linked List, Reverse Every K Nodes, Reverse Sublist

### üî∂ Two Heaps
- **Use case**: Continuous median, window medians
- **Technique**: Maintain maxHeap + minHeap balance
- **Common Problems**: Median of Stream, Sliding Window Median

### üî∂ K-Way Merge
- **Use case**: Merge multiple sorted arrays/lists
- **Technique**: Use MinHeap with indices tracking
- **Common Problems**: Merge K Lists, Kth Smallest in Sorted Matrix

### üî∂ Modified Binary Search
- **Use case**: Problems like rotated arrays, next greatest, ceiling/floor
- **Technique**: Tweaked binary search
- **Common Problems**: Bitonic Array Search, Order-agnostic Search

### üî∂ Multi-threaded Patterns
- **Use case**: Concurrent execution, semaphores
- **Technique**: Thread synchronization & parallelism
- **Common Problems**: H2O Generator, FizzBuzz Multithreaded

---

## üìå Advanced & Niche Patterns (For Enterprise L5+ / System Design Depth)

### üî∂ Union-Find with Path Compression
- **Use case**: Fast group merging & lookup in disjoint sets.
- **Technique**: Combine `find()` and `union()` with path compression & union by rank.
- **Common Problems**: Graph Redundant Connection, Number of Provinces, Kruskal's MST

---

### üî∂ Lazy Segment Tree (with Propagation)
- **Use case**: Range updates + range queries in large arrays.
- **Technique**: Use a tree with delayed updates to optimize bulk operations.
- **Common Problems**: Range Sum with Update, Interval Cover Queries

---

### üî∂ Mo‚Äôs Algorithm (Sqrt Decomposition)
- **Use case**: Answer offline range queries efficiently.
- **Technique**: Sort queries cleverly and use two pointers to maintain frequency/count.
- **Common Problems**: Frequency in range, Sum of distinct elements in subarray

---

### üî∂ Suffix Automaton / Trie / Tree
- **Use case**: Advanced string problems (like substring counts, lex order, compression).
- **Technique**: Build a DAG/tree that encodes all substrings.
- **Common Problems**: Number of Distinct Substrings, Substring Matching in Large Text

---

### üî∂ Rolling Hash (Rabin-Karp)
- **Use case**: Efficient substring matching.
- **Technique**: Use modular arithmetic to compare hash values instead of substrings.
- **Common Problems**: Substring Hash Match, Detect Duplicate Substrings, Plagiarism Detection

---

### üî∂ Heavy-Light Decomposition (HLD)
- **Use case**: Tree queries like path sum, LCA with fast updates.
- **Technique**: Decompose the tree into paths and build segment trees on them.
- **Common Problems**: Path Queries on Trees, Online Tree Queries

---

### üî∂ Binary Lifting (for LCA & K-th Ancestor)
- **Use case**: Quickly jump ancestors or find LCA in O(logN).
- **Technique**: Preprocess jump table for 2^i jumps.
- **Common Problems**: LCA in Tree, Ancestor Queries

---

### üî∂ Bit Trie (Binary Trie)
- **Use case**: Max XOR pair, number range queries.
- **Technique**: Trie nodes store bits instead of characters.
- **Common Problems**: Maximum XOR of Two Numbers, XOR Queries



----


Here are 20 LeetCode questions that can significantly boost problem-solving skills:

> 1Ô∏è‚É£ Merge Intervals 
> 2Ô∏è‚É£ Koko Eating Bananas     
> 3Ô∏è‚É£ Search in Rotated Sorted Array      
> 4Ô∏è‚É£ Detect a Cycle in Linked List       
> 5Ô∏è‚É£ Word Search II      
> 6Ô∏è‚É£ Gas Station     
> 7Ô∏è‚É£ Sliding Window Maximum      
> 8Ô∏è‚É£ Coin Change     
> 9Ô∏è‚É£ Word Break      
> üîü Edit Distance      
> 1Ô∏è‚É£1Ô∏è‚É£ Trapping Rainwater     
> 1Ô∏è‚É£2Ô∏è‚É£ Largest Rectangle in a Histogram       
> 1Ô∏è‚É£3Ô∏è‚É£ Rod Cutting        
> 1Ô∏è‚É£4Ô∏è‚É£ Binary Tree Maximum Path Sum       
> 1Ô∏è‚É£5Ô∏è‚É£ Number of Distinct Islands     
> 1Ô∏è‚É£6Ô∏è‚É£ Rotten Oranges     
> 1Ô∏è‚É£7Ô∏è‚É£ Course Schedule II     
> 1Ô∏è‚É£8Ô∏è‚É£ Pacific Atlantic Water Flow        
> 1Ô∏è‚É£9Ô∏è‚É£ Cheapest Flights Within K Stops        
> 2Ô∏è‚É£0Ô∏è‚É£ Min Cost to Connect All Points     