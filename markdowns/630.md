

### 1. **Infix Notation**

* **Operators** are placed **between** operands.
* Common in mathematics.
* Needs **parentheses** to manage precedence.
* Example: `3 + 4 * 2`

---

### 2. **Prefix Notation (==Polish Notation==)**

* **Operator comes before** operands.
* No parentheses needed.
* Evaluated **right to left** using a stack.
* Example: `+ 3 * 4 2` (equivalent to `3 + 4 * 2`)

---

### 3. **Postfix Notation (==Reverse Polish Notation, RPN==)**

* **Operator comes after** operands.
* Evaluated **left to right** using a stack.
* Example: `3 4 2 * +`


---

**Number of valid conversions** **between the 3 expression notations**:
✅ **Infix**, **Prefix**, and **Postfix (RPN)**.



### 🧠 There are 3 formats → Possible 2-way conversions between them:

We can compute it as the number of **directed pairs (A → B)** where A ≠ B:

#### Total pairs = `3 × (3 - 1) = 6`

Here are all 6 possible conversions:

1. **Infix → Prefix**
2. **Infix → Postfix**
3. **Prefix → Infix**
4. **Prefix → Postfix**
5. **Postfix → Infix**
6. **Postfix → Prefix**

---

✅ **All 6 are valid and commonly used** in compiler design, stack evaluation problems, and expression parsers.


Let's take 

## 🔢 Original Infix Expression: 

- `A + B * C`

- `3 + 4 * 2`

---

### ✅ 1. Infix → Prefix

**Approach**:

1. **Reverse** the infix expression.
2. Swap `(` with `)` and vice versa.
3. Convert to **Postfix** (using standard stack logic).
4. Reverse the postfix to get **Prefix**.

---

#### Expression: `A + B * C`

#### Step-by-step:

* Reverse: `C * B + A`
* Swap `(` and `)`: (none)
* Convert to postfix: `C B * A +`
* Reverse postfix: `+ A * B C`

#### ✅ ** Prefix** : `+ A * B C`


---

#### ➤ Converted Prefix: `+ 3 * 4 2`

#### 🧮 Evaluation (Right to Left):

Stack:

* `2` → push
* `4` → push
* `*` → 4 × 2 = **8** → push
* `3` → push
* `+` → 3 + 8 = **11**

✅ **Answer**: `11`


---

```java
public class InfixToPrefix {
    public static String infixToPrefix(String infix) {
        StringBuilder reversed = new StringBuilder();
        for (int i = infix.length() - 1; i >= 0; i--) {
            char c = infix.charAt(i);
            if (c == '(') reversed.append(')');
            else if (c == ')') reversed.append('(');
            else reversed.append(c);
        }
        String postfix = InfixToPostfix.infixToPostfix(reversed.toString());
        return new StringBuilder(postfix).reverse().toString();
    }
}
```


---

### ✅ 2. Infix → Postfix

**Approach (Shunting Yard Algorithm)**:

1. Use a **stack** for operators and a **result string**.
2. For each token:

   * If operand → append to result.
   * If operator → pop stack till lower precedence or `(` found.
   * If `(` → push to stack.
   * If `)` → pop till `(`.
3. At end, pop remaining operators to result.

----

#### Expression: `A + B * C`

#### Step-by-step:

1. `A` → operand → output: `A`
2. `+` → push to stack
3. `B` → output: `A B`
4. `*` → higher precedence → push: `+ *`
5. `C` → output: `A B C`
6. Pop `*` then `+` → output: `A B C * +`

#### ✅ **Postfix**: `A B C * +`

---

#### ➤ Converted Postfix: `3 4 2 * +`

#### 🧮 Evaluation (Left to Right):

Stack:

* `3` → push
* `4` → push
* `2` → push
* `*` → 4 × 2 = **8** → push
* `+` → 3 + 8 = **11**

✅ **Answer**: `11`


----

```java
import java.util.*;

public class InfixToPostfix {
    public static String infixToPostfix(String s) {
        Stack<Character> stack = new Stack<>();
        StringBuilder output = new StringBuilder();

        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                output.append(c);
            } else if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(')
                    output.append(stack.pop());
                stack.pop(); // pop '('
            } else { // operator
                while (!stack.isEmpty() && precedence(c) <= precedence(stack.peek()))
                    output.append(stack.pop());
                stack.push(c);
            }
        }
        while (!stack.isEmpty())
            output.append(stack.pop());

        return output.toString();
    }

    static int precedence(char op) {
        return switch (op) {
            case '+', '-' -> 1;
            case '*', '/' -> 2;
            case '^' -> 3;
            default -> 0;
        };
    }
}
```




---

### ✅ 3. Prefix → Infix

**Approach**:

1. Traverse **right to left**.
2. If operand → push to stack.
3. If operator → pop two operands, form `"(op1 operator op2)"`, push back.

---

#### Expression: `+ A * B C`

#### Step-by-step (right to left):

1. `C` → push
2. `B` → push
3. `*` → pop B, C → push `(B * C)`
4. `A` → push
5. `+` → pop A, `(B * C)` → push `(A + (B * C))`

#### ✅ **Infix**: `(A + (B * C))`


---


#### ➤ Input: `+ 3 * 4 2`

#### ➤ Converted Infix: `(3 + (4 * 2))`

#### 🧮 Evaluation:

* `4 * 2 = 8`
* `3 + 8 = 11`

✅ **Answer**: `11`


---



```java
import java.util.*;

public class PrefixToInfix {
    public static String prefixToInfix(String s) {
        Stack<String> stack = new Stack<>();
        for (int i = s.length() - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (Character.isLetterOrDigit(c)) {
                stack.push(String.valueOf(c));
            } else {
                String op1 = stack.pop();
                String op2 = stack.pop();
                stack.push("(" + op1 + c + op2 + ")");
            }
        }
        return stack.pop();
    }
}
```

---

### ✅ 4. Prefix → Postfix

**Approach**:

1. Traverse **right to left**.
2. If operand → push.
3. If operator → pop two, form `op1 op2 operator`, push back.

---

#### Expression: `+ A * B C`

#### Step-by-step (right to left):

1. `C` → push
2. `B` → push
3. `*` → pop B, C → push `B C *`
4. `A` → push
5. `+` → pop A, `B C *` → push `A B C * +`

#### ✅ **Postfix**: `A B C * +`

---

#### ➤ Input: `+ 3 * 4 2`

#### ➤ Converted Postfix: `3 4 2 * +`

#### 🧮 Evaluation:

Same as step 2:

* `4 * 2 = 8`
* `3 + 8 = 11`

✅ **Answer**: `11`


---

```java
import java.util.*;

public class PrefixToPostfix {
    public static String prefixToPostfix(String s) {
        Stack<String> stack = new Stack<>();
        for (int i = s.length() - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (Character.isLetterOrDigit(c)) {
                stack.push(String.valueOf(c));
            } else {
                String op1 = stack.pop();
                String op2 = stack.pop();
                stack.push(op1 + op2 + c);
            }
        }
        return stack.pop();
    }
}
```



---

### ✅ 5. Postfix → Infix

**Approach**:

1. Traverse **left to right**.
2. If operand → push.
3. If operator → pop two, form `"(op1 operator op2)"`, push back.

---

#### Expression: `A B C * +`

#### Step-by-step (left to right):

1. `A` → push
2. `B` → push
3. `C` → push
4. `*` → pop B, C → push `(B * C)`
5. `+` → pop A, `(B * C)` → push `(A + (B * C))`

#### ✅ **Infix**: `(A + (B * C))`


---

#### ➤ Input: `3 4 2 * +`

#### ➤ Converted Infix: `(3 + (4 * 2))`

#### 🧮 Evaluation:

* `4 * 2 = 8`
* `3 + 8 = 11`

✅ **Answer**: `11`


---



```java
import java.util.*;

public class PostfixToInfix {
    public static String postfixToInfix(String s) {
        Stack<String> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                stack.push(String.valueOf(c));
            } else {
                String op2 = stack.pop();
                String op1 = stack.pop();
                stack.push("(" + op1 + c + op2 + ")");
            }
        }
        return stack.pop();
    }
}
```



---

### ✅ 6. Postfix → Prefix

**Approach**:

1. Traverse **left to right**.
2. If operand → push.
3. If operator → pop two, form `operator op1 op2`, push back.

---

#### Expression: `A B C * +`

#### Step-by-step (left to right):

1. `A` → push
2. `B` → push
3. `C` → push
4. `*` → pop B, C → push `* B C`
5. `+` → pop A, `* B C` → push `+ A * B C`

#### ✅ **Prefix** : `+ A * B C`

---

#### ➤ Input: `3 4 2 * +`

#### ➤ Converted Prefix: `+ 3 * 4 2`

#### 🧮 Evaluation:

Same as step 1:

* `4 * 2 = 8`
* `3 + 8 = 11`

✅ **Answer**: `11`


---



```java
import java.util.*;

public class PostfixToPrefix {
    public static String postfixToPrefix(String s) {
        Stack<String> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                stack.push(String.valueOf(c));
            } else {
                String op2 = stack.pop();
                String op1 = stack.pop();
                stack.push(c + op1 + op2);
            }
        }
        return stack.pop();
    }
}
```


----


Perfect! Now let's go through **all 6 expression conversions** from `3 + 4 * 2`, and for each one, include:

✅ Converted expression
✅ Step-by-step **evaluation with numbers**
✅ Final **result = 11**

---


## 🧾 Final Summary Table

| Conversion       | Converted Expression | Evaluated Result |
| ---------------- | -------------------- | ---------------- |
| Infix → Prefix   | `+ 3 * 4 2`          | ✅ `11`           |
| Infix → Postfix  | `3 4 2 * +`          | ✅ `11`           |
| Prefix → Infix   | `(3 + (4 * 2))`      | ✅ `11`           |
| Prefix → Postfix | `3 4 2 * +`          | ✅ `11`           |
| Postfix → Infix  | `(3 + (4 * 2))`      | ✅ `11`           |
| Postfix → Prefix | `+ 3 * 4 2`          | ✅ `11`           |


---

## C/Java Precedence Table 



## ✅ **Operator Precedence Table**

| **Precedence** | **Operator**    | **Description**                                   | **Associativity**                          |               |               |
| -------------- | --------------- | ------------------------------------------------- | ------------------------------------------ | ------------- | ------------- |
| 1              | `()`            | Parentheses (function call)                       | ==Left-to-Right==                              |               |               |
|                | `[]`            | Array Subscript (Square Brackets)                 |                                            |               |               |
|                | `.`             | Dot Operator                                      |                                            |               |               |
|                | `->`            | Structure Pointer Operator                        |                                            |               |               |
|                | `++`, `--`      | Postfix increment, decrement                      |                                            |               |               |
| 2              | `++`, `--`      | Prefix increment, decrement                       | **Right-to-Left**                              |               |               |
|                | `+`, `-`        | Unary plus, minus                                 |                                            |               |               |
|                | `!`, `~`        | Logical NOT, Bitwise complement                   |                                            |               |               |
|                | `(type)`        | Cast Operator                                     |                                            |               |               |
|                | `*`             | Dereference Operator                              |                                            |               |               |
|                | `&`             | Addressof Operator                                |                                            |               |               |
|                | `sizeof`        | Determine size in bytes                           |                                            |               |               |
| 3              | `*`, `/`, `%`   | Multiplication, division, modulus                 | ==Left-to-Right==                              |               |               |
| 4              | `+`, `-`        | Addition, subtraction                             | ==Left-to-Right==                              |               |               |
| 5              | `<<`, `>>`      | Bitwise shift left, Bitwise shift right           | ==Left-to-Right==                              |               |               |
| 6              | `<`, `<=`       | Relational less than, less than or equal to       | ==Left-to-Right==                              |               |               |
|                | `>`, `>=`       | Relational greater than, greater than or equal to |                                            |               |               |
| 7              | `==`, `!=`      | Relational is equal to, is not equal to |            ==Left-to-Right==                              |               |               |
| 8              | `&`             | Bitwise AND                                       | ==Left-to-Right==                              |               |               |
| 9              | `^`             | Bitwise exclusive OR                              | ==Left-to-Right==                              |               |               |
| 10             | `\|`              |  Bitwise inclusive OR                           | ==Left-to-Right== |               |
| 11             | `&&`            | Logical AND                                       | ==Left-to-Right==                              |               |               |
| 12             | `\|\|`             |    Logical OR                                                                                   | ==Left-to-Right== |
| 13             | `?:`            | Ternary conditional                               | **Right-to-Left**                              |               |               |
| 14             | `=` | Assignment                                        | **Right-to-Left**                              |               |               |
|                | `+=`, `-=`      | Addition, subtraction assignment               |                                            |               |               |
|                | `*=`, `/=`      | Multiplication, division assignment               |                                            |               |               |
|                | `%=`, `&=`      | Modulus, bitwise AND assignment                   |                                            |               |               |
|                | `^=`, `\|=`                                                       | Bitwise exclusive, inclusive OR assignment
|                | `<<=`, `>>=`    | Bitwise shift left, right assignment              |                                            |               |               |
| 15             | `,`             | Comma (expression separator)                      | ==Left-to-Right==                              |               |               |

---


### 🧠 Tips:

* **Parentheses** `()` override everything.
* **Right to Left** associativity is important for things like exponentiation and assignment.
* Exponentiation is not always supported in all languages as `^`; in Python, it’s `**`.

Great question!

### ✅ **Left to Right** vs **Right to Left** associativity:

These define the **order in which operators of the same precedence are evaluated** in an expression.

---

### 🔁 **Left to Right (L → R)**

* Evaluate **leftmost operator first**, then move right.
* Most common (used for `+`, `-`, `*`, `/`, etc.)

#### 🔍 Example:

```txt
5 - 3 - 1
```

* All `-` operators have the same precedence.
* Associativity is **Left to Right**, so:

```
(5 - 3) - 1 = 2 - 1 = 1 ✅
```

---

### 🔁 **Right to Left (R → L)**

* Evaluate **rightmost operator first**, then move left.
* Used for **assignment**, **exponentiation**, **unary ops**, etc.

#### 🔍 Example:

```txt
2 ^ 3 ^ 2
```

* `^` is **Right to Left**, so:

```
2 ^ (3 ^ 2) = 2 ^ 9 = 512 ✅
```

---

### 🧠 Simple Summary:

| Associativity | Evaluates First |
| ------------- | --------------- |
| Left to Right | Left operator   |
| Right to Left | Right operator  |

Let me know if you want visual diagrams or practice examples.
