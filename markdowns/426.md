

# ğŸ”„ Incremental Static Regeneration (ISR) in Next.js â€” The Best of Static and Dynamic Worlds

Next.js revolutionized frontend development by blending the **speed of static websites** with the **power of dynamic content**. One of its most powerful features is **Incremental Static Regeneration (ISR)** â€” a game-changer that allows you to **update static content after build time**, without needing to rebuild the entire site.

In this guide, youâ€™ll learn what ISR is, how it works, and when to use it effectively.

---

## ğŸ§  What is Incremental Static Regeneration (ISR)?

**ISR** enables you to:
- Pre-render static pages at **build time**
- **Update or regenerate pages** in the background as traffic comes in
- Serve updated content **without rebuilding the whole app**

> ISR lets you **retain the performance of static sites**, while also enabling **real-time content updates**.

---

## ğŸ“¦ How It Works

You use `getStaticProps` just like you would for Static Site Generation (SSG), but with an extra `revalidate` key:

```js
export async function getStaticProps() {
  const data = await fetchData();

  return {
    props: { data },
    revalidate: 60 // regenerate after 60 seconds
  };
}
```

This means:
- The page is **generated at build time**
- The **first request after 60 seconds** triggers a **background regeneration**
- The **new version** replaces the old version **seamlessly**

---

## ğŸ”‚ ISR Workflow

1. First request â†’ Page served from cache (fast)
2. Revalidation time hits (e.g., 60s)
3. Next request triggers **background regeneration**
4. New HTML is saved and used from that point forward

ğŸ’¡ All users see **the cached version** until the new one is ready.

---

## ğŸš€ Real Example: Blog

```js
// pages/blog/[slug].js

export async function getStaticProps({ params }) {
  const post = await fetchPostBySlug(params.slug);

  return {
    props: { post },
    revalidate: 300 // regenerate every 5 minutes
  };
}

export async function getStaticPaths() {
  const slugs = await fetchAllSlugs();

  return {
    paths: slugs.map(slug => ({ params: { slug } })),
    fallback: 'blocking'
  };
}
```

---

## ğŸ§ª `revalidate` Timing

The `revalidate` key defines the **interval in seconds** when the page becomes stale and eligible for regeneration.

```js
revalidate: 10 // every 10 seconds
```

---

## ğŸ” Fallback Modes for ISR

| `fallback` Value | Description                                                                 |
|------------------|-----------------------------------------------------------------------------|
| `false`          | Only pages returned in `paths` are built at build time; others = 404       |
| `true`           | Renders a fallback page while building the new one on the first request     |
| `'blocking'`     | Waits for the new page to be generated on the first request (no flicker)    |

âœ… Use `'blocking'` to prevent loading states.

---

## âš™ï¸ ISR vs SSR vs SSG

| Feature        | ISR                        | SSR                         | SSG                        |
|----------------|-----------------------------|------------------------------|-----------------------------|
| Speed          | Very fast (cached)          | Slower (on-demand rendering) | Fast (pre-built HTML)       |
| Data Freshness | Configurable via `revalidate` | Always fresh                 | Only fresh at build time    |
| SEO            | âœ… Excellent                 | âœ… Excellent                  | âœ… Excellent                 |
| Use Case       | Blogs, CMS, listings         | Auth dashboards, live data   | Static pages, docs          |

---

## ğŸ“ˆ When to Use ISR

âœ… Blog posts  
âœ… Product listings  
âœ… Marketing pages  
âœ… CMS content (WordPress, Strapi, etc.)  
âœ… Pages with moderate-to-low update frequency  

---

## âš ï¸ When *Not* to Use ISR

- Highly dynamic pages (like dashboards)
- Authenticated/user-specific content
- Pages with frequently changing query parameters

> Use `getServerSideProps` or client-side fetching for those.

---

## ğŸŒ Deployment Requirements

ISR works **out-of-the-box** with:
- **Vercel** (fully supported)
- **Netlify**, **AWS Lambda**, etc. (needs configuration)
- Not available for purely static hosting (e.g., GitHub Pages)

---

## âœ… Summary

| Feature            | Description                                                |
|--------------------|------------------------------------------------------------|
| API Used           | `getStaticProps` with `revalidate`                         |
| Purpose            | Update static pages without rebuilding the whole site      |
| Performance        | High (cached), with smart regeneration                     |
| Ideal for          | Blogs, CMS, marketplaces, marketing pages                  |
| SEO-Friendly       | âœ… Yes                                                     |
| Easy to Set Up     | âœ… Yes â€” just add `revalidate` to `getStaticProps`         |

---

## ğŸ§¾ Final Thoughts

**Incremental Static Regeneration (ISR)** bridges the gap between **speed** and **freshness**. It allows you to pre-render pages at build time, then **dynamically regenerate them** as needed â€” no need to choose between static and dynamic anymore.

> â€œWith ISR, your pages stay staticâ€¦ until they need to change.â€

