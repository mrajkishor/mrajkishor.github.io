

# **Reactive Repositories and MongoDB Integration**

---

## üöÄ Overview

In traditional Spring applications, data access is **blocking**, especially when using JDBC or synchronous ORM layers like JPA/Hibernate. Spring WebFlux, however, is designed to be **non-blocking and reactive from top to bottom**.

To support this, Spring Data provides **Reactive Repositories**, and MongoDB (via **Reactive MongoDB driver**) becomes a natural fit ‚Äî because MongoDB is inherently non-blocking and supports **event-driven streaming**.

> ‚úÖ At Enterprise-level scale, where low latency and high concurrency are critical, **non-blocking DB access** eliminates thread contention and improves system throughput dramatically.

---

## üì¶ What Are Reactive Repositories?

**Reactive Repositories** are part of the `spring-data` project and built on **Project Reactor**. Instead of returning `List<T>` or `Optional<T>`, they return:

* `Mono<T>` ‚Äì for **zero or one** result
* `Flux<T>` ‚Äì for **zero or more** results

They support full **CRUD operations**, **derived queries**, **custom queries**, **pagination**, and **streaming**, all in a **non-blocking, reactive** way.

---

## üß± Reactive MongoDB Architecture in Spring WebFlux

```text
[WebClient / API Call]
        ‚Üì
[Reactive Controller]
        ‚Üì
[Reactive Service Layer]
        ‚Üì
[ReactiveMongoRepository]
        ‚Üì
[Reactive MongoDB Driver]
        ‚Üì
[MongoDB (non-blocking socket I/O)]
```

---

## üîß Maven Dependency

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
</dependency>
```

---

## üß© Entity Definition Example

```java
@Document(collection = "users")
public class User {
    @Id
    private String id;
    private String name;
    private String email;
    private LocalDateTime createdAt;
    // getters & setters
}
```

---

## üõ† Reactive Repository Example

```java
public interface UserRepository extends ReactiveMongoRepository<User, String> {

    Mono<User> findByEmail(String email);                  // single item

    Flux<User> findByNameContainsIgnoreCase(String name);  // multiple items

    Flux<User> findAllByCreatedAtAfter(LocalDateTime time); // time-filtered

    Mono<Void> deleteByEmail(String email);                // void return
}
```

---

## ‚öôÔ∏è Service Layer (Reactive Style)

```java
@Service
public class UserService {
    private final UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public Mono<User> createUser(User user) {
        user.setCreatedAt(LocalDateTime.now());
        return repository.save(user);
    }

    public Flux<User> getRecentUsers() {
        return repository.findAllByCreatedAtAfter(LocalDateTime.now().minusDays(7));
    }
}
```

---

## üåê Controller Example (WebFlux + Reactive Mongo)

```java
@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService service;

    @PostMapping
    public Mono<User> create(@RequestBody User user) {
        return service.createUser(user);
    }

    @GetMapping("/recent")
    public Flux<User> getRecentUsers() {
        return service.getRecentUsers();
    }
}
```

---

## üîÑ Streaming Real-time Updates

MongoDB supports **tailable cursors** which let you **stream data reactively**, e.g., for:

* Real-time logs
* Chat messages
* Stock tickers

```java
@Tailable
@Query("{ createdAt: { $gt: ?0 } }")
Flux<User> streamNewUsers(LocalDateTime since);
```

---

## üìä Advantages of Reactive MongoDB Integration

| Feature                | Benefit                                        |
| ---------------------- | ---------------------------------------------- |
| Non-blocking I/O       | Improves scalability, avoids thread starvation |
| Backpressure support   | Prevents overloading consumers                 |
| Native JSON structure  | Perfect fit for document APIs                  |
| Tailable cursors       | Enables streaming use cases                    |
| Full reactive pipeline | Consistent model from DB to HTTP client        |

---

## ‚ö†Ô∏è Limitations and Considerations

| Concern                                     | Notes                                                  |
| ------------------------------------------- | ------------------------------------------------------ |
| No ACID across collections                  | Mongo is eventually consistent                         |
| No JPA-like ORM features                    | No `@OneToMany`, `@ManyToOne` (manual joins if needed) |
| Not suitable for heavy relational use cases | Use R2DBC with PostgreSQL if needed                    |
| Reactive debugging is harder                | Use `log()`, `StepVerifier`, or block only for testing |

---

## üß†  Use Cases

| Use Case                             | Reactive Mongo Fit?                               |
| ------------------------------------ | ------------------------------------------------- |
| ‚úÖ Real-time analytics dashboard      | Perfect with tailable cursors                     |
| ‚úÖ High-throughput event ingestion    | Fits with streaming microservices                 |
| ‚úÖ Search/filter APIs                 | Efficient with derived queries                    |
| ‚ùå Banking / Strict ACID transactions | Better suited with R2DBC + Postgres               |
| ‚úÖ IoT telemetry pipelines            | Works well with reactive ingestion & backpressure |

---

## üî¨ Testing Reactive Repositories

```java
@DataMongoTest
class UserRepositoryTest {

    @Autowired private UserRepository userRepository;

    @Test
    void testFindByEmail() {
        StepVerifier.create(userRepository.findByEmail("test@example.com"))
            .expectNextMatches(user -> user.getEmail().equals("test@example.com"))
            .verifyComplete();
    }
}
```

---

## ‚úÖ Summary

| Concept                 | Description                                    |
| ----------------------- | ---------------------------------------------- |
| ReactiveMongoRepository | Non-blocking MongoDB data access               |
| Mono<T>, Flux<T>        | Reactive types representing async data flow    |
| Tailable Cursor         | Streams data reactively from Mongo collections |
| Full-stack reactive     | From HTTP request to DB interaction            |
| Backpressure            | Helps avoid resource exhaustion in high load   |

---

## üß† Interview Insight

> "Spring WebFlux with ReactiveMongoRepository allows end-to-end asynchronous data pipelines. It helps build highly scalable microservices where traditional thread-per-request models would choke under concurrent I/O operations."

