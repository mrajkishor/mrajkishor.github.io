

# **Throwable Hierarchy – Error, Exception, RuntimeException**

---

## 🔰 Overview: Throwable – The Root of All Errors and Exceptions

In Java, **all exceptions and errors are objects** that inherit from the abstract class `java.lang.Throwable`.

The `Throwable` class has two **direct subclasses**:

* `Error` – for **serious system-level failures** that applications should not catch
* `Exception` – for **conditions applications might want to catch and recover from**

Understanding this hierarchy is vital for:

* Writing robust exception handling
* Designing custom exceptions
* Understanding compile-time vs runtime behavior
* Deciding **when to handle vs propagate** exceptions

---

## 🔷 `Throwable` Class – At the Root

```java
public class Throwable implements Serializable
```

### 🔹 Common methods in `Throwable`:

* `getMessage()` – returns detail message
* `printStackTrace()` – prints exception details
* `getCause()` – returns the cause (chained exceptions)
* `fillInStackTrace()` – useful for performance tuning in low-latency systems

---

## 🌳 The Throwable Hierarchy Tree

```
java.lang.Object
    └── java.lang.Throwable
          ├── java.lang.Exception  (Recoverable)
          │      └── java.lang.RuntimeException (Unchecked)
          └── java.lang.Error      (Non-recoverable)
```

---

## 🔴 1. `Error` – Serious Failures

### 📌 What is `Error`?

An `Error` indicates **critical problems in the JVM or system resources** that applications **should not try to catch or recover from**.

### 🔥 Examples:

* `OutOfMemoryError`
* `StackOverflowError`
* `NoClassDefFoundError`
* `InternalError`

### ⚠️ Characteristics:

* Unchecked (not checked at compile time)
* Usually beyond application control
* Often signals **bugs in the JVM or hardware constraints**
* Catching them is an **anti-pattern**, except for system monitoring/logging

```java
try {
    recursive();  // may cause StackOverflowError
} catch (StackOverflowError e) {
    System.err.println("Critical error: " + e);
}
```

---

## 🟡 2. `Exception` – Application-Level Problems

### 📌 What is `Exception`?

Exceptions represent **conditions that applications can catch and potentially recover from**.

There are two categories:

* **Checked Exceptions** – must be handled or declared
* **Unchecked Exceptions** – runtime issues that can be avoided with better logic

---

### ✅ 2.1 Checked Exceptions (compile-time)

#### Examples:

* `IOException`
* `SQLException`
* `FileNotFoundException`
* `ClassNotFoundException`

#### ⚙️ Compile-time enforcement:

```java
public void readFile(String path) throws IOException {
    Files.readAllLines(Path.of(path)); // Must handle or declare IOException
}
```

---

## 🟢 3. `RuntimeException` – Unchecked Exceptions

### 📌 What is `RuntimeException`?

A special subclass of `Exception` that represents **programming errors or misuse of API contracts**. These are **not checked at compile-time**.

> "If it's a bug that could be avoided by defensive programming, it's probably a `RuntimeException`."

---

### ✅ Common Subclasses of `RuntimeException`:

| Exception                   | Cause                              |
| --------------------------- | ---------------------------------- |
| `NullPointerException`      | Accessing methods/fields on `null` |
| `IndexOutOfBoundsException` | Invalid index in arrays/lists      |
| `IllegalArgumentException`  | Invalid parameter passed           |
| `IllegalStateException`     | Object not in expected state       |
| `ArithmeticException`       | Division by zero                   |
| `ClassCastException`        | Invalid type casting               |

---

## 📊 Best Practices

| Practice                                         | Reason                                              |
| ------------------------------------------------ | --------------------------------------------------- |
| **Don't catch `Error`**                          | It's beyond app's recovery ability                  |
| **Catch only specific exceptions**               | Avoid catch-all blocks like `catch (Exception e)`   |
| **Use checked exceptions to enforce contracts**  | e.g., DAO methods throwing `SQLException`           |
| **Use runtime exceptions for programmer errors** | Nulls, invalid states, etc.                         |
| **Design custom exceptions with hierarchy**      | e.g., `ApplicationException`, `ValidationException` |
| **Never swallow exceptions silently**            | Always log or rethrow                               |

---

## 🔁 Real-World Analogy

| Throwable Type     | Real-World Equivalent                                  |
| ------------------ | ------------------------------------------------------ |
| `Error`            | Earthquake – catastrophic, system must halt            |
| `Exception`        | Power outage – recoverable, requires fallback          |
| `RuntimeException` | Forgetting to lock a door – your fault, fix your logic |

---

## 🧠 Interview Insights

> "How do you decide whether to use a checked or unchecked exception?"

* **Use checked** if client code **must take an action** (e.g., retry, user alert).
* **Use unchecked** for **programmer mistakes** (e.g., nulls, contract violations).

> "Can you catch both `Exception` and `Error`?"

* Technically yes, but catching `Error` is **discouraged** unless you’re doing custom instrumentation or JVM monitoring.

---

## ✅ Summary

| Concept            | Description                              |
| ------------------ | ---------------------------------------- |
| `Throwable`        | Base class for all exceptions and errors |
| `Error`            | Unrecoverable problems; JVM-level        |
| `Exception`        | Recoverable issues in application        |
| `RuntimeException` | Unchecked, due to developer errors       |

