# **Bounded Contexts & Aggregates**  

## **ğŸš€ Introduction**  
Designing microservices requires a structured approach to ensure scalability, maintainability, and independence between services. **Domain-Driven Design (DDD)** provides essential concepts like **Bounded Contexts** and **Aggregates** to help **organize services logically and maintain a clean domain model**.  

In this blog, weâ€™ll cover:  
- **What is a Bounded Context?**  
- **Why Bounded Contexts are Important in Microservices**  
- **What is an Aggregate?**  
- **How Aggregates Ensure Consistency**  
- **Best Practices for Defining Bounded Contexts & Aggregates**  

---

## **ğŸ“Œ What is a Bounded Context?**  
A **Bounded Context** is a **logical boundary** within a domain where a specific model is applied. Each microservice represents a **separate bounded context** with **its own business logic, domain model, and database**.  

### **ğŸ”¹ Example: Bounded Contexts in an E-Commerce System**  
An e-commerce system may have the following **bounded contexts (separate microservices)**:  
- **Order Service** â†’ Manages orders, payments, and shipment tracking.  
- **Inventory Service** â†’ Tracks product availability and stock levels.  
- **Customer Service** â†’ Stores user profiles, addresses, and preferences.  
- **Payment Service** â†’ Processes transactions and refunds.  

Each service **defines its own data model** and doesnâ€™t share databases, ensuring **clear separation of concerns**.

### **ğŸ”¹ Why Bounded Contexts Are Important in Microservices**
âœ… **Avoids Data Coupling** â€“ Each service **owns its own data model** (no direct database sharing).  
âœ… **Improves Maintainability** â€“ Changes in one service donâ€™t affect others.  
âœ… **Enhances Scalability** â€“ Each bounded context can be **deployed and scaled independently**.  
âœ… **Reduces Complexity** â€“ Prevents a **distributed monolith** by enforcing service boundaries.  

---

## **ğŸ“Œ What is an Aggregate?**  
An **Aggregate** is a **group of related domain objects** that should be treated as a **single unit** when making changes.  

An **Aggregate Root** is the **main entity** that ensures consistency **within the aggregate**. External services can only interact with the **aggregate root** and not directly with internal objects.  

### **ğŸ”¹ Example: Aggregate in an Order Service**
The **Order Aggregate** consists of:  
- **Order (Aggregate Root)** â€“ The main entity representing an order.  
- **Order Items** â€“ Line items associated with an order.  
- **Payment Details** â€“ Stores payment confirmation details.  

ğŸ“Œ **Rule:** Any changes within the aggregate **must go through the aggregate root**.

#### **Java Example: Order Aggregate**
```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String status; // PENDING, PAID, SHIPPED
    
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "order")
    private List<OrderItem> items;
}
```
- The **Order** entity is the **Aggregate Root**.
- `OrderItem` objects are **part of the aggregate** and cannot be modified directly.

---

## **ğŸ“Œ How Aggregates Ensure Consistency in Microservices**
Aggregates **help maintain consistency** by enforcing the following rules:  

âœ… **Encapsulation:** Aggregates **hide internal details** from other services.  
âœ… **Transaction Boundary:** Changes to an aggregate should be **atomic** (use a single transaction).  
âœ… **Event-Driven Updates:** Instead of direct updates, aggregates **emit domain events** for external services.  

---

## **ğŸ“Œ Best Practices for Defining Bounded Contexts & Aggregates**
### **1ï¸âƒ£ Identify Business Capabilities as Bounded Contexts**
- Use **Event Storming** or **Domain Modeling** to define boundaries.
- Assign **clear ownership** of data to each microservice.

âœ… **Example:**
- **Customer Service** owns customer profiles.
- **Order Service** owns order history.
- **Payment Service** owns payment transactions.

---

### **2ï¸âƒ£ Keep Aggregates Small**
- An aggregate **should only include tightly related objects**.  
- Large aggregates **cause performance issues** and reduce flexibility.  

ğŸš« **Bad Example:**  
```java
@Entity
public class Order {
    @OneToMany(cascade = CascadeType.ALL)
    private List<Product> products; // âŒ Products should belong to Inventory Service
}
```
âœ… **Good Example:**  
```java
@Entity
public class Order {
    @OneToMany(cascade = CascadeType.ALL)
    private List<OrderItem> items; // âœ… OrderItems belong to the Order Aggregate
}
```

---

### **3ï¸âƒ£ Use Domain Events to Ensure Loose Coupling**
Instead of directly updating another microservice, **emit an event** when something changes.

#### **Example: OrderCreatedEvent (Kafka)**
```java
public class OrderCreatedEvent {
    private Long orderId;
    private Double totalAmount;
}
```
```java
kafkaTemplate.send("order-events", new OrderCreatedEvent(order.getId(), order.getTotal()));
```
- Other services (e.g., **Payment Service**) listen to this event and **react accordingly**.

---

### **4ï¸âƒ£ Ensure Aggregates Follow the Single Responsibility Principle**
ğŸš« **Bad Example (Too Many Responsibilities in One Aggregate)**  
```java
@Entity
public class Order {
    @OneToMany
    private List<OrderItem> items;

    @OneToOne
    private PaymentDetails payment; // âŒ Payment should belong to Payment Service

    @OneToOne
    private ShippingDetails shipping; // âŒ Shipping should belong to Shipment Service
}
```
âœ… **Good Example (Separate Responsibilities Across Bounded Contexts)**  
```java
@Entity
public class Order {
    @OneToMany
    private List<OrderItem> items;
}
```
- **PaymentDetails** exists in **Payment Service**.
- **ShippingDetails** exists in **Shipment Service**.

---

## **ğŸ“Œ Conclusion**
**Bounded Contexts and Aggregates** are **essential for designing microservices** that are **scalable, maintainable, and independent**.  

### **ğŸš€ Key Takeaways**
âœ… **Bounded Contexts define the boundaries of a microservice**, ensuring data ownership and separation.  
âœ… **Aggregates encapsulate related domain objects** and enforce consistency within their boundaries.  
âœ… **Aggregates should be small** to improve performance and flexibility.  
âœ… **Domain events (Kafka, RabbitMQ) should be used for inter-service communication** instead of direct service calls.  

---

# **Hands-on Guide: Implementing Bounded Contexts & Aggregates in Spring Boot**

In this guide, we will **implement Bounded Contexts and Aggregates** in a **Microservices-based E-Commerce system** using **Spring Boot**. We'll use **REST APIs, JPA for persistence, Kafka for event-driven communication, and Docker for service isolation**.

---

## **ğŸ“Œ Project Overview**
### **ğŸ”¹ Microservices Architecture**
We will implement **three microservices**, each representing a **Bounded Context**:

1. **Order Service** â†’ Manages orders, order items, and emits `OrderCreatedEvent`.
2. **Payment Service** â†’ Listens for `OrderCreatedEvent`, processes payments, and emits `PaymentSuccessEvent`.
3. **Inventory Service** â†’ Listens for `PaymentSuccessEvent` and updates stock.

ğŸ“Œ **Key Concepts Covered:**
âœ… **Bounded Contexts** â€“ Each service has its own **database and domain model**.  
âœ… **Aggregates** â€“ **Order Aggregate** in `OrderService`.  
âœ… **Event-Driven Communication** â€“ Services **emit and listen to events using Kafka**.  

---

## **ğŸ“Œ Step 1: Setting Up Order Service (Bounded Context: Orders)**
### **ğŸ”¹ Define the Order Aggregate**
- **Order (Aggregate Root)**
- **OrderItem (Part of the Aggregate)**

#### **ğŸ“ Order Entity (Aggregate Root)**
```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String status; // PENDING, PAID, SHIPPED
    private Double totalAmount;

    @OneToMany(cascade = CascadeType.ALL, mappedBy = "order")
    private List<OrderItem> items;

    // Constructor, Getters & Setters
}
```

#### **ğŸ“ OrderItem Entity**
```java
@Entity
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String productName;
    private Integer quantity;
    private Double price;

    @ManyToOne
    @JoinColumn(name = "order_id")
    private Order order;
}
```
- `Order` is the **Aggregate Root**.
- `OrderItem` is **part of the Order Aggregate** and cannot be modified independently.

---

### **ğŸ”¹ Define the Order Repository**
```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
}
```

---

### **ğŸ”¹ Publish an Event When an Order is Created**
Instead of calling the `Payment Service` directly, we **emit an event** using **Kafka**.

#### **ğŸ“ OrderCreatedEvent**
```java
public class OrderCreatedEvent {
    private Long orderId;
    private Double totalAmount;
}
```

#### **ğŸ“ Kafka Producer to Publish Event**
```java
@Service
public class OrderService {
    @Autowired private OrderRepository orderRepository;
    @Autowired private KafkaTemplate<String, OrderCreatedEvent> kafkaTemplate;

    public Order createOrder(Order order) {
        order.setStatus("PENDING");
        Order savedOrder = orderRepository.save(order);
        
        // Emit event to Kafka
        kafkaTemplate.send("order-events", new OrderCreatedEvent(savedOrder.getId(), savedOrder.getTotalAmount()));
        
        return savedOrder;
    }
}
```
âœ… **Instead of making a direct API call to Payment Service, we publish `OrderCreatedEvent` to Kafka.**

---

## **ğŸ“Œ Step 2: Setting Up Payment Service (Bounded Context: Payments)**
- **Listens for `OrderCreatedEvent`** from Kafka.
- **Processes the payment** and **emits `PaymentSuccessEvent`**.

### **ğŸ”¹ Kafka Consumer in Payment Service**
```java
@Service
public class PaymentService {
    @Autowired private KafkaTemplate<String, PaymentSuccessEvent> kafkaTemplate;

    @KafkaListener(topics = "order-events", groupId = "payment-group")
    public void processPayment(OrderCreatedEvent event) {
        System.out.println("Processing payment for Order ID: " + event.getOrderId());

        // Payment logic (simulated)
        boolean paymentSuccess = true;

        if (paymentSuccess) {
            kafkaTemplate.send("payment-events", new PaymentSuccessEvent(event.getOrderId(), "SUCCESS"));
        }
    }
}
```

âœ… **Payment Service listens to `OrderCreatedEvent`, processes payment, and emits `PaymentSuccessEvent`.**

---

## **ğŸ“Œ Step 3: Setting Up Inventory Service (Bounded Context: Inventory)**
- **Listens for `PaymentSuccessEvent`** from Kafka.
- **Updates stock levels**.

### **ğŸ”¹ Kafka Consumer in Inventory Service**
```java
@Service
public class InventoryService {
    @KafkaListener(topics = "payment-events", groupId = "inventory-group")
    public void updateStock(PaymentSuccessEvent event) {
        System.out.println("Updating inventory for Order ID: " + event.getOrderId());
    }
}
```

âœ… **Inventory Service listens for `PaymentSuccessEvent` and updates stock levels accordingly.**

---

## **ğŸ“Œ Step 4: Setting Up Kafka for Event-Driven Communication**
### **ğŸ”¹ Kafka Configuration (`application.yml`)**
```yaml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: order-group
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
```
âœ… **Each microservice has a different `group-id`, ensuring independent message processing.**

---

## **ğŸ“Œ Step 5: Running Services with Docker**
Weâ€™ll containerize our services using **Docker**.

### **ğŸ”¹ Dockerfile for Order Service**
```dockerfile
FROM openjdk:17-jdk-slim
COPY target/order-service.jar order-service.jar
ENTRYPOINT ["java", "-jar", "/order-service.jar"]
```
âœ… **Repeat this for `payment-service` and `inventory-service`.**

---

### **ğŸ”¹ Docker-Compose File**
```yaml
version: '3'
services:
  zookeeper:
    image: wurstmeister/zookeeper:latest
    ports:
      - "2181:2181"

  kafka:
    image: wurstmeister/kafka:latest
    ports:
      - "9092:9092"
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
    depends_on:
      - zookeeper

  order-service:
    build: ./order-service
    ports:
      - "8081:8081"
    depends_on:
      - kafka

  payment-service:
    build: ./payment-service
    ports:
      - "8082:8082"
    depends_on:
      - kafka

  inventory-service:
    build: ./inventory-service
    ports:
      - "8083:8083"
    depends_on:
      - kafka
```
âœ… **This configures Zookeeper, Kafka, and all three microservices in containers.**

---

## **ğŸ“Œ Expected Workflow**
1ï¸âƒ£ **Order Service creates an order** and **publishes `OrderCreatedEvent`** to Kafka.  
2ï¸âƒ£ **Payment Service listens for `OrderCreatedEvent`**, processes payment, and emits `PaymentSuccessEvent`.  
3ï¸âƒ£ **Inventory Service listens for `PaymentSuccessEvent`** and updates stock levels.  

âœ… **This ensures Bounded Contexts communicate asynchronously without direct dependencies!**

---

## **ğŸ“Œ Final Thoughts**
### **ğŸš€ What We Achieved**
âœ… **Designed microservices with Bounded Contexts & Aggregates.**  
âœ… **Used Event-Driven Architecture with Kafka.**  
âœ… **Implemented asynchronous microservice communication.**  
âœ… **Deployed using Docker & Docker Compose.**  

---

# **Extending Microservices with Distributed Tracing & Observability (Zipkin, Jaeger)**  

## **ğŸš€ Introduction**  
When microservices communicate asynchronously using **Kafka**, debugging failures and monitoring performance **become challenging**. To **track service-to-service interactions**, we use **Distributed Tracing and Observability tools** like:  
- **Zipkin** â€“ Distributed tracing system for monitoring microservices.  
- **Jaeger** â€“ OpenTelemetry-based tracing tool for debugging microservices.  
- **Prometheus & Grafana** â€“ Metrics collection and visualization for system performance.  

ğŸ“Œ **In this guide, we will:**  
âœ… **Integrate Zipkin and Jaeger into our microservices.**  
âœ… **Enable Spring Boot to generate tracing IDs for requests.**  
âœ… **Visualize traces in Zipkin UI & Jaeger UI.**  
âœ… **Monitor microservices performance using Prometheus & Grafana.**  

---

## **ğŸ“Œ Step 1: Setting Up Distributed Tracing with Zipkin**
### **ğŸ”¹ Add Dependencies for Zipkin in Each Microservice**
In each microservice (`order-service`, `payment-service`, `inventory-service`), add the following dependencies in `pom.xml`:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-sleuth-zipkin</artifactId>
</dependency>
```

**What happens here?**
- **Spring Cloud Sleuth** automatically **generates tracing IDs** for requests.
- **Zipkin integration** ensures that traces are sent to the **Zipkin server**.

---

### **ğŸ”¹ Configure Zipkin in `application.yml`**
In each microservice, update `application.yml`:

```yaml
spring:
  application:
    name: order-service
  zipkin:
    base-url: http://zipkin:9411
  sleuth:
    sampler:
      probability: 1.0  # Sample 100% of requests for tracing
```

---

### **ğŸ”¹ Run Zipkin using Docker**
Add **Zipkin container** in `docker-compose.yml`:

```yaml
zipkin:
  image: openzipkin/zipkin
  ports:
    - "9411:9411"
```

âœ… **Zipkin UI is now available at** `http://localhost:9411`.

---

### **ğŸ”¹ Testing Zipkin Integration**
Run your microservices and send a request:

```bash
curl -X POST http://localhost:8081/orders
```

Now, go to **Zipkin UI (`http://localhost:9411`)**, and you should see a trace with:
- **Order Service**
- **Payment Service**
- **Inventory Service**

âœ… **Zipkin now tracks the entire microservice request flow!** ğŸ‰  

---

## **ğŸ“Œ Step 2: Setting Up Jaeger for Advanced Tracing**
Jaeger is an alternative to Zipkin but offers **better OpenTelemetry support**.

### **ğŸ”¹ Add Jaeger Dependencies**
In `pom.xml`, replace **Zipkin** with **Jaeger**:

```xml
<dependency>
    <groupId>io.opentracing.contrib</groupId>
    <artifactId>opentracing-spring-jaeger-web-starter</artifactId>
    <version>3.3.0</version>
</dependency>
```

---

### **ğŸ”¹ Configure Jaeger in `application.yml`**
```yaml
spring:
  application:
    name: order-service
  jaeger:
    service-name: order-service
    sender:
      agent-host: jaeger
      agent-port: 6831
```

---

### **ğŸ”¹ Run Jaeger with Docker**
Add **Jaeger container** to `docker-compose.yml`:

```yaml
jaeger:
  image: jaegertracing/all-in-one:latest
  ports:
    - "16686:16686"  # Jaeger UI
    - "6831:6831/udp" # Jaeger agent
```

âœ… **Jaeger UI is available at** `http://localhost:16686`.  

Now, when requests pass through microservices, **Jaeger tracks the flow with spans and latency metrics**.

---

## **ğŸ“Œ Step 3: Adding Metrics with Prometheus & Grafana**
### **ğŸ”¹ Add Micrometer & Prometheus Dependencies**
In `pom.xml`, add:

```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

---

### **ğŸ”¹ Configure Prometheus in `application.yml`**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health, metrics, prometheus
  metrics:
    export:
      prometheus:
        enabled: true
```

âœ… **Each microservice now exposes Prometheus metrics at** `http://localhost:8081/actuator/prometheus`.

---

### **ğŸ”¹ Run Prometheus & Grafana with Docker**
Add **Prometheus and Grafana** to `docker-compose.yml`:

```yaml
prometheus:
  image: prom/prometheus
  ports:
    - "9090:9090"
  volumes:
    - ./prometheus.yml:/etc/prometheus/prometheus.yml

grafana:
  image: grafana/grafana
  ports:
    - "3000:3000"
```

âœ… **Grafana UI is available at** `http://localhost:3000`.

---

### **ğŸ”¹ Configure Prometheus to Scrape Metrics**
Create a **`prometheus.yml`** file:

```yaml
global:
  scrape_interval: 5s
scrape_configs:
  - job_name: 'order-service'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['order-service:8081']

  - job_name: 'payment-service'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['payment-service:8082']

  - job_name: 'inventory-service'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['inventory-service:8083']
```

âœ… **Prometheus now collects metrics from all microservices!**

---

## **ğŸ“Œ Step 4: Visualizing Data**
### **ğŸ”¹ View Tracing in Zipkin**
Go to `http://localhost:9411`, filter by `order-service`, and check **end-to-end request tracing**.

### **ğŸ”¹ View Tracing in Jaeger**
Go to `http://localhost:16686`, select a service (e.g., `order-service`), and view **latency analysis**.

### **ğŸ”¹ View Metrics in Prometheus**
Visit `http://localhost:9090`, search for **Spring Boot metrics**, e.g.:
```plaintext
http_server_requests_seconds_count
```

### **ğŸ”¹ Create Dashboards in Grafana**
1. Go to **`http://localhost:3000`**, login (`admin/admin`).
2. Add Prometheus as a data source.
3. Import a **Spring Boot monitoring dashboard**.
4. View **CPU, Memory, and API Response Time metrics**.

âœ… **Grafana now visualizes your microservices' performance in real time!**

---

## **ğŸ“Œ Final Workflow**
1ï¸âƒ£ **Order Service receives a request**, generates a **trace ID**, and starts a transaction.  
2ï¸âƒ£ **Kafka propagates the trace ID** to **Payment Service**, which **logs the trace**.  
3ï¸âƒ£ **Payment Service emits an event**, which **Inventory Service processes with tracing enabled**.  
4ï¸âƒ£ **Zipkin/Jaeger track the request flow** across microservices.  
5ï¸âƒ£ **Prometheus collects metrics**, and **Grafana visualizes performance dashboards**.

âœ… **You can now trace transactions, measure API performance, and monitor microservices efficiently!** ğŸ‰  

---

## **ğŸ“Œ Conclusion**
### **ğŸš€ What We Achieved**
âœ… **Implemented distributed tracing with Zipkin & Jaeger.**  
âœ… **Enabled service-to-service request tracking in Kafka-based microservices.**  
âœ… **Integrated Prometheus & Grafana for monitoring performance.**  
âœ… **Configured Docker for easy deployment of monitoring tools.**  

ğŸ”¹ **Next Steps:**  
- Add **Log Aggregation with ELK Stack (Elasticsearch, Logstash, Kibana)**.  
- Implement **alerting with Prometheus AlertManager**.  
- Optimize **trace sampling for production environments**.  

---

# **Log Aggregation & Alerting in Microservices with ELK Stack & Prometheus AlertManager**

## **ğŸš€ Introduction**  
When running microservices in production, debugging failures and monitoring logs efficiently is **crucial**. Since each microservice runs **independently**, logs are scattered across multiple instances, making it **hard to trace errors**.

### **ğŸ“Œ Why Log Aggregation & Alerting?**
âœ… **Centralized Logging** â€“ Collect logs from all microservices in one place.  
âœ… **Structured Log Storage** â€“ Use **Elasticsearch** to store logs efficiently.  
âœ… **Real-time Log Analysis** â€“ View logs in **Kibana** with filtering & search.  
âœ… **Automated Alerts** â€“ Configure **Prometheus AlertManager** to notify on errors.  

---

## **ğŸ“Œ Step 1: Setting Up ELK Stack (Elasticsearch, Logstash, Kibana)**
The **ELK Stack** consists of:
- **Elasticsearch** â€“ Stores structured logs.
- **Logstash** â€“ Collects and processes logs.
- **Kibana** â€“ Provides a UI for searching & visualizing logs.

### **ğŸ”¹ Add Logback Logging in Each Microservice**
To send logs from **Spring Boot microservices** to ELK, update `pom.xml`:

```xml
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>6.6</version>
</dependency>
```

---

### **ğŸ”¹ Configure Logback to Send Logs to Logstash**
Create `logback-spring.xml` in `src/main/resources/`:

```xml
<configuration>
    <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
        <destination>logstash:5044</destination>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder" />
    </appender>

    <root level="INFO">
        <appender-ref ref="LOGSTASH" />
    </root>
</configuration>
```
âœ… **This sends structured JSON logs to Logstash at port `5044`.**

---

### **ğŸ”¹ Add ELK Stack to Docker Compose**
Modify `docker-compose.yml`:

```yaml
elasticsearch:
  image: docker.elastic.co/elasticsearch/elasticsearch:7.17.0
  container_name: elasticsearch
  environment:
    - discovery.type=single-node
  ports:
    - "9200:9200"

logstash:
  image: docker.elastic.co/logstash/logstash:7.17.0
  container_name: logstash
  ports:
    - "5044:5044"
  volumes:
    - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf

kibana:
  image: docker.elastic.co/kibana/kibana:7.17.0
  container_name: kibana
  ports:
    - "5601:5601"
```

âœ… **Elasticsearch (`9200`), Logstash (`5044`), and Kibana (`5601`) are now configured.**

---

### **ğŸ”¹ Configure Logstash to Ingest Logs into Elasticsearch**
Create a **Logstash configuration file** (`logstash.conf`):

```plaintext
input {
  tcp {
    port => 5044
    codec => json
  }
}

filter {
  mutate {
    add_field => { "service" => "order-service" }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "microservice-logs"
  }
  stdout { codec => rubydebug }
}
```

âœ… **Logstash will collect logs from microservices and send them to Elasticsearch.**

---

### **ğŸ”¹ Running ELK Stack**
```bash
docker-compose up -d
```
âœ… **Visit Kibana UI at** `http://localhost:5601`, go to **Discover**, and search for logs!

---

## **ğŸ“Œ Step 2: Configuring Prometheus AlertManager**
Prometheus **collects application metrics**, and **AlertManager sends alerts** for critical events.

### **ğŸ”¹ Add AlertManager to Docker Compose**
Modify `docker-compose.yml`:

```yaml
alertmanager:
  image: prom/alertmanager
  ports:
    - "9093:9093"
  volumes:
    - ./alertmanager.yml:/etc/alertmanager/alertmanager.yml
```
âœ… **AlertManager runs on `http://localhost:9093`**.

---

### **ğŸ”¹ Configure Alerts in Prometheus**
Modify `prometheus.yml`:

```yaml
global:
  scrape_interval: 5s

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - "alertmanager:9093"

rule_files:
  - "alert-rules.yml"

scrape_configs:
  - job_name: 'order-service'
    static_configs:
      - targets: ['order-service:8081']
```

---

### **ğŸ”¹ Define Alert Rules**
Create `alert-rules.yml`:

```yaml
groups:
  - name: High Error Rate
    rules:
      - alert: HighErrorRate
        expr: rate(http_server_requests_seconds_count{status="500"}[5m]) > 10
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected in Order Service"
```
âœ… **If more than 10 errors occur per minute, an alert is triggered.**

---

### **ğŸ”¹ Configure AlertManager to Send Alerts**
Create `alertmanager.yml`:

```yaml
route:
  receiver: "email-alerts"

receivers:
  - name: "email-alerts"
    email_configs:
      - to: "admin@example.com"
        from: "monitoring@example.com"
        smarthost: "smtp.gmail.com:587"
        auth_username: "your-email@gmail.com"
        auth_password: "your-password"
```
âœ… **Alerts will now be sent to your email.**

---

## **ğŸ“Œ Step 3: Testing the Setup**
### **ğŸ”¹ Trigger a High-Error Scenario**
Manually force an error in `OrderService`:

```java
@GetMapping("/force-error")
public ResponseEntity<String> throwError() {
    throw new RuntimeException("Manual error for testing alerts");
}
```

ğŸš€ **Now, hit the endpoint multiple times:**
```bash
curl http://localhost:8081/force-error
```

1ï¸âƒ£ **Elasticsearch logs the errors.**  
2ï¸âƒ£ **Kibana visualizes the logs in real-time.**  
3ï¸âƒ£ **Prometheus detects high error rates.**  
4ï¸âƒ£ **AlertManager triggers an alert.**  
5ï¸âƒ£ **Email notification is sent to `admin@example.com`.**  

âœ… **Your microservices now have centralized logging & alerting!** ğŸ‰  

---

## **ğŸ“Œ Step 4: Viewing Logs & Alerts**
### **ğŸ”¹ View Logs in Kibana**
1. Open `http://localhost:5601`
2. Go to **Discover** â†’ Select `microservice-logs`
3. Search for `"ERROR"` logs to debug failures.

---

### **ğŸ”¹ View Alerts in Prometheus**
1. Open `http://localhost:9090`
2. Go to **Alerts** â†’ Check if **HighErrorRate** alert is triggered.

---

### **ğŸ”¹ View Alerts in AlertManager**
1. Open `http://localhost:9093`
2. See active alerts under **Silences & Alerts**.

---

## **ğŸ“Œ Final Workflow**
1ï¸âƒ£ **Microservices send logs to Logstash.**  
2ï¸âƒ£ **Logstash processes logs & stores them in Elasticsearch.**  
3ï¸âƒ£ **Kibana visualizes logs with filtering & search.**  
4ï¸âƒ£ **Prometheus monitors error rates & system metrics.**  
5ï¸âƒ£ **AlertManager sends alerts via email when errors spike.**  

âœ… **You can now monitor microservices, debug issues faster, and receive automated alerts!** ğŸ‰  

---

## **ğŸ“Œ Conclusion**
### **ğŸš€ What We Achieved**
âœ… **Set up centralized logging with ELK Stack (Elasticsearch, Logstash, Kibana).**  
âœ… **Configured structured logging in Spring Boot microservices.**  
âœ… **Implemented real-time alerts with Prometheus & AlertManager.**  
âœ… **Sent alerts via email for critical errors.**  

ğŸ”¹ **Next Steps:**  
- Add **Slack or Discord notifications** for alerts.  
- Implement **Distributed Log Correlation using Trace IDs**.  
- Use **Grafana for real-time log & metric visualization.**  

