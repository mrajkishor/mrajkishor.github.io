
# üöÄ Frequent Min/Max in Window ‚Äì The Monotonic Queue Pattern


> Frequent min/max in window?   
>    ‚Üí Use Monotonic Queue, Deque, or Heap




## üìå Problem Pattern

You‚Äôre given a **sliding window of size `k`** and a list of numbers. For every position of the window, you must find the **maximum** or **minimum** value in that window. This problem pattern appears frequently in coding interviews (e.g., **Sliding Window Maximum**, **Minimum in Sliding Window**, **Longest Subarray with Limit**).

---

## ‚ùì Why Can't We Use Naive Approach?

For each window, you could scan the `k` elements to find the max/min.

* **Time Complexity**: O(n \* k) ‚Äî too slow for large inputs.

---

## ‚úÖ Optimized Pattern: Use a **Monotonic Queue** or **Deque**

### üëâ What is a Monotonic Queue?

It‚Äôs a **double-ended queue (deque)** that maintains its elements in **increasing or decreasing order**. This helps in:

* Constant time access to max/min
* Efficient discard of outdated or irrelevant values


> A monotonic queue maintains elements in a specific order (either non-decreasing or non-increasing), while a sorted queue maintains elements in a specific order (ascending or descending). Monotonic queues achieve this order through dynamic adjustments during insertion and removal, whereas sorted queues typically require a separate sorting operation. 


---

## üß† Core Intuition

For **maximum in a window**, maintain a **monotonically decreasing deque** ‚Äî the front always has the largest.

For **minimum**, use a **monotonically increasing deque** ‚Äî the front has the smallest.

### Rules:

1. **Remove out-of-window indices** from the front.
2. **Maintain monotonicity** while inserting:

   * For max: Pop from back while `nums[i] > nums[deque[-1]]`
   * For min: Pop from back while `nums[i] < nums[deque[-1]]`
3. **Add current index** to deque.
4. **Output from front** of deque (which holds max/min).

---

## üìò Example: Sliding Window Maximum (LeetCode 239)

> YT: https://www.youtube.com/watch?v=DfljaUwZsOk           
> This problem solution demonstrates why in some problems we must chose deque over stack. See 9:08 of video.  

**Input**:
`nums = [1,3,-1,-3,5,3,6,7], k = 3`

**Output**:
`[3,3,5,5,6,7]`

### üí° Java Code Using Monotonic Deque:

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque<>();
    int[] result = new int[nums.length - k + 1];
    int ri = 0;

    for (int i = 0; i < nums.length; i++) {
        // Remove indices outside the window
        if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }

        // Maintain decreasing order in deque
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }

        deque.offerLast(i);

        // Capture result starting from i >= k - 1
        if (i >= k - 1) {
            result[ri++] = nums[deque.peekFirst()];
        }
    }
    return result;
}
```



Here is the **full Java program** including the `main` method to test the sliding window maximum code using a **monotonic deque**:

```java
import java.util.*;

public class SlidingWindowMaximum {
    public static int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new ArrayDeque<>();
        int[] result = new int[nums.length - k + 1];
        int ri = 0;

        for (int i = 0; i < nums.length; i++) {
            // Remove indices outside the window
            if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }

            // Maintain decreasing order in deque
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            deque.offerLast(i);

            // Add max to result when the first window is complete
            if (i >= k - 1) {
                result[ri++] = nums[deque.peekFirst()];
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};
        int k = 3;
        int[] result = maxSlidingWindow(nums, k);

        System.out.println("Sliding window maximums:");
        for (int num : result) {
            System.out.print(num + " ");
        }
    }
}
```

---

### üß† How It Works:

* The deque stores **indices**, not actual values.
* Maintains a **monotonically decreasing** sequence of values' indices.
* Ensures **O(n)** time complexity by processing each index at most twice.




Let‚Äôs **dry run** the `maxSlidingWindow()` code on:

```java
nums = {1, 3, -1, -3, 5, 3, 6, 7}
k = 3
```

---

### üìä Goal:

Find the **maximum element** in each window of size `k = 3`.

---

### üõ† Variables:

* `deque`: stores **indices** in decreasing order of their values.
* `result`: stores final answers.

---

### üîÅ Step-by-Step Dry Run:

#### i = 0 ‚Üí nums\[0] = 1

* deque: empty ‚Üí just add 0
* `deque = [0]`
* Not yet `i ‚â• k-1`, so skip result

---

#### i = 1 ‚Üí nums\[1] = 3

* `nums[1] > nums[deque.peekLast()]` ‚Üí 3 > 1 ‚Üí remove index 0
* `deque = []`, then add 1
* `deque = [1]`
* Still `i < k-1`, skip result

---

#### i = 2 ‚Üí nums\[2] = -1

* `nums[2] < nums[1]` ‚Üí no removal
* add 2
* `deque = [1, 2]`
* Now `i ‚â• k-1` ‚Üí record max: `nums[1] = 3`
* `result = [3]`

---

#### i = 3 ‚Üí nums\[3] = -3

* deque: front is 1 ‚Üí still within window
* `nums[3] < nums[2]` ‚Üí no removal
* add 3
* `deque = [1, 2, 3]`
* max = nums\[1] = 3
* `result = [3, 3]`

---

#### i = 4 ‚Üí nums\[4] = 5

* deque front 1 is out of window (i - k + 1 = 2) ‚Üí remove 1
* now: remove all smaller elements ‚Üí 3 > -1 > -3 ‚Üí remove 2, 3
* add 4
* `deque = [4]`
* max = nums\[4] = 5
* `result = [3, 3, 5]`

---

#### i = 5 ‚Üí nums\[5] = 3

* 4 is in window, 3 < 5 ‚Üí no removal
* add 5
* `deque = [4, 5]`
* max = nums\[4] = 5
* `result = [3, 3, 5, 5]`

---

#### i = 6 ‚Üí nums\[6] = 6

* remove smaller elements: 3 < 6, 5 < 6 ‚Üí remove 5, 4
* add 6
* `deque = [6]`
* max = nums\[6] = 6
* `result = [3, 3, 5, 5, 6]`

---

#### i = 7 ‚Üí nums\[7] = 7

* 6 < 7 ‚Üí remove 6
* add 7
* `deque = [7]`
* max = nums\[7] = 7
* `result = [3, 3, 5, 5, 6, 7]`

---

### ‚úÖ Final Output:

```java
result = [3, 3, 5, 5, 6, 7]
```

This is the **maximum in each sliding window** of size 3.





---

## üõ† Alternative: Heap (Priority Queue)

Another approach uses a **Max Heap** (for max) or **Min Heap** (for min).

### ‚ùå Downsides:

* Can't efficiently remove out-of-window elements.
* Becomes **O(n log k)** instead of **O(n)** with Monotonic Queue.

---

## üß© Real-World Use Cases

* CPU scheduling or memory usage tracking over a time window
* Stock market: Track max/min price in last `k` days
* Network packet congestion monitoring
* Live stream analytics

---

## üß™ Practice These Problems

* **Sliding Window Maximum** ‚Äì LeetCode 239
* **Sliding Window Median** ‚Äì LeetCode 480 (uses two heaps)
* **Shortest Subarray with Sum at Least K** ‚Äì LeetCode 862
* **Longest Subarray with Limit** ‚Äì LeetCode 1438

---

## üîö Summary

| Technique       | Time Complexity | Space | Use When?                       |
| --------------- | --------------- | ----- | ------------------------------- |
| Naive Loop      | O(n \* k)       | O(1)  | Small inputs only               |
| Monotonic Deque | O(n)            | O(k)  | Best for frequent min/max in k  |
| Heap            | O(n log k)      | O(k)  | When exact order matters (rare) |

---

### ‚ú® Final Tip

Monotonic Queue is **not just for min/max**. It‚Äôs also used in:

* **Next Greater Element**
* **Histogram problems**
* **Max in circular windows**

Think of it as your go-to pattern when **order in window matters**.


---


### ‚úÖ When to use **Heap** instead of DeQue?

In **some cases**, a **heap is still a valid solution**, especially when:

#### 1. **You don‚Äôt need exact sliding window max/min, but Kth largest**

* Example: **"Find Kth Largest Element in a Stream"** ‚Äì you use a min-heap of size K.

#### 2. **You want flexibility with order** (not just max/min)

* Heaps can support **top-K**, **Kth min/max**, **median**, etc.
* Deque is only for **strict max/min** in a window.

#### 3. **You don‚Äôt care about O(n log k)** time

* Heap solution is still acceptable for interview if you **clearly explain** it's slower.

---

### üîÅ Comparison:

| Approach              | Time Complexity | Suitable For                                            |
| --------------------- | --------------- | ------------------------------------------------------- |
| **Deque (Monotonic)** | O(n)            | Fastest for **max/min in sliding window**               |
| **Heap**              | O(n log k)      | For **Kth largest**, or when **ordered access** matters |

---

### üî• Example LeetCode Comparison:

* `Sliding Window Maximum` [Link](https://leetcode.com/problems/sliding-window-maximum/description/) ‚Äì Use **Deque (O(n))**
* `Median in Sliding Window` [Link](https://leetcode.com/problems/sliding-window-median/description/) ‚Äì Needs **Two Heaps** (maxHeap + minHeap)
* `Kth Largest Element in Stream` [Link](https://leetcode.com/problems/kth-largest-element-in-a-stream/description/) ‚Äì Use **Min Heap**

---

### ‚úÖ Final Verdict:

> Deque is **best** for max/min in sliding windows (when you just need 1 value).
> Heap is used when you want **ordered structure** or **Kth statistics**.


**Note: **Deque is more optimal** for most sliding max/min cases.**


----

## Questions

> Q. In queue  "insert elem in rear", "remove elem from front". In dequeue, "insert elem in rear",  "can remove from rear / front". Am I correct? 

Yes, you're **absolutely correct** ‚úÖ

Here's a quick breakdown:

### üü© **Queue**

* **Insert**: Rear (`enqueue`)
* **Remove**: Front (`dequeue`)
* **Type**: **FIFO** (First In, First Out)

---

### üü® **Deque** (Double-Ended Queue)

* **Insert**: From **rear** or **front**
* **Remove**: From **rear** or **front**
* **Type**: Fully flexible at both ends

---

### ‚úÖ So yes:

> In a **Deque**, you can insert at the rear and remove from either **rear or front** ‚Äî and that‚Äôs exactly what makes it powerful for sliding window problems.


---

> Q. So Deque can be stack !!

Yes, a **deque can act as a stack** ‚úÖ

### Why?
Because a **stack** uses:
- **Push**: Insert at one end (top)
- **Pop**: Remove from the same end

### So in a **deque**, if you:
- **Insert at rear**, and  
- **Remove from rear**,  
‚Üí It behaves exactly like a **stack (LIFO)**

---

### üîÅ Summary:

| Structure | Insert | Remove | Behavior        |
|----------|--------|--------|-----------------|
| Queue    | Rear   | Front  | FIFO            |
| Stack    | Rear   | Rear   | LIFO (can be front too) |
| Deque    | Rear/Front | Rear/Front | Both FIFO & LIFO support |

So yes, **deque is a superset** ‚Äî it can act as both **stack and queue**.


> Q. why there is first in the method name of deque?

The word **"First"** in methods like `peekFirst()` and `pollFirst()` simply refers to the **front** of the deque ‚Äî the **first element** in line, just like in a queue.

### üîç Why "First"?

Because a **Deque** (Double-Ended Queue) has **two ends**:

* **First** ‚Üí the front (head/start)
* **Last** ‚Üí the rear (tail/end)

So Java clearly names methods to specify **which end you're working with**.

---

### üîß Examples:

| Method         | Acts On | Purpose                     |
| -------------- | ------- | --------------------------- |
| `offerFirst()` | front   | Insert at front             |
| `pollFirst()`  | front   | Remove from front           |
| `peekFirst()`  | front   | View front without removing |
| `offerLast()`  | rear    | Insert at rear              |
| `pollLast()`   | rear    | Remove from rear            |
| `peekLast()`   | rear    | View rear without removing  |

---

### üß† Simple Analogy:

Imagine a train:

* **First** is the engine.
* **Last** is the last compartment.
  You can **add or remove** people at **either end**, so Java gives you both options clearly.

That's why **"first"** is in the method name ‚Äî to tell you it‚Äôs operating on the **front of the deque**.


> Q. In methods like pollFirst, peekfirst etc. in deque, isn't the name "First" redundant?

Yes ‚Äî **you‚Äôre right** in thinking that method names like `pollFirst()` and `pollLast()` are longer and technically **use more bytes** than just `poll()` or `pop()`.

But here's why Java (and other modern languages) **intentionally uses `First` and `Last`** in `Deque`:

---

### ‚úÖ **1. Not Redundant ‚Äî It Adds Clarity**

* A **Deque** can operate at **both ends**.
* So just saying `poll()` would be **ambiguous**.
* `pollFirst()` vs `pollLast()` clearly tells **which end** you‚Äôre working with.

  * ‚ö†Ô∏è Imagine debugging code where `poll()` doesn't say *which end* ‚Äî confusing!

---

### ‚úÖ **2. Readability > Micro-Optimization**

* Java prioritizes **clear, self-documenting code** over saving a few bytes in method names.
* You‚Äôre not saving actual memory in runtime ‚Äî method names are **not stored in RAM** during execution.

---

### ‚úÖ **3. Names are Resolved at Compile-Time**

* The actual names (`pollFirst`, `peekLast`, etc.) live in **compiled bytecode**, not repeatedly in memory.
* Runtime performance and memory **aren‚Äôt affected** by long method names.

---

### üîö **Conclusion**

> Yes, `"First"` adds extra bytes in source code,
> ‚ùå But it‚Äôs **not redundant** ‚Äî it adds essential clarity in a double-ended structure.
> ‚úÖ And it does **not affect runtime performance** or memory usage meaningfully.

---


## Questions 


> Q. Is deque is something which can be used both as stack and queue?


Yes, ‚úÖ **Deque (Double-Ended Queue)** can be used as **both a stack and a queue**.

---

### üîÅ As a **Queue**:

* **Add at rear:** `addLast()`
* **Remove from front:** `removeFirst()`

### üîÅ As a **Stack**:

* **Push at front:** `addFirst()`
* **Pop from front:** `removeFirst()`

---

### üîß Java Example:

```java
Deque<Integer> deque = new ArrayDeque<>();

// As stack
deque.addFirst(10); // push
deque.removeFirst(); // pop

// As queue
deque.addLast(20); // enqueue
deque.removeFirst(); // dequeue
```

---

So yes, **`Deque` is a versatile data structure** ‚Äî supports both **LIFO (stack)** and **FIFO (queue)** operations efficiently.


> Q. Is priorityQueue is something that doesn't follow fifo but follows the priority? 

Yes, ‚úÖ **`PriorityQueue`** in Java does **not follow FIFO** ‚Äî it follows **priority-based ordering**.

---

### üîç How it works:

* Elements are ordered by **natural order** (e.g., smallest number first), or by a **custom comparator**.
* The **element with highest priority** (e.g., lowest value in min-heap) is always at the **head**.

---

### üö´ Not FIFO:

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.add(10);
pq.add(5);
pq.add(20);

System.out.println(pq.poll()); // prints 5 (not 10!)
```

Even though `10` was inserted first, `5` comes out first because it has **higher priority** (smaller value).

---

So yes, `PriorityQueue` is **not FIFO**, it is **priority-driven**.


> Q. then why it has queue in its name?


Great question!

The name **`PriorityQueue`** includes ‚ÄúQueue‚Äù because:

---

### üí° Conceptually:

A **queue** is a structure where you **add elements** and **remove them** later ‚Äî it's about managing a collection with controlled access.

* In **`Queue`**, removal is based on **insertion order** (FIFO).
* In **`PriorityQueue`**, removal is based on **priority**, not order.

So both are **queues** in the sense that:

* You **add elements**
* You **remove one element at a time**
* You **don't access elements randomly**

---

### üß† Think of it like:

> ==A queue in a hospital where **more critical patients** are treated first ‚Äî not those who came first.==

---

### ‚úÖ Summary:

It‚Äôs called `PriorityQueue` because it **manages a queue of elements** with a defined **removal policy based on priority**, not just order.



> Q. is monotonic queue and deque same ? 



Not exactly ‚Äî a **monotonic queue** is a **special kind of deque** used in algorithmic problems.

---

### ‚úÖ **Monotonic Queue**

* A **monotonic queue** maintains elements in **sorted order** (increasing or decreasing).
* It's typically implemented using a **deque**.
* Used in sliding window problems like "maximum in all subarrays of size k".

---

### ‚úÖ **Deque**

* A **double-ended queue** that allows insertion/removal from **both ends**.
* It has **no order constraint** unless you enforce one.

---

### üí° Summary:

| Feature          | Monotonic Queue                               | Deque            |
| ---------------- | --------------------------------------------- | ---------------- |
| Order Maintained | Yes (increasing/decreasing)                   | No               |
| Purpose          | Algorithm-specific (e.g., sliding window max) | General-purpose  |
| Implementation   | Usually uses `Deque`                          | Native structure |

üëâ So, **a monotonic queue uses a deque**, but they are **not the same thing**.
