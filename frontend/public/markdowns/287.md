# **Introduction to Micro Frontends in Next.js**  

## ğŸ“Œ **Introduction**  
As frontend applications grow in complexity, **monolithic architectures** become harder to maintain. **Micro Frontends (MFE)** provide a solution by breaking a large frontend into **smaller, independent modules** that can be developed and deployed separately.  

### **What is a Micro Frontend?**  
Micro Frontends apply the **microservices concept** to frontend development, where different teams work on independent UI components that integrate into a single application.  

ğŸ’¡ **Key Features:**  
âœ” Independent development and deployment of frontend modules  
âœ” Different tech stacks for different micro frontends  
âœ” Enhanced scalability and maintainability  
âœ” Faster development cycles  

**Example Architecture:**  
```
E-commerce App (Container)
â”œâ”€â”€ Home Page (Micro Frontend)
â”œâ”€â”€ Product List (Micro Frontend)
â”œâ”€â”€ Shopping Cart (Micro Frontend)
â”œâ”€â”€ User Profile (Micro Frontend)
```

---

## ğŸ— **Benefits of Micro Frontends**  

ğŸ”¹ **Scalability** â€“ Teams work on separate modules independently  
ğŸ”¹ **Tech Agnostic** â€“ Different parts of the app can use different frameworks (e.g., React, Angular, Vue)  
ğŸ”¹ **Independent Deployments** â€“ Each MFE can be deployed separately  
ğŸ”¹ **Improved Maintainability** â€“ Easier to manage and update  
ğŸ”¹ **Faster Development** â€“ Parallel development speeds up releases  

---

## ğŸš€ **Micro Frontend Approaches in Next.js**  

Next.js provides multiple ways to implement Micro Frontends:

| Approach | Description | Pros | Cons |
|----------|------------|------|------|
| **Module Federation** (Webpack 5) | Different Next.js apps share components dynamically | High performance, efficient lazy loading | Requires configuration |
| **iFrames** | Load MFEs in separate frames | Isolated, secure | Poor performance, limited communication |
| **Reverse Proxy (NGINX)** | Serves MFEs from different domains | No client-side integration needed | Requires DevOps setup |
| **Build-Time Composition** | Pre-integrates MFEs at build time | Optimized performance | Less flexibility in independent deployment |

Let's explore **Module Federation**, the most popular approach.

---

## ğŸ›  **Setting Up Micro Frontends in Next.js with Module Federation**  

### **1ï¸âƒ£ Install Dependencies**  
First, install the **Next.js Module Federation plugin**:

```sh
npm install @module-federation/nextjs-mf
```

---

### **2ï¸âƒ£ Create a Host and Remote Application**  

We'll create **two Next.js apps**:  
1. **Host App (`container`)** â€“ Main application that loads Micro Frontends.  
2. **Remote App (`products`)** â€“ A micro frontend providing a product list.

---

### **3ï¸âƒ£ Configure Webpack in `products` (Remote App)**  

In `products/next.config.js`:

```js
const { withModuleFederation } = require('@module-federation/nextjs-mf');

module.exports = withModuleFederation({
  name: 'products',
  filename: 'static/chunks/remoteEntry.js',
  exposes: {
    './ProductList': './components/ProductList',
  },
  shared: {
    react: { singleton: true },
    'react-dom': { singleton: true },
  },
});
```

ğŸ“Œ **Explanation:**  
- `name: 'products'` â†’ The name of the remote app.  
- `filename: 'static/chunks/remoteEntry.js'` â†’ The entry point for Module Federation.  
- `exposes` â†’ Specifies the components available for the Host App.  
- `shared` â†’ Ensures React is **shared** across MFEs to avoid multiple instances.  

---

### **4ï¸âƒ£ Create a Component in `products`**  

ğŸ“„ **Create `components/ProductList.js`**  

```jsx
const ProductList = () => {
  return (
    <div>
      <h2>Product List</h2>
      <ul>
        <li>Product 1</li>
        <li>Product 2</li>
      </ul>
    </div>
  );
};

export default ProductList;
```

---

### **5ï¸âƒ£ Configure Webpack in `container` (Host App)**  

In `container/next.config.js`:

```js
const { withModuleFederation } = require('@module-federation/nextjs-mf');

module.exports = withModuleFederation({
  name: 'container',
  remotes: {
    products: 'products@http://localhost:3001/_next/static/chunks/remoteEntry.js',
  },
});
```

ğŸ“Œ **Explanation:**  
- `name: 'container'` â†’ The Host App name.  
- `remotes` â†’ Defines external apps (MFEs) to be imported dynamically.  

---

### **6ï¸âƒ£ Load the Micro Frontend in `container`**  

ğŸ“„ **Modify `pages/index.js` in `container`**  

```jsx
import dynamic from "next/dynamic";

const ProductList = dynamic(() => import("products/ProductList"), { ssr: false });

export default function Home() {
  return (
    <div>
      <h1>Welcome to the Store</h1>
      <ProductList />
    </div>
  );
}
```

ğŸ“Œ **Explanation:**  
- `dynamic()` â†’ Dynamically imports `ProductList` from `products`.  
- `{ ssr: false }` â†’ Disables SSR for the component.  

---

## ğŸ“¦ **Running the Micro Frontends Locally**  

1ï¸âƒ£ Start the **Remote App (`products`)**:  
```sh
cd products
npm run dev
```
ğŸŸ¢ Running on `http://localhost:3001`  

2ï¸âƒ£ Start the **Host App (`container`)**:  
```sh
cd container
npm run dev
```
ğŸŸ¢ Running on `http://localhost:3000`  

ğŸ”¹ Now, `http://localhost:3000` loads the **Product List** from `http://localhost:3001`.

---

## ğŸ¯ **Deployment Strategies for Micro Frontends**  

### âœ… **1. Deploying on Vercel**  
- Deploy each MFE separately on **Vercel**.  
- Use **Vercel Redirects/Rewrites** to serve MFEs from the same domain.  

### âœ… **2. Using Reverse Proxy (NGINX)**  
- Host each MFE on separate subdomains:  
  - `products.myapp.com`  
  - `cart.myapp.com`  
- Use **NGINX** to proxy requests dynamically.  

ğŸ’¡ **Example NGINX Config:**  
```nginx
location /products {
    proxy_pass http://products.myapp.com;
}
```

---

## âœ… **Best Practices for Micro Frontends in Next.js**  

âœ” **Ensure Shared Dependencies** â€“ Use `singleton: true` for React.  
âœ” **Use Lazy Loading** â€“ Dynamically import MFEs for better performance.  
âœ” **Implement Authentication Properly** â€“ Centralized auth in the Host App.  
âœ” **Monitor Performance** â€“ Track loading times of MFEs.  
âœ” **Keep MFEs Independent** â€“ Minimize dependencies between MFEs.  

---

## ğŸš€ **Conclusion**  

Micro Frontends in Next.js **enable scalable, modular, and independent frontend development**. Using **Module Federation**, we can dynamically load components, improving performance and maintainability.  

