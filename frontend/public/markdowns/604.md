### â—„ Special Techniques â€“ Monotonic Stack â†’ Next Greater / Smaller Element

A **Monotonic Stack** is a stack that maintains its elements in either **increasing or decreasing order**, which helps solve **Next Greater / Smaller Element** problems in **O(n)** time.

---

### âœ… **When to Use:**

* You need to find:

  * **Next Greater Element (NGE)**
  * **Previous Smaller Element**
  * **Next Smaller Element**
  * **Previous Greater Element**
* You're dealing with **ranges, spans, or comparisons** (e.g., stock span, temperatures, histogram).

---

### ğŸ’¡ **Core Idea:**

* Traverse the array.
* Use a stack to **keep track of useful indices**.
* **Pop** from the stack when the current element breaks the order (greater or smaller).
* Store result based on the stackâ€™s top.

---

### ğŸ” **Types:**

* **Monotonically Decreasing Stack** â†’ for **Next Greater Element**
* **Monotonically Increasing Stack** â†’ for **Next Smaller Element**

---

### ğŸ§  **Example: Next Greater Element**

Input: `[2, 1, 2, 4, 3]`
Output: `[4, 2, 4, -1, -1]`

```java
int[] res = new int[nums.length];
Stack<Integer> stack = new Stack<>();

for (int i = nums.length - 1; i >= 0; i--) {
    while (!stack.isEmpty() && stack.peek() <= nums[i]) {
        stack.pop();
    }
    res[i] = stack.isEmpty() ? -1 : stack.peek();
    stack.push(nums[i]);
}
```

Letâ€™s break down the **Next Greater Element** logic for input:

### ğŸ”¢ Input: `[2, 1, 2, 4, 3]`

We want to find, for each element, the **first element to its right that is greater** than it.
If no such element exists, we return `-1`.

---

### ğŸ” Step-by-step:

| Index | Value | Next Greater Element (NGE)            |
| ----- | ----- | ------------------------------------- |
| 0     | 2     | 4 â†’ (Next greater after 2 is 4)       |
| 1     | 1     | 2 â†’ (Next greater after 1 is 2)       |
| 2     | 2     | 4 â†’ (Next greater after 2 is 4)       |
| 3     | 4     | -1 â†’ (No element to right is greater) |
| 4     | 3     | -1 â†’ (No element to right is greater) |

---

### âœ… Output: `[4, 2, 4, -1, -1]`

This is why:

* 2 â†’ **4**
* 1 â†’ **2**
* 2 â†’ **4**
* 4 â†’ **-1**
* 3 â†’ **-1**


---

### ğŸ” How it works:

* Traverse from right to left.
* Maintain a stack of **indices** of elements in **monotonically decreasing order**.
* For each element:

  * Pop smaller elements from the stack.
  * If the stack isnâ€™t empty, its top points to the **next greater**.
  * Push current index onto the stack.



---

### ğŸŸ¢ **Advantages:**

* Reduces brute-force **O(nÂ²)** to **O(n)**.
* Elegant and efficient for real-time range-based logic.

---

Use Monotonic Stack when you see patterns like **"next greater," "previous smaller," or "first element on the right that..."**.
