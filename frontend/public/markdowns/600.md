
# ğŸ§  Sliding Window Technique

*A technique to optimize nested loops involving contiguous data (subarrays/substrings)*

---

## ğŸ’¡ What Is a Sliding Window?

A **sliding window** is a **contiguous range** (or â€œwindowâ€) that **moves across a sequence** (array or string) to solve problems involving:

* Subarray/substring **lengths**
* **Maximum/minimum** in window
* **Frequency/count** tracking
* **Sum or average** in range

---

## ğŸ› ï¸ Types of Sliding Windows

| Type             | Description                                       |
| ---------------- | ------------------------------------------------- |
| **Fixed-size**   | Window size `k` is constant (e.g., sum of size k) |
| **Dynamic-size** | Window expands or shrinks based on constraints    |

---

## ğŸ” Sliding Window Template (Dynamic Window)

```js
let start = 0;
for (let end = 0; end < s.length; end++) {
    // Expand the window with s[end]

    // While window is invalid:
    while (/* constraint violated */) {
        // Shrink the window from start
        start++;
    }

    // Update result if needed (e.g., maxLen = Math.max(...))
}
```

---

## â• Fixed-size Window Template

```js
let sum = 0, maxSum = 0;
for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    if (i >= k) sum -= nums[i - k];
    if (i >= k - 1) maxSum = Math.max(maxSum, sum);
}
```

---

## ğŸ“Œ Use Cases & Triggers

Use Sliding Window when you see:

* â€œFind max/min/longest/shortest **subarray** or **substring**â€
* â€œExactly/at most/at least K distinct/sum/charâ€
* â€œFixed size or dynamic range conditionsâ€

---

## ğŸ” Data Structures Commonly Used With Sliding Window

| Scenario                     | Tool                    |
| ---------------------------- | ----------------------- |
| Frequency/count tracking     | HashMap                 |
| Uniqueness/containment check | HashSet                 |
| Max/min tracking             | Deque (Monotonic Queue) |
| Top-K/median in window       | Heap                    |

---

## ğŸ“˜ LeetCode Problems Using Sliding Window

| Problem # | Title                                             | Window Type       | Difficulty |
| --------- | ------------------------------------------------- | ----------------- | ---------- |
| 643       | Maximum Average Subarray I                        | Fixed             | Easy       |
| 424       | Longest Repeating Character Replacement           | Dynamic (count)   | Medium     |
| 3         | Longest Substring Without Repeating Characters    | Dynamic (set)     | Medium     |
| 76        | Minimum Window Substring                          | Dynamic (map)     | Hard       |
| 567       | Permutation in String                             | Fixed + Frequency | Medium     |
| 438       | Find All Anagrams in a String                     | Fixed + Frequency | Medium     |
| 209       | Minimum Size Subarray Sum                         | Dynamic           | Medium     |
| 1456      | Maximum Number of Vowels in Substring of Length K | Fixed             | Medium     |
| 1004      | Max Consecutive Ones III                          | Dynamic (flip)    | Medium     |
| 1423      | Max Points You Can Obtain from Cards              | Inverse window    | Medium     |
| 239       | Sliding Window Maximum                            | Fixed + Deque     | Hard       |

---

## ğŸ§ª Example Problem: Maximum Sum Subarray of Size K

```js
function maxSum(nums, k) {
  let sum = 0, max = 0;
  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    if (i >= k) sum -= nums[i - k];
    if (i >= k - 1) max = Math.max(max, sum);
  }
  return max;
}
```

---

## âš ï¸ Common Pitfalls

* âŒ Off-by-one errors in window boundaries
* âŒ Forgetting to shrink the window dynamically
* âŒ Not updating frequency maps properly
* âŒ Wrong condition in while loop (can lead to infinite loops)

---

## âœ… Summary

| Goal                              | Use Sliding Window When...                |
| --------------------------------- | ----------------------------------------- |
| Find max/min/avg in subarray      | Use fixed-size window                     |
| Longest substring with constraint | Use dynamic-size window + HashMap/HashSet |
| Find subarrays with sum/k count   | Use prefix sum or shrinkable window       |
| Track frequency/counts            | Combine with HashMap or Count Array       |

---

### Questions

> Q. Why do i confuse between 2 pointers and sliding window?


That's a **very common confusion** â€” and you're not alone.

Letâ€™s break down **why** you're mixing up **Two Pointers** and **Sliding Window**, and how to **clearly separate** them in your mind:

---

## ğŸ¤¯ Why the Confusion Happens

Because **sliding window is built using two pointers**, but **not all two pointer problems are sliding windows**.

| Concept        | Overlaps                                             |
| -------------- | ---------------------------------------------------- |
| Two Pointers   | More general tool (left/right, slow/fast)            |
| Sliding Window | A specific use case: contiguous subarrays/substrings |

---

## âœ… Clear Distinction

| Feature             | **Two Pointers**                         | **Sliding Window**                         |
| ------------------- | ---------------------------------------- | ------------------------------------------ |
| Purpose             | Compare/move from two ends, match values | Maintain a window over contiguous elements |
| Must be contiguous? | âŒ No                                     | âœ… Yes (always contiguous)                  |
| Window Size         | Not always fixed/dynamic                 | Fixed or dynamic size window               |
| Common Goal         | Pairs, reverse, find mid, merge          | Sum, length, count, frequency in window    |
| Key Structure       | Often two independent pointers           | One pointer grows, one shrinks the window  |

---

## ğŸ” Example Comparison

### ğŸ”¹ Two Pointers: Find pair with sum

```js
// Sorted array
let left = 0, right = nums.length - 1;
while (left < right) {
  if (nums[left] + nums[right] === target) return true;
  else if (...) left++; else right--;
}
```

### ğŸ”¸ Sliding Window: Longest substring with k distinct chars

```js
let start = 0, freq = new Map();
for (let end = 0; end < s.length; end++) {
  freq.set(...);
  while (freq.size > k) {
    freq.delete(...);
    start++;
  }
  maxLen = Math.max(maxLen, end - start + 1);
}
```

---

## ğŸ§  Mental Model

* **If the range must be continuous**, and youâ€™re **tracking something inside the window**, itâ€™s **sliding window**.
* **==If you're working with sorted arrays==**, matching from ends, or **no need for continuity**, itâ€™s usually **plain two pointers**.

---

## âœ… Tip to Remember

> **All sliding window problems use two pointers,
> but not all two pointer problems are sliding windows.**

---

Here's a **1-line decision rule** and a simple **flowchart-style checklist** to help you instantly decide:



## âœ… **One-Line Rule**

> ğŸ” **If you're moving across a **contiguous** range and tracking things like sum, length, or count â€” it's Sliding Window.**
> Otherwise, it's likely just a Two Pointer pattern.

---

## ğŸ§­ **Flowchart-Style Checklist**

```text
1. Is the question about subarray/substring or a continuous range?
   â†’ Yes â†’ Go Sliding Window

2. Are you tracking max/min/sum/count/length in a range?
   â†’ Yes â†’ Go Sliding Window

3. Is the array sorted and you're finding pairs (e.g., target sum)?
   â†’ Yes â†’ Two Pointers (Opposite ends)

4. Are you scanning for matching elements or removing duplicates?
   â†’ Yes â†’ Two Pointers (Fast & Slow)

5. Is the data not required to be continuous?
   â†’ Yes â†’ Two Pointers
```

---

## ğŸ¯ Quick Pattern Matches

| Keyword in Question            | Pattern        |
| ------------------------------ | -------------- |
| "subarray", "substring"        | Sliding Window |
| "longest", "shortest" in range | Sliding Window |
| "remove duplicates"            | Two Pointers   |
| "sorted array" + "pair"        | Two Pointers   |
| "in-place" modification        | Two Pointers   |

---

### ğŸ’¬ Example to Practice:

* **"Find the longest substring with at most 2 distinct characters"** â†’ âœ… Sliding Window
* **"Find if a pair sums to target in sorted array"** â†’ âœ… Two Pointers
* **"Remove duplicates in-place from sorted array"** â†’ âœ… Two Pointers
* **"Max sum of subarray of size K"** â†’ âœ… Sliding Window


