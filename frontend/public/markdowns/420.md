

# ğŸ”Œ API Routes in Next.js â€” Build Full-Stack Without Leaving the Framework

One of the most powerful features of Next.js is its ability to create **API routes alongside your frontend code** â€” eliminating the need for a separate backend server for many applications.

With **API Routes**, you can write **backend logic** like form handling, database queries, authentication, or 3rd-party integrations using plain JavaScript or TypeScript â€” all within your Next.js app.

---

## ğŸ“¦ What Are API Routes?

API Routes in Next.js are **server-side functions** you place inside the `/pages/api/` directory.

Each file in that folder becomes an **HTTP endpoint** (e.g., `pages/api/hello.js` becomes `/api/hello`).

> Think of them as **mini Express routes**, but baked right into your Next.js project.

---

## ğŸ”§ Creating a Basic API Route

```js
// pages/api/hello.js
export default function handler(req, res) {
  res.status(200).json({ message: 'Hello from API Route!' });
}
```

ğŸ“ URL: `http://localhost:3000/api/hello`

---

## ğŸ§  Request and Response Objects

- `req`: contains HTTP request data (method, body, query, headers)
- `res`: used to send the response

Same as in Express.js!

```js
export default function handler(req, res) {
  if (req.method === 'POST') {
    const { name } = req.body;
    res.status(200).json({ message: `Hello, ${name}` });
  } else {
    res.status(405).json({ error: 'Method Not Allowed' });
  }
}
```

---

## ğŸ›  Handling Different HTTP Methods

You can handle methods like `GET`, `POST`, `PUT`, `DELETE` in a single route.

```js
export default function handler(req, res) {
  switch (req.method) {
    case 'GET':
      res.status(200).json({ data: 'Fetching data...' });
      break;
    case 'POST':
      res.status(201).json({ message: 'Data submitted!' });
      break;
    default:
      res.status(405).end(); // Method Not Allowed
  }
}
```

---

## ğŸ” Authentication & Middleware

While API Routes donâ€™t support traditional middleware directly like Express, you can **write reusable utility functions**.

### Example: Check for a token

```js
export default function handler(req, res) {
  const token = req.headers.authorization;
  if (!token || token !== 'mysecrettoken') {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  res.status(200).json({ data: 'Access granted' });
}
```

For complex logic, you can also integrate `jsonwebtoken`, `next-auth`, or `iron-session`.

---

## ğŸŒ Using Query Parameters

```js
// /api/greet?name=Raj
export default function handler(req, res) {
  const { name } = req.query;
  res.status(200).json({ message: `Hi, ${name}` });
}
```

---

## ğŸ§® Example: POST Request With JSON Body

```js
export default function handler(req, res) {
  if (req.method === 'POST') {
    const { email, password } = req.body;
    // validate, store in DB, etc.
    res.status(201).json({ status: 'User created' });
  }
}
```

Make sure to **send Content-Type: application/json** in frontend fetch:

```js
fetch('/api/register', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email, password })
});
```

---

## ğŸ§ª Use Cases for API Routes

âœ… Form submission handler  
âœ… Newsletter signup  
âœ… Authentication (JWT or session)  
âœ… Database CRUD operations  
âœ… Image/file upload  
âœ… 3rd-party API integration  
âœ… Webhooks (Stripe, GitHub, etc.)

---

## ğŸ”„ Edge vs Serverless vs Traditional

- **API Routes in `/pages/api/`** run as **serverless functions** (Vercel) or Node.js functions (local/server).
- **API Routes in the app directory (Next.js 13+)** can run as **Edge Functions** for low-latency.

---

## âš ï¸ Limitations

- Cannot persist connections (e.g., WebSockets) â€” prefer `/app` edge functions or external server.
- Shared memory (like in-memory DB or variables) won't persist between requests on serverless platforms.

---

## ğŸ“Œ Folder Structure Example

```
pages/
  â””â”€â”€ api/
       â”œâ”€â”€ hello.js            â†’ /api/hello
       â”œâ”€â”€ auth/
       â”‚     â””â”€â”€ login.js      â†’ /api/auth/login
       â””â”€â”€ users/
             â””â”€â”€ [id].js       â†’ /api/users/123
```

Yes, you can use **dynamic API routes** like `[id].js` too!

---

## âœ… Summary

| Feature               | Description                                       |
|------------------------|---------------------------------------------------|
| Location               | `/pages/api/*.js`                                 |
| Purpose                | Build backend logic alongside frontend            |
| Supports               | All HTTP methods (`GET`, `POST`, `PUT`, etc.)     |
| Use Cases              | Forms, auth, DB access, 3rd-party APIs            |
| Alternative to         | Express, external servers                         |
| Bonus                  | Supports dynamic routing and file-based structure |

---

## ğŸ”š Final Thought

API Routes let you **go full-stack with one codebase** â€” no need to spin up Express or manage a separate server. They're perfect for small apps, quick MVPs, or even production use cases on serverless platforms like **Vercel**, **Netlify**, or **AWS Lambda**.

> Build your UI and your backend logic â€” all inside Next.js ğŸ§ 

