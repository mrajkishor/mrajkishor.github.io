Hereâ€™s the solution for [**LeetCode 2726 â€“ Interval Cancellation**](https://leetcode.com/problems/interval-cancellation/?envType=study-plan-v2&envId=30-days-of-javascript):

---

## âœ… Problem Summary

You need to implement a `cancellableInterval` function that:
- Accepts a `fn` and a delay `t`
- Repeatedly calls `fn` every `t` milliseconds
- Returns an object with a `.cancel()` method to stop future invocations

---

## âœ… Solution

```ts
function cancellable(fn: Function, t: number): { cancel: () => void } { // outer function
  // â† lexical environment begins here
  const intervalId = setInterval(fn, t); // in the lexical scope of closure

  return { // closure
    cancel: () => clearInterval(intervalId) // â† closure over intervalId
  };
}
```

> **Note** : ==Lexical scope (or static scope)== means that functions remember the variables available in the scope where they were **defined**, not where they are **called**.

[See more...](#lexical-scope-and-closure-with-brief-explanation)

---

## âœ… Example Usage

```ts
let count = 0;

const { cancel } = cancellable(() => {
  console.log('Running:', ++count);
}, 1000);

// Cancel after 3.5 seconds
setTimeout(cancel, 3500);
```

ğŸŸ¢ Output:
```
Running: 1
Running: 2
Running: 3
```

(Stops before 4th run)

---

## ğŸ§  Key Concepts

- `setInterval(fn, t)` schedules `fn` repeatedly every `t` ms
- `clearInterval(intervalId)` stops it
- Returning a closure with `.cancel()` enables cancellation access

---

## Lexical scope and closure with brief explanation 

Letâ€™s visualize how **lexical scope** and **closure** work together in your `cancellable()` example â€” step by step!

---

## ğŸ”„ Code

```ts
function cancellable(fn, t) {
  const intervalId = setInterval(fn, t);

  return {
    cancel: () => clearInterval(intervalId)
  };
}

const { cancel } = cancellable(() => console.log("Hello"), 1000);
setTimeout(cancel, 3000);
```

---

## ğŸ§  Step-by-Step Lexical Environment + Closure

### 1. `cancellable()` is invoked
- A new **lexical environment** (scope) is created
- `intervalId` is declared inside this scope

```
Lexical Environment:
{
  fn: function,
  t: 1000,
  intervalId: <timer#123>
}
```

### 2. `cancel` function is created and returned
- `cancel` is **defined inside `cancellable()`**
- It **closes over** (remembers) `intervalId`

```js
cancel: () => clearInterval(intervalId)
```

This creates a **closure**, where:
- `cancel` carries a reference to `intervalId` even after `cancellable()` returns

---

## ğŸ§  Closure Analogy

> Think of a function as a **backpack** ğŸ’

- When you define `cancel` inside `cancellable`, it **packs** everything it might use â€” like `intervalId` â€” into its backpack
- Even after `cancellable()` is finished, the `cancel` function still has access to that backpack (the closure)

---

## ğŸ“¦ Visual Memory Model

```
Global Scope
â”œâ”€â”€ cancellable()  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              â”‚
â”‚ Lexical Environment:         â”‚
â”‚  â””â”€â”€ intervalId = timer#123  â”‚
â”‚                              â–¼
â””â”€â”€ cancel() â€” closure keeps intervalId alive
```

So when `cancel()` is called later, JS doesnâ€™t look in the global scope â€” it looks in the backpack (`closure`) it was born with.

