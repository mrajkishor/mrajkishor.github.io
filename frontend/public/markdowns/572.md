
## ğŸ§© Detecting Cycles?


### ğŸ” Problem

Given a **linked list**, determine if it contains a **cycle** (i.e., a node is visited again by following `next` pointers).

---

### ğŸ§  Intuition

In a cyclic list, a pointer eventually **loops back** instead of reaching `null`. We must detect this repeating pattern efficiently, without using extra space if possible.

---

### âœ… Approaches

#### 1. **Floydâ€™s Cycle Detection Algorithm (Tortoise and Hare)**

[Problem Link](https://leetcode.com/problems/linked-list-cycle/)

* Use two pointers:

  * ğŸ¢ `slow` moves 1 step
  * ğŸ‡ `fast` moves 2 steps
* If thereâ€™s a cycle, `slow` and `fast` will **meet**.
* If `fast` or `fast.next` becomes `null`, the list is acyclic.

```java
public boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) return true;
    }
    return false;
}
```

* â±ï¸ Time: O(n)
* ğŸ§  Space: O(1)

---

#### 2. **HashSet Approach**

* Track visited nodes.
* If a node appears again, a cycle exists.

```java
public boolean hasCycle(ListNode head) {
    Set<ListNode> visited = new HashSet<>();
    while (head != null) {
        if (visited.contains(head)) return true;
        visited.add(head);
        head = head.next;
    }
    return false;
}
```

* â±ï¸ Time: O(n)
* ğŸ§  Space: O(n)

---

### âš ï¸ Edge Cases

* Empty list (`head == null`) â†’ no cycle
* Single node with `head.next == head` â†’ cycle
* Long tail with a short loop

---

### ğŸ¯ Interview Tip

Always mention **Floydâ€™s Algorithm** first â€” it's optimal and space-efficient. Hashing is easy but memory-heavy.

---

### ğŸ§µ Follow-up Variants

* Return **start node of cycle** (use Floydâ€™s again after detection)
* Remove cycle
* Count cycle length

