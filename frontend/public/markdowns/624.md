

## ğŸ“Œ Graph Representation

Graphs can be represented in multiple ways in memory, depending on the requirements:

---

### ğŸ§® 1. **Adjacency Matrix**

* A `V x V` 2D array `matrix[u][v]`
* `matrix[u][v] = 1` (or weight `w`) means thereâ€™s an edge from `u` to `v`.

#### âœ… **Undirected Graph**:

* Both `matrix[u][v]` and `matrix[v][u]` are set.

```java
int V = 4;
int[][] matrix = new int[V][V];

// Edges: 0-1, 0-2, 1-3, 2-3
matrix[0][1] = matrix[1][0] = 1; // Note: the 1 is the default weight of the edge
matrix[0][2] = matrix[2][0] = 1;
matrix[1][3] = matrix[3][1] = 1;
matrix[2][3] = matrix[3][2] = 1;
```

#### âœ… **Directed Graph**:

```java
int V = 4;
int[][] matrix = new int[V][V];

// Edges: 0â†’1, 1â†’2, 1â†’3
matrix[0][1] = 1;
matrix[1][2] = 1;
matrix[1][3] = 1;
```

---

### ğŸ§¾ 2. **Adjacency List (Indexed Nodes)**

* A list of lists: `List<List<Integer>> adj`
* `adj.get(u)` holds all neighbors `v` of node `u`

#### âœ… **Undirected Graph**:

```java
int V = 4;
List<List<Integer>> adj = new ArrayList<>();
for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

// Edges: 0-1, 0-2, 1-3, 2-3
adj.get(0).add(1); adj.get(1).add(0);
adj.get(0).add(2); adj.get(2).add(0);
adj.get(1).add(3); adj.get(3).add(1);
adj.get(2).add(3); adj.get(3).add(2);
```

#### âœ… **Directed Graph**:

```java
int V = 4;
List<List<Integer>> adj = new ArrayList<>();
for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

// Edges: 0â†’1, 1â†’2, 1â†’3
adj.get(0).add(1);
adj.get(1).add(2);
adj.get(1).add(3);
```

---

### ğŸ§¾ 3. **Generic Adjacency List (Named Nodes)**

Useful when node labels are not numbers:

```java
Map<String, List<String>> graph = new HashMap<>();

// Directed edge u â†’ v
void addEdgeDirected(String u, String v) {
    graph.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
}

// Undirected edge uâ€”v
void addEdgeUndirected(String u, String v) {
    graph.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
    graph.computeIfAbsent(v, k -> new ArrayList<>()).add(u);
}
```

#### ğŸ§ª Example:

```java
addEdgeUndirected("A", "B");
addEdgeUndirected("A", "C");
addEdgeUndirected("B", "D");
addEdgeUndirected("C", "D");
```

Graph:

```
A: [B, C]
B: [A, D]
C: [A, D]
D: [B, C]
```

---

## ğŸ—ï¸ Weighted Graph Representation

### ğŸ“˜ Adjacency Matrix (Weighted)

```java
int V = 4;
int[][] matrix = new int[V][V];

// Undirected
matrix[0][1] = matrix[1][0] = 5;
matrix[0][2] = matrix[2][0] = 3;

// Directed
matrix[0][1] = 5;
matrix[1][2] = 2;
```

---

### ğŸ“˜ Adjacency List (Weighted)

```java
class Pair {
    int node, weight;
    Pair(int node, int weight) {
        this.node = node;
        this.weight = weight;
    }
}
```

#### âœ… Undirected Weighted

```java
List<List<Pair>> adj = new ArrayList<>();
for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

adj.get(0).add(new Pair(1, 5));
adj.get(1).add(new Pair(0, 5));
```

#### âœ… Directed Weighted

```java
adj.get(0).add(new Pair(1, 5));
adj.get(1).add(new Pair(2, 2));
```

---

## ğŸ” Comparison

| Feature              | Adjacency Matrix | Adjacency List       |
| -------------------- | ---------------- | -------------------- |
| Space (Sparse Graph) | âŒ O(VÂ²)          | âœ… O(V + E)           |
| Edge Lookup          | âœ… O(1)           | âŒ O(k)               |
| Iterate Neighbors    | âŒ O(V)           | âœ… O(k)               |
| Add Edge             | âœ… Easy           | âœ… Easy               |
| Weighted Graph       | âœ… Easy           | âœ… Use Pair(node, wt) |

---

âœ… Use **Adjacency Matrix** for:

* Dense graphs
* Frequent edge lookup

âœ… Use **Adjacency List** for:

* Sparse graphs
* Fast traversal and lower memory

