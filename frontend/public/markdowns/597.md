
# ğŸ” Looking for Duplicates / Counts / Frequencies?

## â†’ Use **HashMap**, **HashSet**, or **Counting Array**

---

## ğŸ§  Pattern Overview

When the problem involves:

* Detecting **duplicates**
* Counting **occurrences**
* Tracking **frequencies**
* Finding **majority**, **mode**, or **frequency-based conditions**

â†’ Use frequency-tracking data structures like:

* ğŸ”¸ **HashMap** â€“ for counting arbitrary keys
* ğŸ”¸ **HashSet** â€“ for tracking unique presence
* ğŸ”¸ **Counting Array** â€“ for small-range integers

---

## ğŸ§° Core Tools

| Tool                  | Use Case                           | Time | Space |
| --------------------- | ---------------------------------- | ---- | ----- |
| `HashMap<K, Integer>` | Count frequency of elements        | O(n) | O(n)  |
| `HashSet<T>`          | Detect duplicates (exists or not)  | O(n) | O(n)  |
| Counting Array        | Fixed-range integers (e.g. 0â€“1000) | O(n) | O(1)  |

---

## ğŸ“˜ Example 1: Detect Duplicates in Array

**Problem**: LeetCode 217 â€“ *Contains Duplicate*

```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> seen = new HashSet<>();
    for (int num : nums) {
        if (!seen.add(num)) return true;
    }
    return false;
}
```

---

## ğŸ“˜ Example 2: Count Frequencies

**Problem**: LeetCode 387 â€“ *First Unique Character in a String*

```java
public int firstUniqChar(String s) {
    Map<Character, Integer> freq = new HashMap<>();
    for (char c : s.toCharArray()) {
        freq.put(c, freq.getOrDefault(c, 0) + 1);
    }
    for (int i = 0; i < s.length(); i++) {
        if (freq.get(s.charAt(i)) == 1) return i;
    }
    return -1;
}
```

---

## ğŸ“˜ Example 3: Majority Element

**Problem**: LeetCode 169 â€“ *Majority Element*

```java
public int majorityElement(int[] nums) {
    Map<Integer, Integer> count = new HashMap<>();
    for (int num : nums) {
        count.put(num, count.getOrDefault(num, 0) + 1);
        if (count.get(num) > nums.length / 2) return num;
    }
    return -1;
}
```

---

## ğŸ§© When to Use What?

| Scenario                  | Use            |
| ------------------------- | -------------- |
| Check if element repeats  | HashSet        |
| Count how many times seen | HashMap        |
| Count fixed-range numbers | Counting Array |
| Need order of occurrence  | LinkedHashMap  |

---

## ğŸ”„ HashMap Template for Counting

```java
Map<Integer, Integer> count = new HashMap<>();
for (int num : nums) {
    count.put(num, count.getOrDefault(num, 0) + 1);
}
```

---

## âš ï¸ Gotchas

* Use `getOrDefault()` to avoid `NullPointerException`
* Use `remove()` from `HashSet` carefully â€” check return value
* Donâ€™t use `Counting Array` if the range is large (e.g., 10^9)

---

## ğŸ”¥ Common Interview Problems

| Problem                                | Pattern             |
| -------------------------------------- | ------------------- |
| LeetCode 217 â€“ Contains Duplicate      | HashSet             |
| LeetCode 1 â€“ Two Sum                   | HashMap             |
| LeetCode 169 â€“ Majority Element        | HashMap             |
| LeetCode 347 â€“ Top K Frequent Elements | HashMap + Heap      |
| LeetCode 383 â€“ Ransom Note             | HashMap/Count Array |
| LeetCode 242 â€“ Valid Anagram           | HashMap/Count Array |
| LeetCode 49 â€“ Group Anagrams           | HashMap + Sorting   |

---

## ğŸ’¡ Summary

| Problem Type               | Best Tool                                   |
| -------------------------- | ------------------------------------------- |
| Duplicates / Uniqueness    | HashSet                                     |
| Count / Frequency          | HashMap                                     |
| Small numbers / characters | Counting Array                              |
| High performance counting  | `int[26]`, `int[100001]` if domain is small |

---

Hereâ€™s a clean **mind map-style cheatsheet** for:

---

## ğŸ§  **Duplicates / Counts / Frequencies Cheatsheet**

*â€œLooking for Duplicates, Frequency Counts? Use HashMap, HashSet, or Counting Arrayâ€*

---

### ğŸ¯ **Pattern Triggers**

* â€œCheck if a value appears more than onceâ€
* â€œReturn count of characters/integersâ€
* â€œFind most/least frequent elementâ€
* â€œGroup values by frequency or patternâ€

---

### ğŸ§° **Choose the Right Tool**

| Problem Type                        | Use Structure          | Time | Space |
| ----------------------------------- | ---------------------- | ---- | ----- |
| Check duplicates                    | `HashSet`              | O(n) | O(n)  |
| Count element frequencies           | `HashMap<K, Integer>`  | O(n) | O(n)  |
| Fixed-range values (e.g. 0â€“1000)    | Counting Array `int[]` | O(n) | O(1)  |
| Group elements by frequency/pattern | `HashMap<K, List<V>>`  | O(n) | O(n)  |

---

### ğŸ”„ **Common Snippets**

#### â¤ **Counting with HashMap**

```java
Map<Integer, Integer> count = new HashMap<>();
for (int num : nums)
    count.put(num, count.getOrDefault(num, 0) + 1);
```

#### â¤ **Detecting Duplicates**

```java
Set<Integer> seen = new HashSet<>();
for (int num : nums) {
    if (!seen.add(num)) return true;
}
```

#### â¤ **Counting Characters (A-Z)**

```java
int[] freq = new int[26];
for (char c : s.toCharArray())
    freq[c - 'a']++;
```



Here's the **full Java code** that counts the frequency of each lowercase letter (aâ€“z) in a given string `s` using the array:

```java
public class LetterFrequency {
    public static void main(String[] args) {
        String s = "helloapple";

        int[] freq = new int[26]; // For 'a' to 'z'

        for (char c : s.toCharArray()) {
            if (c >= 'a' && c <= 'z') {
                freq[c - 'a']++;
            }
        }

        // Print frequencies
        for (int i = 0; i < 26; i++) {
            if (freq[i] > 0) {
                char ch = (char) (i + 'a');
                System.out.println(ch + " â†’ " + freq[i]);
            }
        }
    }
}
```

---

### ğŸ§  Notes:

* It handles **only lowercase letters aâ€“z**.
* For uppercase, add a line: `s = s.toLowerCase();` or extend logic for `'A'` to `'Z'`.







---

### ğŸ’¡ **HashMap vs HashSet vs Counting Array**

| Feature              | HashMap               | HashSet             | Count Array |
| -------------------- | --------------------- | ------------------- | ----------- |
| Tracks frequency     | âœ… Yes                 | âŒ No                | âœ… Yes       |
| Tracks presence only | âœ… Can simulate        | âœ… Best for presence | âŒ No        |
| Ordered keys         | âŒ (Use LinkedHashMap) | âŒ                   | âŒ           |
| Fixed input range    | âŒ (any data)          | âŒ                   | âœ… Best      |

---

### ğŸ“˜ **Must-Practice LeetCode Problems**

| Problem # | Name                    | Tool Used      |
| --------- | ----------------------- | -------------- |
| 217       | Contains Duplicate      | HashSet        |
| 1         | Two Sum                 | HashMap        |
| 169       | Majority Element        | HashMap        |
| 242       | Valid Anagram           | Count Array    |
| 49        | Group Anagrams          | HashMap + Sort |
| 383       | Ransom Note             | Count Array    |
| 347       | Top K Frequent Elements | HashMap + Heap |

---

### ğŸ›‘ **Pitfalls to Avoid**

* âŒ Forgetting `getOrDefault` in HashMap
* âŒ Not handling large value ranges with count arrays
* âŒ Using Set when frequency is required
* âŒ Assuming `HashMap` maintains order (it doesn't!)

---

### ğŸ”š **Summary Thought**

> When tracking **what** and **how many times** something appears â€”
> reach for a **HashMap** or **Count Array**.
> When checking **if it appears at all**, go for a **HashSet**.

