### â—„ Special Techniques â€“ Greedy â†’ Only When Local Optimum Leads to Global Optimum

**Greedy algorithms** make the **locally optimal choice at each step**, hoping it leads to a **globally optimal solution**.

---

### âœ… **When to Use:**

* The problem has **greedy-choice property**: local best choices lead to global best.
* It shows **optimal substructure**: solution to a problem includes solutions to its subproblems.

---

### ğŸ’¡ **Core Strategy:**

At each step, **pick the best available option** (e.g., max value, min cost, shortest interval) **without backtracking**.

---

### âš ï¸ **Caution:**

Greedy doesnâ€™t always work. Use it **only when proven** that local decisions lead to optimal global result (usually via proof, intuition, or observation).

---

### ğŸ“˜ **Examples of Greedy Problems:**

* **Activity Selection** â†’ Choose max non-overlapping intervals by earliest end time.
* **Fractional Knapsack** â†’ Take highest value/weight ratio items first.
* **Huffman Coding** â†’ Build optimal prefix code using greedy merges.
* **Jump Game (LeetCode 55)** â†’ Choose the farthest jump at each step.
* **Minimum Platforms / Merge Intervals** â†’ Sort and pick based on greedy conditions.

---

### ğŸ§  **Why It Works (When It Works):**

Because the **problem structure guarantees** that making the best choice at each step doesn't prevent finding the best solution overall.

---

### ğŸŸ¢ **Benefit:**

* Simpler and faster than Dynamic Programming (often **O(n log n)** vs **O(nÂ²)**).
* No need for backtracking or state storage.

---

Use **Greedy** when problem constraints and behavior clearly allow **short-sighted decisions** to lead to the **best long-term result**.
