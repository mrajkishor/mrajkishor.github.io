### â—„ Tree â€” Balanced Checks or Diameter Calculations

#### â“ **Balanced checks or diameter calculations?**

â†’ **Use Postorder + height calculations**

---

### ðŸ“Œ **Why Postorder?**

In **postorder traversal** (`Left â†’ Right â†’ Root`), we visit children **before** the parent â€” perfect for computing **heights** and **bottom-up values** like:

* Height of subtree
* Diameter of subtree
* Balanced property (difference in height â‰¤ 1)

---

### âœ… **1. Check if Tree is Balanced**

A binary tree is **height-balanced** if for ==every node==,

`|height(left) - height(right)| â‰¤ 1`.


```java
boolean isBalanced(TreeNode root) {
    return check(root) != -1;
}

int check(TreeNode node) {
    if (node == null) return 0;
    int left = check(node.left);
    if (left == -1) return -1;

    int right = check(node.right);
    if (right == -1) return -1;

    if (Math.abs(left - right) > 1) return -1;
    return 1 + Math.max(left, right);
}
```

### Balanced 

![alt text](image-45.png)

### Not balanced

![alt text](image-46.png)

---

### âœ… **2. Calculate Diameter of Binary Tree**

**Diameter** = longest path between any two nodes (may or may not pass through root)

```java
int diameter = 0;

int height(TreeNode node) {
    if (node == null) return 0;

    int left = height(node.left);
    int right = height(node.right);

    diameter = Math.max(diameter, left + right); // measures the diameter of each node and compares with prev diameter
    return 1 + Math.max(left, right); // measures the height of each node and increment 1 for its parent node 
}

int diameterOfBinaryTree(TreeNode root) {
    height(root);
    return diameter;
}
```

---

### ðŸ“ˆ Time Complexity:

* **O(n)** â€” each node is visited once
* **Postorder** allows reusing height info during the return phase

---

### ðŸ§  Summary:

> Use **postorder** when child calculations must be complete before parent logic â€” perfect for height-based problems like **balance** and **diameter**.



---



Q. How diameter is addition of `left + right` ?

Here's a clear explanation of why:

---

### âœ… **Diameter = left height + right height**

#### ðŸ” Definition:

The **diameter** of a binary tree is:

> The **number of edges** in the **longest path** between any two nodes in the tree.


---

### ðŸ§  Why `left + right`?

When calculating diameter **at any node**, the longest path **through** that node will be:

```
(from the deepest node in left subtree)
        â†“
     [left subtree height]
        â†“
      current node
        â†“
     [right subtree height]
        â†“
(to the deepest node in right subtree)
```

So the total number of **edges** in that path is:

```
leftHeight + rightHeight
```

We check this at **every node** using postorder traversal, and **track the max** as we go.

---

### ðŸ“Œ Example:

For this simple tree:

```
      A
     / \
    B   C
   /     \
  D       E
```

* Longest path is: `D â†’ B â†’ A â†’ C â†’ E`
* Number of **edges** = 4
* At node `A`:

  * `leftHeight = 2` (from D)
  * `rightHeight = 2` (from E)
  * `diameter = 2 + 2 = 4` âœ”ï¸

---

### ðŸ§® Code snippet (Leetcode style):

```java
int diameter = 0;

int height(TreeNode node) {
    if (node == null) return 0;
    int left = height(node.left);
    int right = height(node.right);
    diameter = Math.max(diameter, left + right); // â† this is the key
    return 1 + Math.max(left, right);
}
```

---

> âœ… So yes â€” **diameter = left + right** because it represents the **maximum edge path** that spans both subtrees through a node.
