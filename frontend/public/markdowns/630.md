

### 1. **Infix Notation**

* **Operators** are placed **between** operands.
* Common in mathematics.
* Needs **parentheses** to manage precedence.
* Example: `3 + 4 * 2`

---

### 2. **Prefix Notation (==Polish Notation==)**

* **Operator comes before** operands.
* No parentheses needed.
* Evaluated **right to left** using a stack.
* Example: `+ 3 * 4 2` (equivalent to `3 + 4 * 2`)

---

### 3. **Postfix Notation (==Reverse Polish Notation, RPN==)**

* **Operator comes after** operands.
* Evaluated **left to right** using a stack.
* Example: `3 4 2 * +`


---

**Number of valid conversions** **between the 3 expression notations**:
‚úÖ **Infix**, **Prefix**, and **Postfix (RPN)**.



### üß† There are 3 formats ‚Üí Possible 2-way conversions between them:

We can compute it as the number of **directed pairs (A ‚Üí B)** where A ‚â† B:

#### Total pairs = `3 √ó (3 - 1) = 6`

Here are all 6 possible conversions:

1. **Infix ‚Üí Prefix**
2. **Infix ‚Üí Postfix**
3. **Prefix ‚Üí Infix**
4. **Prefix ‚Üí Postfix**
5. **Postfix ‚Üí Infix**
6. **Postfix ‚Üí Prefix**

---

‚úÖ **All 6 are valid and commonly used** in compiler design, stack evaluation problems, and expression parsers.


Let's take 

## üî¢ Original Infix Expression: 

- `A + B * C`

- `3 + 4 * 2`

---

### ‚úÖ 1. Infix ‚Üí Prefix

**Approach**:

1. **Reverse** the infix expression.
2. Swap `(` with `)` and vice versa.
3. Convert to **Postfix** (using standard stack logic).
4. Reverse the postfix to get **Prefix**.

---

#### Expression: `A + B * C`

#### Step-by-step:

* Reverse: `C * B + A`
* Swap `(` and `)`: (none)
* Convert to postfix: `C B * A +`
* Reverse postfix: `+ A * B C`

#### ‚úÖ ** Prefix** : `+ A * B C`


---

#### ‚û§ Converted Prefix: `+ 3 * 4 2`

#### üßÆ Evaluation (Right to Left):

Stack:

* `2` ‚Üí push
* `4` ‚Üí push
* `*` ‚Üí 4 √ó 2 = **8** ‚Üí push
* `3` ‚Üí push
* `+` ‚Üí 3 + 8 = **11**

‚úÖ **Answer**: `11`


---

```java
public class InfixToPrefix {
    public static String infixToPrefix(String infix) {
        StringBuilder reversed = new StringBuilder();
        for (int i = infix.length() - 1; i >= 0; i--) {
            char c = infix.charAt(i);
            if (c == '(') reversed.append(')');
            else if (c == ')') reversed.append('(');
            else reversed.append(c);
        }
        String postfix = InfixToPostfix.infixToPostfix(reversed.toString());
        return new StringBuilder(postfix).reverse().toString();
    }
}
```


---

### ‚úÖ 2. Infix ‚Üí Postfix

**Approach (Shunting Yard Algorithm)**:

1. Use a **stack** for operators and a **result string**.
2. For each token:

   * If operand ‚Üí append to result.
   * If operator ‚Üí pop stack till lower precedence or `(` found.
   * If `(` ‚Üí push to stack.
   * If `)` ‚Üí pop till `(`.
3. At end, pop remaining operators to result.

----

#### Expression: `A + B * C`

#### Step-by-step:

1. `A` ‚Üí operand ‚Üí output: `A`
2. `+` ‚Üí push to stack
3. `B` ‚Üí output: `A B`
4. `*` ‚Üí higher precedence ‚Üí push: `+ *`
5. `C` ‚Üí output: `A B C`
6. Pop `*` then `+` ‚Üí output: `A B C * +`

#### ‚úÖ **Postfix**: `A B C * +`

---

#### ‚û§ Converted Postfix: `3 4 2 * +`

#### üßÆ Evaluation (Left to Right):

Stack:

* `3` ‚Üí push
* `4` ‚Üí push
* `2` ‚Üí push
* `*` ‚Üí 4 √ó 2 = **8** ‚Üí push
* `+` ‚Üí 3 + 8 = **11**

‚úÖ **Answer**: `11`


----

```java
import java.util.*;

public class InfixToPostfix {
    public static String infixToPostfix(String s) {
        Stack<Character> stack = new Stack<>();
        StringBuilder output = new StringBuilder();

        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                output.append(c);
            } else if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(')
                    output.append(stack.pop());
                stack.pop(); // pop '('
            } else { // operator
                while (!stack.isEmpty() && precedence(c) <= precedence(stack.peek()))
                    output.append(stack.pop());
                stack.push(c);
            }
        }
        while (!stack.isEmpty())
            output.append(stack.pop());

        return output.toString();
    }

    static int precedence(char op) {
        return switch (op) {
            case '+', '-' -> 1;
            case '*', '/' -> 2;
            case '^' -> 3;
            default -> 0;
        };
    }
}
```




---

### ‚úÖ 3. Prefix ‚Üí Infix

**Approach**:

1. Traverse **right to left**.
2. If operand ‚Üí push to stack.
3. If operator ‚Üí pop two operands, form `"(op1 operator op2)"`, push back.

---

#### Expression: `+ A * B C`

#### Step-by-step (right to left):

1. `C` ‚Üí push
2. `B` ‚Üí push
3. `*` ‚Üí pop B, C ‚Üí push `(B * C)`
4. `A` ‚Üí push
5. `+` ‚Üí pop A, `(B * C)` ‚Üí push `(A + (B * C))`

#### ‚úÖ **Infix**: `(A + (B * C))`


---


#### ‚û§ Input: `+ 3 * 4 2`

#### ‚û§ Converted Infix: `(3 + (4 * 2))`

#### üßÆ Evaluation:

* `4 * 2 = 8`
* `3 + 8 = 11`

‚úÖ **Answer**: `11`


---



```java
import java.util.*;

public class PrefixToInfix {
    public static String prefixToInfix(String s) {
        Stack<String> stack = new Stack<>();
        for (int i = s.length() - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (Character.isLetterOrDigit(c)) {
                stack.push(String.valueOf(c));
            } else {
                String op1 = stack.pop();
                String op2 = stack.pop();
                stack.push("(" + op1 + c + op2 + ")");
            }
        }
        return stack.pop();
    }
}
```

---

### ‚úÖ 4. Prefix ‚Üí Postfix

**Approach**:

1. Traverse **right to left**.
2. If operand ‚Üí push.
3. If operator ‚Üí pop two, form `op1 op2 operator`, push back.

---

#### Expression: `+ A * B C`

#### Step-by-step (right to left):

1. `C` ‚Üí push
2. `B` ‚Üí push
3. `*` ‚Üí pop B, C ‚Üí push `B C *`
4. `A` ‚Üí push
5. `+` ‚Üí pop A, `B C *` ‚Üí push `A B C * +`

#### ‚úÖ **Postfix**: `A B C * +`

---

#### ‚û§ Input: `+ 3 * 4 2`

#### ‚û§ Converted Postfix: `3 4 2 * +`

#### üßÆ Evaluation:

Same as step 2:

* `4 * 2 = 8`
* `3 + 8 = 11`

‚úÖ **Answer**: `11`


---

```java
import java.util.*;

public class PrefixToPostfix {
    public static String prefixToPostfix(String s) {
        Stack<String> stack = new Stack<>();
        for (int i = s.length() - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (Character.isLetterOrDigit(c)) {
                stack.push(String.valueOf(c));
            } else {
                String op1 = stack.pop();
                String op2 = stack.pop();
                stack.push(op1 + op2 + c);
            }
        }
        return stack.pop();
    }
}
```



---

### ‚úÖ 5. Postfix ‚Üí Infix

**Approach**:

1. Traverse **left to right**.
2. If operand ‚Üí push.
3. If operator ‚Üí pop two, form `"(op1 operator op2)"`, push back.

---

#### Expression: `A B C * +`

#### Step-by-step (left to right):

1. `A` ‚Üí push
2. `B` ‚Üí push
3. `C` ‚Üí push
4. `*` ‚Üí pop B, C ‚Üí push `(B * C)`
5. `+` ‚Üí pop A, `(B * C)` ‚Üí push `(A + (B * C))`

#### ‚úÖ **Infix**: `(A + (B * C))`


---

#### ‚û§ Input: `3 4 2 * +`

#### ‚û§ Converted Infix: `(3 + (4 * 2))`

#### üßÆ Evaluation:

* `4 * 2 = 8`
* `3 + 8 = 11`

‚úÖ **Answer**: `11`


---



```java
import java.util.*;

public class PostfixToInfix {
    public static String postfixToInfix(String s) {
        Stack<String> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                stack.push(String.valueOf(c));
            } else {
                String op2 = stack.pop();
                String op1 = stack.pop();
                stack.push("(" + op1 + c + op2 + ")");
            }
        }
        return stack.pop();
    }
}
```



---

### ‚úÖ 6. Postfix ‚Üí Prefix

**Approach**:

1. Traverse **left to right**.
2. If operand ‚Üí push.
3. If operator ‚Üí pop two, form `operator op1 op2`, push back.

---

#### Expression: `A B C * +`

#### Step-by-step (left to right):

1. `A` ‚Üí push
2. `B` ‚Üí push
3. `C` ‚Üí push
4. `*` ‚Üí pop B, C ‚Üí push `* B C`
5. `+` ‚Üí pop A, `* B C` ‚Üí push `+ A * B C`

#### ‚úÖ **Prefix** : `+ A * B C`

---

#### ‚û§ Input: `3 4 2 * +`

#### ‚û§ Converted Prefix: `+ 3 * 4 2`

#### üßÆ Evaluation:

Same as step 1:

* `4 * 2 = 8`
* `3 + 8 = 11`

‚úÖ **Answer**: `11`


---



```java
import java.util.*;

public class PostfixToPrefix {
    public static String postfixToPrefix(String s) {
        Stack<String> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                stack.push(String.valueOf(c));
            } else {
                String op2 = stack.pop();
                String op1 = stack.pop();
                stack.push(c + op1 + op2);
            }
        }
        return stack.pop();
    }
}
```


----


Perfect! Now let's go through **all 6 expression conversions** from `3 + 4 * 2`, and for each one, include:

‚úÖ Converted expression
‚úÖ Step-by-step **evaluation with numbers**
‚úÖ Final **result = 11**

---


## üßæ Final Summary Table

| Conversion       | Converted Expression | Evaluated Result |
| ---------------- | -------------------- | ---------------- |
| Infix ‚Üí Prefix   | `+ 3 * 4 2`          | ‚úÖ `11`           |
| Infix ‚Üí Postfix  | `3 4 2 * +`          | ‚úÖ `11`           |
| Prefix ‚Üí Infix   | `(3 + (4 * 2))`      | ‚úÖ `11`           |
| Prefix ‚Üí Postfix | `3 4 2 * +`          | ‚úÖ `11`           |
| Postfix ‚Üí Infix  | `(3 + (4 * 2))`      | ‚úÖ `11`           |
| Postfix ‚Üí Prefix | `+ 3 * 4 2`          | ‚úÖ `11`           |


---

## C/Java Precedence Table 



## ‚úÖ **Operator Precedence Table**

| **Precedence** | **Operator**    | **Description**                                   | **Associativity**                          |               |               |
| -------------- | --------------- | ------------------------------------------------- | ------------------------------------------ | ------------- | ------------- |
| 1              | `()`            | Parentheses (function call)                       | ==Left-to-Right==                              |               |               |
|                | `[]`            | Array Subscript (Square Brackets)                 |                                            |               |               |
|                | `.`             | Dot Operator                                      |                                            |               |               |
|                | `->`            | Structure Pointer Operator                        |                                            |               |               |
|                | `++`, `--`      | Postfix increment, decrement                      |                                            |               |               |
| 2              | `++`, `--`      | Prefix increment, decrement                       | **Right-to-Left**                              |               |               |
|                | `+`, `-`        | Unary plus, minus                                 |                                            |               |               |
|                | `!`, `~`        | Logical NOT, Bitwise complement                   |                                            |               |               |
|                | `(type)`        | Cast Operator                                     |                                            |               |               |
|                | `*`             | Dereference Operator                              |                                            |               |               |
|                | `&`             | Addressof Operator                                |                                            |               |               |
|                | `sizeof`        | Determine size in bytes                           |                                            |               |               |
| 3              | `*`, `/`, `%`   | Multiplication, division, modulus                 | ==Left-to-Right==                              |               |               |
| 4              | `+`, `-`        | Addition, subtraction                             | ==Left-to-Right==                              |               |               |
| 5              | `<<`, `>>`      | Bitwise shift left, Bitwise shift right           | ==Left-to-Right==                              |               |               |
| 6              | `<`, `<=`       | Relational less than, less than or equal to       | ==Left-to-Right==                              |               |               |
|                | `>`, `>=`       | Relational greater than, greater than or equal to |                                            |               |               |
| 7              | `==`, `!=`      | Relational is equal to, is not equal to |            ==Left-to-Right==                              |               |               |
| 8              | `&`             | Bitwise AND                                       | ==Left-to-Right==                              |               |               |
| 9              | `^`             | Bitwise exclusive OR                              | ==Left-to-Right==                              |               |               |
| 10             | `\|`              |  Bitwise inclusive OR                           | ==Left-to-Right== |               |
| 11             | `&&`            | Logical AND                                       | ==Left-to-Right==                              |               |               |
| 12             | `\|\|`             |    Logical OR                                                                                   | ==Left-to-Right== |
| 13             | `?:`            | Ternary conditional                               | **Right-to-Left**                              |               |               |
| 14             | `=` | Assignment                                        | **Right-to-Left**                              |               |               |
|                | `+=`, `-=`      | Addition, subtraction assignment               |                                            |               |               |
|                | `*=`, `/=`      | Multiplication, division assignment               |                                            |               |               |
|                | `%=`, `&=`      | Modulus, bitwise AND assignment                   |                                            |               |               |
|                | `^=`, `\|=`                                                       | Bitwise exclusive, inclusive OR assignment
|                | `<<=`, `>>=`    | Bitwise shift left, right assignment              |                                            |               |               |
| 15             | `,`             | Comma (expression separator)                      | ==Left-to-Right==                              |               |               |

---


### üß† Tips:

* **Parentheses** `()` override everything.
* **Right to Left** associativity is important for things like exponentiation and assignment.
* Exponentiation is not always supported in all languages as `^`; in Python, it‚Äôs `**`.

Great question!

### ‚úÖ **Left to Right** vs **Right to Left** associativity:

These define the **order in which operators of the same precedence are evaluated** in an expression.

---

### üîÅ **Left to Right (L ‚Üí R)**

* Evaluate **leftmost operator first**, then move right.
* Most common (used for `+`, `-`, `*`, `/`, etc.)

#### üîç Example:

```txt
5 - 3 - 1
```

* All `-` operators have the same precedence.
* Associativity is **Left to Right**, so:

```
(5 - 3) - 1 = 2 - 1 = 1 ‚úÖ
```

---

### üîÅ **Right to Left (R ‚Üí L)**

* Evaluate **rightmost operator first**, then move left.
* Used for **assignment**, **exponentiation**, **unary ops**, etc.

#### üîç Example:

```txt
2 ^ 3 ^ 2
```

* `^` is **Right to Left**, so:

```
2 ^ (3 ^ 2) = 2 ^ 9 = 512 ‚úÖ
```

---

### üß† Simple Summary:

| Associativity | Evaluates First |
| ------------- | --------------- |
| Left to Right | Left operator   |
| Right to Left | Right operator  |

Let me know if you want visual diagrams or practice examples.
