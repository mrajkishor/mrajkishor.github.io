Here are the **most common interview questions with answers** on the core OOPs pillars — **Inheritance, Abstraction, Polymorphism, and Encapsulation** — especially relevant for Java Full Stack interviews like Wipro (7+ years of experience level):

---

### ✅ **1. What is Inheritance in Java?**

**Answer:**
Inheritance is a mechanism where one class (**child/subclass**) inherits fields and methods from another class (**parent/superclass**). It promotes code reuse and establishes an **IS-A** relationship.

```java
class Animal {
    void sound() { System.out.println("Generic sound"); }
}

class Dog extends Animal {
    void bark() { System.out.println("Bark"); }
}
```

Here, `Dog` inherits `sound()` from `Animal`. So, `Dog IS-A Animal`.

---

### ✅ **2. What are the types of inheritance supported in Java?**

**Answer:**
Java supports the following types of inheritance:

* **Single Inheritance:** One subclass inherits one superclass.
* **Multilevel Inheritance:** Class inherits from a class that has inherited another class.
* **Hierarchical Inheritance:** Multiple classes inherit from one superclass.

> ⚠️ Java **does not support multiple inheritance with classes** (to avoid ambiguity). It supports multiple inheritance via **interfaces**.

---

### ✅ **3. What is Abstraction? How is it implemented in Java?**

**Answer:**
Abstraction means **hiding internal implementation** and **exposing only relevant details**.

It is achieved in Java via:

* **Abstract classes** (using `abstract` keyword)
* **Interfaces**

**Example:**

```java
interface Vehicle {
    void start();
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car started");
    }
}
```

The user doesn't need to know how the engine works — only that `start()` will work.

---

### ✅ **4. Difference between Abstraction and Encapsulation?**

| Feature      | Abstraction                        | Encapsulation                 |
| ------------ | ---------------------------------- | ----------------------------- |
| Purpose      | Hides **implementation logic**     | Hides **data/internal state** |
| Achieved via | Interfaces, abstract classes       | Classes with private fields   |
| Focus        | What to do                         | How to do it                  |
| Example      | `List`, `Map`, `Stream` interfaces | POJO with getters/setters     |

---

### ✅ **5. What is Encapsulation in Java?**

**Answer:**
Encapsulation means **binding data and methods** into a single unit (class), and **restricting direct access** to the internals of that class using access modifiers like `private`.

**Example:**

```java
public class Employee {
    private int salary;

    public int getSalary() { return salary; }
    public void setSalary(int salary) {
        if (salary > 0) this.salary = salary;
    }
}
```

You control access to `salary` using setters/getters — that's encapsulation.

---

### ✅ **6. What is Polymorphism in Java?**

**Answer:**
Polymorphism means **"many forms"**. In Java, it allows an object to behave differently based on context.

**Types:**

* **Compile-Time Polymorphism** (Method Overloading)
* **Runtime Polymorphism** (Method Overriding)

**Example:**

```java
// Overloading (compile-time)
void draw(int radius) {}
void draw(String shape) {}

// Overriding (runtime)
class Animal {
    void sound() { System.out.println("Sound"); }
}
class Dog extends Animal {
    void sound() { System.out.println("Bark"); }
}
```

---

### ✅ **7. What is Method Overloading vs Method Overriding?**

| Feature     | Overloading                     | Overriding                     |
| ----------- | ------------------------------- | ------------------------------ |
| Timing      | Compile-time                    | Runtime                        |
| Signature   | Same name, different parameters | Same signature                 |
| Inheritance | Not required                    | Requires parent-child relation |
| Return Type | Can vary                        | Must be same (or covariant)    |

---

### ✅ **8. How does Java resolve method calls at runtime?**

**Answer:**
Using **Dynamic Method Dispatch**, Java decides at runtime which overridden method to execute — based on the actual object’s type (not the reference type).

```java
Animal a = new Dog();
a.sound(); // prints "Bark" because actual object is Dog
```

---

### ✅ **9. What is the use of `super` and `this` in OOPs?**

**Answer:**

* `this` refers to **current class instance**.
* `super` refers to **immediate parent class**.

**Use Cases:**

* `this.variable` → resolves naming conflict
* `this()` → calls another constructor
* `super()` → calls parent constructor
* `super.method()` → call overridden parent method

---

### ✅ **10. What is IS-A and HAS-A relationship in OOP?**

**Answer:**

* **IS-A:** Inheritance (`Dog IS-A Animal`)
  Achieved via `extends` or `implements`

* **HAS-A:** Composition (`Car HAS-A Engine`)
  Achieved by including one class as a field in another

```java
class Engine {}
class Car {
    Engine engine = new Engine(); // HAS-A
}
```

---

Would you like a **PDF version** of these, or want the same for **Java 8 + Collections + Concurrency** as well?
