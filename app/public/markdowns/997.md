

## **ACID Properties**

---

### üîπ What is a Transaction?

A **transaction** is a **sequence of one or more database operations** treated as a single **logical unit of work**. For example:

```sql
BEGIN;
UPDATE account SET balance = balance - 1000 WHERE id = 101;
UPDATE account SET balance = balance + 1000 WHERE id = 202;
COMMIT;
```

Even though there are two SQL statements, the transaction should either **succeed entirely** or **fail entirely**. That is guaranteed by **ACID properties**.

---

## üî• What are ACID Properties?

**ACID** stands for:

| Property            | Purpose                                  |
| ------------------- | ---------------------------------------- |
| **A** ‚Äì Atomicity   | All-or-nothing execution                 |
| **C** ‚Äì Consistency | Valid state transitions                  |
| **I** ‚Äì Isolation   | Concurrent transactions do not interfere |
| **D** ‚Äì Durability  | Committed data persists after crash      |

Let‚Äôs explore each:

---

### 1Ô∏è‚É£ **Atomicity** ‚Äì *"All or Nothing"*

> Ensures that a transaction **executes completely** or **has no effect at all**.

üîç **Example**:
If a power failure occurs after debiting ‚Çπ1000 but before crediting the other account, the system **rolls back** the transaction.

üìå **Handled by**:

* **Undo logs**
* **Transaction rollback**
* Recovery manager

---

### 2Ô∏è‚É£ **Consistency** ‚Äì *"Preserve Data Integrity"*

> Ensures that a transaction brings the **database from one valid state to another**.

üéØ It ensures **integrity constraints** (like foreign keys, balance ‚â• 0) are not violated.

üîç **Example**:
If a constraint requires that total bank balance remains constant, consistency ensures it before and after a transfer.

üìå **Who ensures this?**

* Application logic (you!)
* Constraints in schema (DBMS enforces)

---

### 3Ô∏è‚É£ **Isolation** ‚Äì *"Transactions Should Appear Serial"*

> Ensures that **concurrent transactions** produce the **same result as serial execution**.

üìå Key Concepts:

* **Serial schedule**: Transactions execute one after another
* **Concurrent schedule**: Interleaved operations, but outcome must be **conflict-serializable**

üîç **Example**:
Two users booking the last movie seat simultaneously ‚Äî isolation ensures **only one gets the seat**.

üìå **Enforced by**:

* **Locks (2PL)** ‚Äì Two-Phase Locking
* **Timestamp ordering**
* **MVCC** (Multi-Version Concurrency Control)

---

### 4Ô∏è‚É£ **Durability** ‚Äì *"Once Committed, Always Exists"*

> Guarantees that **committed changes** are **not lost**, even if system crashes.

üìå Mechanisms:

* **Write-ahead logging (WAL)** ‚Äì logs are flushed before actual data
* **Checkpoints** ‚Äì ensure partial transactions don‚Äôt get replayed

üîç **Example**:
After a bank transfer commits, even a sudden crash won‚Äôt revert the balances.

---

## üí° Real GATE-Level Question Types

| Concept Tested | Sample GATE Question                                    |
| -------------- | ------------------------------------------------------- |
| Atomicity      | What happens if a crash occurs midway in a transaction? |
| Consistency    | Given a transaction, is the constraint preserved?       |
| Isolation      | Schedule-based questions on serializability/conflicts   |
| Durability     | Asked in crash recovery and logging concepts            |

---

## üîÅ Summary Table

| Property    | Guarantee                      | Technique Used                    |
| ----------- | ------------------------------ | --------------------------------- |
| Atomicity   | All or nothing                 | Undo logs, rollback               |
| Consistency | Valid state transitions        | Schema constraints, triggers      |
| Isolation   | Transactions behave serially   | Locking (2PL), Timestamp ordering |
| Durability  | Persistence after commit/crash | WAL, Checkpointing, Shadow Paging |

---

## Use case, case study and STAR: 

Here is a **real-world use case, an enterprise case study**, and a **STAR-format story** on:

---


## ‚úÖ Use Case: **Online Banking ‚Äì Fund Transfer Between Accounts**

When a user transfers money from **Account A to Account B**, the system must:

1. **Debit** amount from Account A.
2. **Credit** amount to Account B.

### Why ACID is critical:

* **Atomicity**: Both debit and credit must succeed, or neither should happen.
* **Consistency**: Total balance in the system remains the same before and after.
* **Isolation**: Concurrent transfers must not interfere or cause double-spends.
* **Durability**: Once confirmed, the transfer must persist even if the system crashes.

Without ACID:

* Money might get debited from A but not credited to B (partial updates).
* Two parallel transfers might read stale balances and overdraft.
* A crash after debit might lose the credit update permanently.

---

## üè¢ Case Study: **ACID Enforcement in PayPal‚Äôs Transaction Engine**

### Context:

PayPal's financial systems handle **millions of concurrent financial transactions daily**. Data correctness is mission-critical ‚Äî a single anomaly can cause **monetary loss, legal exposure, and user distrust**.

### How PayPal applied ACID:

* Used **ACID-compliant RDBMS** (Oracle, later PostgreSQL and distributed SQL like CockroachDB).
* Every transaction (purchase, refund, transfer) is wrapped in **multi-statement transactions** using stored procedures.
* **Atomicity** is enforced by rolling back on business logic failures (e.g., insufficient funds).
* **Consistency** is ensured by applying referential constraints and business rules (e.g., currency match).
* **Isolation** is handled with **Serializable or Repeatable Read** isolation to avoid dirty reads in financial flows.
* **Durability** is ensured using **WAL + replication** so that even in the event of node failure, committed transactions are not lost.

### Outcome:

* Achieved near-zero inconsistency in transactions.
* Improved trust in multi-party payments (e.g., marketplace use cases).
* Enabled compliance with **SOX and PCI DSS**, which demand strict ACID guarantees.

---

## üåü STAR Format Story (Real-world scenario)

> üéØ **SITUATION**:
> At my previous company, we built a **payment processing system** for a large e-commerce client. One critical feature was enabling **wallet-to-wallet transfers** between users ‚Äî a seemingly simple operation but one that had **real money risk** involved.

---

> üß≠ **TASK**:
> I was responsible for designing the **transactional flow** in the backend and ensuring that **no money could be lost or duplicated** ‚Äî even in the case of **system crashes or concurrent operations**.

---

> ‚öôÔ∏è **ACTION**:

* I implemented the fund transfer logic using a **SQL transaction block** in PostgreSQL.
* Inside the block, we **first debited** the sender‚Äôs wallet and then **credited** the receiver.
* To enforce **atomicity**, any failure (like insufficient funds) would trigger a rollback.
* For **isolation**, we used the `SERIALIZABLE` level during high-load spikes to avoid race conditions.
* To ensure **durability**, we validated that the transaction persisted via WAL before notifying the user.
* I also added **retry logic** with exponential backoff for deadlocks caused by concurrent transactions.

---

> ‚úÖ **RESULT**:

* The system processed over **10 million transfers** in the first year with **zero transactional anomalies**.
* It passed a **3rd-party security audit** focused on data integrity and was certified for **PCI DSS compliance**.
* The client publicly highlighted it in their annual tech report for its robustness and precision under scale.

---

## üí¨ Final Tip for Interviews:

When discussing ACID in interviews:

* **Avoid textbook definitions alone** ‚Äî use scenarios (banking, e-commerce, travel booking).
* Emphasize **failure scenarios and how ACID prevents data corruption**.
* Back it up with **SQL-level implementation techniques** (e.g., BEGIN...COMMIT...ROLLBACK, isolation levels, retry on deadlock).

---


### ==A **PostgreSQL transaction implementation** for this use case==


Here is a **PostgreSQL transaction implementation** for the **wallet-to-wallet fund transfer use case**, designed with **full ACID compliance** in mind:

---

## üè¶ Use Case: Transfer ‚Çπ100 from User A to User B

---

### ‚úÖ **Table Structure (Simplified)**

```sql
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);

CREATE TABLE wallets (
    user_id INT PRIMARY KEY REFERENCES users(user_id),
    balance NUMERIC(12, 2) NOT NULL CHECK (balance >= 0)
);

CREATE TABLE transactions (
    transaction_id SERIAL PRIMARY KEY,
    sender_id INT REFERENCES users(user_id),
    receiver_id INT REFERENCES users(user_id),
    amount NUMERIC(12, 2),
    status TEXT CHECK (status IN ('SUCCESS', 'FAILED')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

---

### ‚öôÔ∏è **PostgreSQL Transaction Implementation**

```sql
-- Assume sender_id = 1, receiver_id = 2, amount = 100.00

BEGIN;

-- Step 1: Lock both wallet rows to avoid race conditions
SELECT * FROM wallets WHERE user_id IN (1, 2) FOR UPDATE;

-- Step 2: Check sender's balance
-- Note: If this block throws an error, PostgreSQL will automatically ROLLBACK the whole transaction
DO $$
DECLARE
    sender_balance NUMERIC;
BEGIN
    SELECT balance INTO sender_balance FROM wallets WHERE user_id = 1;

    IF sender_balance < 100.00 THEN
        -- Not enough funds ‚Üí rollback
        INSERT INTO transactions (sender_id, receiver_id, amount, status)
        VALUES (1, 2, 100.00, 'FAILED');
        
        -- Rollback by raising exception
        RAISE EXCEPTION 'Insufficient funds';

        -- Or, you can manually rollback (if you want more control)
        -- Start code...
        -- ROLLBACK;
        -- Optionally raise notice or return a status from your app layer
        -- RETURN;
        -- ..enD code

    END IF;
END $$;

-- Step 3: Debit sender
UPDATE wallets
SET balance = balance - 100.00
WHERE user_id = 1;

-- Step 4: Credit receiver
UPDATE wallets
SET balance = balance + 100.00
WHERE user_id = 2;

-- Step 5: Log successful transaction
INSERT INTO transactions (sender_id, receiver_id, amount, status)
VALUES (1, 2, 100.00, 'SUCCESS');

-- Step 6: Commit the transaction
COMMIT;
```

---

### üí° Key Points on ACID Compliance

| Property        | How It's Achieved                                           |
| --------------- | ----------------------------------------------------------- |
| **Atomicity**   | Either all steps succeed, or none (`BEGIN/COMMIT/ROLLBACK`) |
| **Consistency** | Wallets always maintain valid balances via constraints      |
| **Isolation**   | `FOR UPDATE` prevents dirty reads and lost updates          |
| **Durability**  | PostgreSQL uses **WAL (Write-Ahead Log)** to persist data   |

---

### üîÅ Optional Enhancements (Production-Grade)

* Add **retry logic in application layer** for deadlocks (`SerializationFailure`).
* Use **SAVEPOINTS** if you want to recover from sub-block errors inside transaction.
* Wrap into a **stored procedure or transaction function** for reusability.

