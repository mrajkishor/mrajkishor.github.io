

#  **B-Tree (Balanced Tree)**

---

## 🧠 What is a B-Tree?

A **B-Tree** is a **self-balancing, multi-level search tree** used for organizing large datasets on disk. It maintains sorted data and allows **logarithmic time** complexity for **search, insert, and delete** operations.

It is ideal for **disk-based storage systems** like databases and file systems because it reduces disk I/O by keeping the tree shallow.

---

## 🧬 **B-Tree Properties (Order *m*)**

A B-Tree of **order *m*** (also called *m-way B-Tree*) follows these rules:

1. **Every node** can have **at most *m* children**.
2. **Every internal node** (non-leaf) has **at least ⌈m/2⌉ children**, except the root.
3. **Every node (except root)** contains at least **⌈m/2⌉ − 1 keys**.
4. **Each node** with *k* children has exactly **k − 1 keys**.
5. **All leaves appear at the same depth**.
6. **Keys within nodes are sorted in increasing order**.

---

## 📦 **Structure of a B-Tree Node**

Each node contains:

* An array of **keys**: `K1 < K2 < K3 < ... < Kn`
* An array of **child pointers**: `C0, C1, ..., Cn`

  * All values in subtree `C0` are `< K1`
  * All values in subtree `Ci` are between `Ki` and `Ki+1`
  * All values in subtree `Cn` are `> Kn`

---

## 🔍 **Search Operation**

To search for key `K`:

1. Start at the root.
2. Perform binary or linear search within node keys.
3. If key is found → return.
4. Else → follow the pointer to the correct child and repeat.

### ⏱ Time Complexity:

* **O(logₘ N)**, where `N` is the number of keys and `m` is the order of the tree (i.e., fan-out).

---

## ➕ **Insertion Operation**

1. **Search** for the correct leaf node where key should be inserted.
2. **Insert** the key in sorted order.
3. If the node **overflows** (more than `m−1` keys):

   * **Split** the node into two halves.
   * **Promote** the middle key to the parent node.
   * If parent overflows → recursively split up to root.
4. If root splits → create a new root.

### 📌 Note:

This **preserves balance** and ensures **logarithmic depth**.

---

## ➖ **Deletion Operation**

Deleting a key involves three cases:

1. **Key in leaf node (no underflow):** Remove directly.
2. **Key in internal node:** Replace with **in-order predecessor/successor**, then delete recursively.
3. **Underflow (fewer than ⌈m/2⌉−1 keys)**:

   * **Borrow** key from sibling (left/right) if it has more than minimum.
   * Else, **merge** with sibling and **pull down** a key from parent.

---

## 📋 **Example (Order 4 B-Tree)**

```
         [17 | 35]
        /    |     \
   [5 10] [20 25] [40 50 60]
```

* Root has 2 keys → 3 children
* Children have 2 or 3 keys (within allowed limits)
* All leaves are at the same level

---

## ✅ **Advantages of B-Trees**

| Feature                | Description                                           |
| ---------------------- | ----------------------------------------------------- |
| **Shallow height**     | Reduces disk I/O due to fewer node accesses           |
| **Balanced structure** | Keeps search time logarithmic                         |
| **Efficient inserts**  | Handles large datasets without rebalancing whole tree |
| **Disk-friendly**      | Nodes can match disk block size to minimize I/O       |

---

## ❌ **Disadvantages**

* Slightly slower for in-memory search compared to binary search trees.
* Complex deletion and merging logic.
* Internal nodes store both keys and values, increasing memory usage compared to B+ Trees.

---

## 🆚 **B-Tree vs Binary Search Tree (BST)**

| Feature           | B-Tree                | BST                      |
| ----------------- | --------------------- | ------------------------ |
| Children per node | `m` (multi-way)       | 2 (binary)               |
| Tree height       | Logarithmic (shallow) | Can become skewed (deep) |
| Disk optimized    | ✅ Yes                 | ❌ No                     |
| Balanced          | Always                | Not always               |

---

## 🆚 **B-Tree vs B+ Tree**

| Feature                | B-Tree                | B+ Tree                            |
| ---------------------- | --------------------- | ---------------------------------- |
| Data in internal nodes | ✅ Yes                 | ❌ No (only in leaves)              |
| Range queries          | Slower                | Faster (linked leaves)             |
| Sequential access      | ❌ Not efficient       | ✅ Very efficient                   |
| Space overhead         | Less (no duplication) | Slightly more (keys repeated)      |
| Common usage           | Rare                  | Widely used in DBMS & file systems |

---

## 🔧 **Use Cases of B-Trees**

* Indexing in older DBMS
* File systems (e.g., NTFS, HFS+)
* Sorted associative containers in memory
* Searching large blocks in external memory (e.g., SSD/HDD)

---

## 🧠 Summary

* B-Trees are **generalized BSTs** designed for **disk access efficiency**.
* They maintain a balanced, shallow structure to optimize **search, insert, and delete**.
* Ideal when the cost of disk I/O dominates performance.

