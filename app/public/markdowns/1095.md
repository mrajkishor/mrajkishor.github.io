
# **B and B+ Trees**

---

## 🧠 **Introduction**

Efficient indexing is crucial for fast data access. **B-Trees** and **B+ Trees** are balanced tree-based indexing structures widely used in database systems to support logarithmic-time **search**, **insert**, **delete**, and **range queries**.

---

## 🌳 **B-Trees (Balanced Trees)**

### ✅ **Definition:**

A **B-Tree** is a self-balancing multi-way search tree that keeps data sorted and allows searches, sequential access, insertions, and deletions in **O(log n)** time.

### 🔹 **Properties of B-Tree (order `m`)**:

* Each node can have **at most `m` children** and **at least ⌈m/2⌉ children** (except root).
* A node with `k` children contains `k−1` keys.
* All **leaves appear at the same level**.
* **Internal nodes** store both keys and pointers to child nodes.
* **Keys guide the search path** — values are stored **within internal and leaf nodes**.

---

### 📋 **Example (B-Tree of order 3):**

```
        [20]
       /    \
   [10]     [30, 40]
```

* Keys: 10, 20, 30, 40
* Searching for 30: Start at root → right child → locate key

---

### ✅ **Operations:**

* **Search**: Navigate from root to appropriate child node using key comparisons.
* **Insert**: Place key in appropriate node; if overflow, **split node**.
* **Delete**: Remove key; if underflow, **merge or redistribute** nodes.

---

## ➕ **B+ Trees (Extended B-Trees)**

### ✅ **Definition:**

A **B+ Tree** is an **extension of B-Tree** where:

* **All keys are stored only in leaf nodes**
* Internal nodes store **only routing keys**
* Leaf nodes are linked using **pointers for fast range access**

### 🔹 **Properties of B+ Tree (order `m`)**:

* Internal nodes: up to `m` children and `m−1` keys
* **All data records appear in leaf nodes only**
* Leaf nodes are **linked sequentially** (linked list style)
* **Supports efficient range queries**

---

### 📋 **Example:**

```
      [20 | 40]
      /   |   \
 [5,10] [25,30] [45,50]
   ↔       ↔        ↔
```

* Search for 30: root → 40 → \[25,30] → found
* Range query (25–50): Directly follow leaf node pointers

---

## 🔁 **B vs B+ Tree – Key Differences**

| Feature            | B-Tree                      | B+ Tree                                   |
| ------------------ | --------------------------- | ----------------------------------------- |
| Data location      | Internal & Leaf nodes       | Leaf nodes only                           |
| Internal node role | Stores keys and values      | Stores only keys (routing)                |
| Range queries      | Slower (must traverse tree) | Faster (linked leaves)                    |
| Sequential access  | Not efficient               | Highly efficient                          |
| Space utilization  | Slightly better             | Slightly worse (duplicate keys in leaves) |
| Search performance | Good                        | Excellent (less tree height)              |

---

## 🧪 **GATE Insights & MCQ Hints**

* 🔹 If **range queries** are needed → Prefer **B+ Tree**
* 🔹 B+ Tree is used in **most modern DBMS** (e.g., PostgreSQL, MySQL)
* 🔹 In **B+ Tree**, internal nodes are **always index only**, not data
* 🔹 **Fan-out** (number of children) determines the tree height

---

## 📐 **Height Analysis**

If:

* **n = number of records**
* **m = max number of children per node**

Then:

* Height of B-Tree: ≈ **logₘ(n)**
* Height of B+ Tree: ≈ **logₘ(n)** (slightly less because more entries in leaves)

---

## ✅ Summary

| Criteria           | B-Tree                | B+ Tree         |
| ------------------ | --------------------- | --------------- |
| Search Complexity  | O(log n)              | O(log n)        |
| Data Storage       | Internal + Leaf Nodes | Leaf Nodes Only |
| Range Queries      | Less Efficient        | More Efficient  |
| Used in DB Systems | Less Common           | Very Common     |

---

## 🧠 Final Tip

> **Always use B+ Trees in database systems** when range scans or ordered iteration over keys is important — which is almost always true for relational DBMS.


