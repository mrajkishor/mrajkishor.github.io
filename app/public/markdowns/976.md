

# **Typing Props and State**

Working with **TypeScript in React** greatly enhances type safety and developer experience. When building components, two primary places where types matter most are:

1. **Props** ‚Äì data passed from parent to child
2. **State** ‚Äì local data managed within the component

Understanding how to **type both props and state** correctly can help prevent bugs, improve code readability, and make the codebase easier to maintain in large applications.

---

## ‚úÖ Why Type Props and State?

* Prevents runtime bugs (e.g. `undefined` props)
* IDEs give better **autocomplete**, **type hints**, and **documentation**
* Forces developers to think through component contracts
* Enables refactoring with confidence

---

## üß© Typing Props

Props are the external inputs to a component. To type them, you define a **TypeScript interface or type alias** and pass it to the component as a generic.

### üîπ Function Component Example:

```tsx
type UserCardProps = {
  name: string;
  age?: number; // optional prop
  isActive: boolean;
};

const UserCard: React.FC<UserCardProps> = ({ name, age, isActive }) => {
  return (
    <div>
      <h2>{name}</h2>
      {age && <p>Age: {age}</p>}
      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
};
```

> ‚úÖ `React.FC` automatically includes `children` as a prop
> 
> ‚ö†Ô∏è Some teams avoid `React.FC` due to its limitations (e.g., incorrect typing of defaultProps or generics), and prefer inline typing:

```tsx
const UserCard = ({ name, age, isActive }: UserCardProps) => {
  // ...
};
```

For detailed explanation. [See More](#reference-1)...


---

## üß† Tip: Optional vs Required Props

* `age?: number` ‚Üí Optional
* `name: string` ‚Üí Required

You can also set default values for props using default parameters or `defaultProps` (in older versions).

---

## üì¶ Typing State

State is the internal data of a component. You typically define the state‚Äôs shape using a TypeScript type or interface and pass it to the `useState` hook.

### üîπ Example with `useState`:

```tsx
const Counter: React.FC = () => {
  const [count, setCount] = useState<number>(0); // Explicitly typed

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
};
```

> ‚úÖ You can also infer types automatically from initial state, but it‚Äôs better to type explicitly for clarity.

---

## üéØ Typing State as an Object

When your state is more complex (like a form or a record), use an interface:

```tsx
interface FormState {
  username: string;
  password: string;
}

const LoginForm: React.FC = () => {
  const [form, setForm] = useState<FormState>({
    username: '',
    password: ''
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setForm(prev => ({ ...prev, [name]: value }));
  };

  return (
    <>
      <input name="username" value={form.username} onChange={handleChange} />
      <input name="password" value={form.password} onChange={handleChange} />
    </>
  );
};
```

---

## üìå Key Patterns

| Concept        | Pattern                                      |
| -------------- | -------------------------------------------- |
| Prop Typing    | `type Props = { ... }`                       |
| State Typing   | `const [state, setState] = useState<Type>()` |
| Optional Props | `propName?: Type`                            |
| Default Props  | Set defaults in parameters or destructuring  |
| React.FC       | `React.FC<Props>` adds `children` by default |

---

## üîê Bonus: Typing Props with Generics

```tsx
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

function List<T>({ items, renderItem }: ListProps<T>) {
  return <ul>{items.map(renderItem)}</ul>;
}
```

This makes your component reusable for any data type ‚Äî a powerful pattern in UI libraries.

---

## ‚ö†Ô∏è Common Mistakes

* Forgetting to type `useState` when initial value is `null` or `undefined`
* Using `any` too liberally ‚Äî defeats the purpose of TypeScript
* Not handling optional props properly
* Relying on `React.FC` when generics or complex types are involved

---

## üß† Final Thoughts

Typing props and state is **not just about TypeScript** ‚Äî it‚Äôs about designing clear component boundaries and data contracts. As applications grow, this clarity becomes critical for collaboration, testing, and maintainability.

> üí° "When in doubt, type it out."

---



## Reference [1]

Here's a clear example that **proves** how `React.FC` automatically includes the `children` prop, and why some teams **avoid using it** in favor of manual prop typing.

---

## ‚úÖ **Proof: `React.FC` includes `children` by default**

### üîπ Using `React.FC`

```tsx
import React from 'react';

type MyComponentProps = {
  title: string;
};

const MyComponent: React.FC<MyComponentProps> = ({ title, children }) => {
  return (
    <div>
      <h1>{title}</h1>
      <div>{children}</div> {/* ‚úÖ Works without explicitly defining `children` in props */}
    </div>
  );
};

// Usage
<MyComponent title="Hello">
  <p>This is a child element</p>
</MyComponent>;
```

### ‚úÖ Output:

The component renders with the title and child paragraph as expected. No TypeScript error, **even though `children` was not declared explicitly in `MyComponentProps`**.

---

## ‚ö†Ô∏è **Why some teams avoid `React.FC`**

### 1. **Typing `children` manually gives more control**

```tsx
type MyComponentProps = {
  title: string;
  children?: React.ReactNode;
};

const MyComponent = ({ title, children }: MyComponentProps) => {
  return (
    <div>
      <h1>{title}</h1>
      {children}
    </div>
  );
};
```

With this style:

* You can **omit** `children` if not used
* You can specify it as required (`children: React.ReactNode`) or optional (`children?: ...`)
* It's explicit and better for **documentation and readability**

[See more use cases...](#reference-2)

---

### 2. **Problem with `defaultProps` (deprecated behavior)**

```tsx
type Props = {
  message?: string;
};

const Greeting: React.FC<Props> = ({ message }) => {
  return <h2>{message}</h2>;
};

Greeting.defaultProps = {
  message: "Hi from default props!",
};

// ‚ùå With `React.FC`, defaultProps are not correctly inferred in newer TypeScript versions
```

### ‚úÖ Better (no `React.FC`):

```tsx
type Props = {
  message?: string;
};

const Greeting = ({ message = "Hi from default props!" }: Props) => {
  return <h2>{message}</h2>;
};
```

---

### 3. **Problem with Generics**

```tsx
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

// ‚ùå Using React.FC with generics causes complexity and confusion
const List: React.FC<ListProps<string>> = ({ items, renderItem }) => {
  return <ul>{items.map(renderItem)}</ul>;
};
```

‚ö†Ô∏è The above works, but using `React.FC` with generics can result in hard-to-read types and bugs in inference. It‚Äôs better to write:

```tsx
function List<T>({ items, renderItem }: ListProps<T>) {
  return <ul>{items.map(renderItem)}</ul>;
}
```

---

## ‚úÖ Summary

| Feature                | `React.FC`                   | Manual Typing (`type Props`)       |
| ---------------------- | ---------------------------- | ---------------------------------- |
| Includes `children`    | ‚úÖ Automatically              | ‚ùå Must be added explicitly         |
| Supports generics well | ‚ö†Ô∏è Awkward syntax            | ‚úÖ Clean and flexible               |
| Handles defaultProps   | ‚ö†Ô∏è Inconsistent in TS >= 3.0 | ‚úÖ Best with destructuring defaults |
| IDE readability        | ‚úÖ But verbose with generics  | ‚úÖ Cleaner, more explicit           |
| Community trend        | üëé Falling out of favor      | üëç Preferred for better control    |

---


## Reference [2]

There **are other important use cases** where typing `children` manually using:

```ts
children?: React.ReactNode
```

(or `children: React.ReactNode`) becomes essential, **beyond just optional vs required**.

Here‚Äôs a complete breakdown:

---

## ‚úÖ 1. **Control Whether `children` Is Optional or Required**

We‚Äôve already discussed this, but to restate:

```ts
children?: React.ReactNode; // optional
children: React.ReactNode;  // required
```

You **cannot control this** with `React.FC`, which always makes it optional.

---

## ‚úÖ 2. **Restrict the Type of Children (not just any ReactNode)**

You can be precise about what kind of children are allowed.

### üîπ Example: Only allow a single `string`

```ts
type Props = {
  children: string;
};

const Label = ({ children }: Props) => <label>{children}</label>;

// ‚úÖ Valid: <Label>Username</Label>
// ‚ùå Invalid: <Label><b>Bold</b></Label>
```

---

## ‚úÖ 3. **Allow Only One Child (`ReactElement`)**

Use this when you want to enforce a single, valid child ‚Äî not a fragment or list.

```ts
import { ReactElement } from 'react';

type Props = {
  children: ReactElement;
};

const Wrapper = ({ children }: Props) => <div>{children}</div>;

// ‚úÖ Valid: <Wrapper><Component /></Wrapper>
// ‚ùå Invalid: <Wrapper><Component /><Component /></Wrapper>
```

---

## ‚úÖ 4. **Restrict Children to Specific Component Types**

You can limit the allowed children to specific components using `ReactElement<typeof Component>`.

### üîπ Example: Only accept `<TabPanel />` components inside `<Tabs>`

```ts
import { ReactElement } from 'react';

type Props = {
  children: ReactElement<typeof TabPanel> | ReactElement<typeof TabPanel>[];
};

const Tabs = ({ children }: Props) => <div>{children}</div>;
```

This is powerful when building **composable UI libraries**.

---

## ‚úÖ 5. **Typing Render Props**

Instead of normal children, you may use a **function as a child**, known as the render prop pattern.

```ts
type Props = {
  children: (value: number) => React.ReactNode;
};

const Counter = ({ children }: Props) => {
  return <div>{children(42)}</div>;
};

// ‚úÖ Usage:
<Counter>
  {(val) => <span>{val}</span>}
</Counter>
```

You **must** type this manually. `React.FC` can't infer function-as-children correctly.

---

## ‚úÖ 6. **Combining Children with Generics**

```ts
type ListProps<T> = {
  items: T[];
  children: (item: T) => React.ReactNode;
};

function List<T>({ items, children }: ListProps<T>) {
  return <ul>{items.map(children)}</ul>;
}
```

Again, you **can‚Äôt do this cleanly** with `React.FC`.

---

## üß† Final Thought

Typing `children` manually is about more than just optionality. It gives you **full control** over:

| Use Case                                      | Supported by `children?: React.ReactNode` |
| --------------------------------------------- | ----------------------------------------- |
| Optional or required                          | ‚úÖ Yes                                     |
| Only specific child types (e.g., string, JSX) | ‚úÖ Yes                                     |
| Only one child                                | ‚úÖ Yes (use `ReactElement`)                |
| Specific component types                      | ‚úÖ Yes (`ReactElement<typeof Comp>`)       |
| Render props (function as children)           | ‚úÖ Yes                                     |
| Generic children (with `<T>`)                 | ‚úÖ Yes                                     |

> üí° If you're building reusable components or design systems, **manual typing of `children` is not just useful ‚Äî it‚Äôs essential.**

