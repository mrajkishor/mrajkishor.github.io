Here‚Äôs a **collection of common interview questions with clear answers** on **`equals()`, `hashCode()`, `toString()`, Comparable vs Comparator** ‚Äî frequently asked in **Java full-stack interviews** (Wipro, Infosys, TCS, Product Companies).

---

## **1. What is the contract between `equals()` and `hashCode()`?**

**Answer:**

* If two objects are **equal (`equals()` returns true)**, they **must have the same `hashCode()`**.
* If two objects have the **same `hashCode()`**, they **may or may not be equal** (collision possible).
* **Failing to override both** correctly can break the behavior of **HashMap, HashSet, HashTable**, etc.

**Example (Bad Case):**

```java
class Person {
    String name;
    // equals() overridden but not hashCode()
}
```

‚Üí Storing `Person` in a HashSet might create duplicates because the default `hashCode()` from `Object` is different.


## brief explantion:: 


let‚Äôs break this down clearly.

---

### ‚ùå **Bad Case: Overriding `equals()` but not `hashCode()`**

```java
class Person {
    String name;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person p = (Person) o;
        return name.equals(p.name);
    }

    // ‚ùå hashCode() NOT overridden
}
```

---

### ‚úÖ **What‚Äôs the issue?**

* You‚Äôve told Java how to check **equality** (`equals()`), but not how to **find the object in a hash-based collection** (`hashCode()`).
* `HashSet` and `HashMap` **first use `hashCode()`** to find a bucket before calling `equals()` to compare actual objects.

---

### ‚ö†Ô∏è **What goes wrong?**

Let‚Äôs say:

```java
Person p1 = new Person("Alice");
Person p2 = new Person("Alice");

System.out.println(p1.equals(p2));  // ‚úÖ true
```

But now:

```java
Set<Person> set = new HashSet<>();
set.add(p1);
set.add(p2);
```

You‚Äôd expect the set to contain only **one "Alice"**, right?
But it contains **two**. Why?

---

### üîç **Why two "equal" objects got added?**

Because:

* `p1.hashCode()` and `p2.hashCode()` are coming from `Object.hashCode()` (default) ‚Üí which is based on memory address ‚Üí different.
* So HashSet puts them in **different buckets** and never calls `equals()`.

Thus, **duplicate slips in**.

---

### ‚úÖ **How to fix it?**

Always override `hashCode()` if you override `equals()`:

```java
@Override
public int hashCode() {
    return name.hashCode();
}
```

Now both `p1` and `p2`:

* Have the **same hashCode**
* Are compared with `equals()`
  ‚Üí So **HashSet** will only store one instance.

---

### üß† Summary

| Case                         | Result                                               |
| ---------------------------- | ---------------------------------------------------- |
| Only `equals()` overridden   | ‚ùå HashSet/HashMap behaves incorrectly                |
| Only `hashCode()` overridden | ‚ùå Objects might be ‚Äúequal‚Äù by hash but not logically |
| Both overridden correctly    | ‚úÖ Consistent, no duplicates                          |



---

## **2. Why should you override both `equals()` and `hashCode()`?**

**Answer:**
Because Java **collections (like HashMap, HashSet)** rely on **hashCode for bucketing** and **equals() for comparison**:

* When you look up an object, the `hashCode()` is used to find the bucket.
* Then `equals()` determines if the object is in that bucket.

---

## **3. How do you properly override `equals()` and `hashCode()`?**

**Answer:**

* `equals()` should check:

  * Reference equality (`this == obj`)
  * Type check
  * Field equality
* `hashCode()` should combine fields used in `equals()`.

**Example:**

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Person)) return false;
    Person p = (Person) o;
    return Objects.equals(name, p.name);
}

@Override
public int hashCode() {
    return Objects.hash(name);
}
```

---

## **4. What is `toString()` method in Java?**

**Answer:**
`toString()` returns a **string representation** of an object.
By default, `Object.toString()` returns:
`ClassName@HexadecimalHashCode`.

**Example:**

```java
Person p = new Person("John");
System.out.println(p);
// Default: Person@6bc7c054
```

**Why override it?**

* To provide meaningful output for debugging/logging.

```java
@Override
public String toString() {
    return "Person{name='" + name + "'}";
}
```

‚Üí Output: `Person{name='John'}`

---

## **5. Difference between `Comparable` and `Comparator`?**

| Feature          | Comparable                 | Comparator                           |
| ---------------- | -------------------------- | ------------------------------------ |
| Package          | `java.lang.Comparable`     | `java.util.Comparator`               |
| Method           | `compareTo(T o)`           | `compare(T o1, T o2)`                |
| Sorting Logic    | Inside the object itself   | Outside the object (separate class)  |
| Number of Orders | Only **one natural order** | Multiple custom orders               |
| Usage            | `Collections.sort(list)`   | `Collections.sort(list, comparator)` |

---

## **6. Example of Comparable**

```java
class Employee implements Comparable<Employee> {
    int id;
    public int compareTo(Employee e) {
        return this.id - e.id; // Sort by ID
    }
}
```

Usage:

```java
Collections.sort(employeeList); // Uses natural ordering by id
```

---

## **7. Example of Comparator**

```java
class NameComparator implements Comparator<Employee> {
    public int compare(Employee e1, Employee e2) {
        return e1.name.compareTo(e2.name);
    }
}
```

Usage:

```java
Collections.sort(employeeList, new NameComparator());
```

---

## **8. When would you use Comparator over Comparable?**

* **Comparable**: When a class has **natural ordering** (e.g., `Integer`, `String`).
* **Comparator**: When you need **multiple sort orders** without modifying the original class.

---

## **9. What happens if `compareTo()` returns inconsistent results with `equals()`?**

**Answer:**

* Collections like **TreeSet** or **TreeMap** may **behave unpredictably** (e.g., treat different objects as duplicates).
* Always ensure `compareTo()` and `equals()` are **consistent**:

```java
x.compareTo(y) == 0  ‚áí  x.equals(y) == true
```

---

## **10. Can `hashCode()` return negative values?**

**Answer:**
Yes, `hashCode()` can return negative integers. Hash-based collections like `HashMap` internally **mask the sign bit** (via `hash & (n-1)`), so negative values are not a problem.

---

### **Would you like me to create 10 common **MCQs** on these topics (`equals`, `hashCode`, `toString`, Comparable vs Comparator\`) with answers for quick revision?**
