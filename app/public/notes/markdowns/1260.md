
# 🔷 Chapter 3.2: Input Buffering

### 1. Why Input Buffering is Needed

* The lexical analyzer reads the **source program character by character**.
* Many tokens require **lookahead** (checking more characters ahead) to decide:

  * Example:

    * `=` → assignment operator.
    * `==` → relational operator.
  * Lexer must peek beyond `=` to decide if it’s `=` or `==`.
* **Problem**:

  * Direct character-by-character reading is slow.
  * Compiler must process **millions of characters** in large programs.
* **Solution**: Use **buffering techniques** to reduce overhead.

---

### 2. Buffer Pair Scheme

* Uses **two equal-sized buffers**, each of size **N** (commonly 4096 bytes, i.e., a disk block).
* One buffer is **processed**, while the other is **filled from disk**.
* Maintains two **pointers**:

  * `lexemeBegin`: start of current lexeme.
  * `forward`: scans ahead to recognize tokens.
* When `forward` reaches the end of a buffer:

  * Automatically switch to the other buffer.
  * If end-of-file is reached, mark with special `eof` character.

👉 Benefit: Reduces number of I/O system calls (instead of 1 per character, we read 4096 at once).

---

### 3. Sentinel Scheme

* Further improves buffer pair efficiency.
* **Sentinel character** (special end-marker, e.g., `eof`) placed at end of buffer.
* Eliminates need for explicit checks like “Have we reached end of buffer?” in each step.
* When scanner reaches sentinel:

  * If it’s **real end of file** → stop scanning.
  * If not → reload buffer automatically and continue.

👉 This avoids **extra conditional checks** → speeds up scanning.

---

### 4. Example of Buffering in Action

Let’s take input:

```c
a = b + c;
```

* `lexemeBegin` → points to `a`.
* `forward` → moves character by character: `a`, whitespace, `=`, whitespace, `b`, …
* When `forward` hits end of buffer, sentinel ensures smooth switch without repeated `if` checks.

---

### 5. Efficiency Considerations

* **Without buffering**: each character read requires a **system call** → very slow.
* **With buffer pairs**: one system call fetches thousands of characters → efficient.
* **With sentinels**: even fewer conditional checks → closer to hardware speed.

---

### 6. Real-World Compilers

* Most production compilers (GCC, JavaC) use **sentinel buffering**.
* Some also use **memory-mapped files** for even faster input handling.

---

# ✅ GATE Pointers

* **Buffer pairs** and **sentinels** are standard exam questions.
* Likely 1-mark theory: *“Why buffering is needed?”*
* Practical MCQ: *“What’s the advantage of sentinels over buffer pairs?”*
* Understanding of **lexemeBegin** and **forward** pointers is often tested.
* Sometimes GATE mixes this with **lookahead** questions (e.g., distinguishing `=` vs `==`).


