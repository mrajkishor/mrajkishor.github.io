

# üî∑ Pagination, Sorting, and Custom Queries in Spring Data JPA

## 1. Concept

Real-world backend systems rarely fetch ‚Äúall rows‚Äù from a database. APIs need to handle **large datasets** efficiently while remaining performant and scalable. Spring Data JPA provides **first-class support** for:

* **Pagination**: Breaking down large result sets into pages.
* **Sorting**: Ordering results dynamically by one or more fields.
* **Custom Queries**: Handling complex or dynamic queries beyond standard repository methods.

These are critical in **high-scale systems (Enterprise-style)** where efficiency and user experience depend on data retrieval speed.

---

## 2. Pagination in Spring Data JPA

Spring provides the `Pageable` interface and `PageRequest` implementation to abstract pagination.

### Example

```java
Pageable pageable = PageRequest.of(0, 20); // page 0, size 20
Page<User> users = userRepository.findAll(pageable);
```

* `Page<T>` ‚Üí Full page metadata: total pages, elements, page number.
* `Slice<T>` ‚Üí Lighter version, only info about next/prev page (better for infinite scrolling).
* `List<T>` ‚Üí Raw data only, no metadata.

### Key Methods

* `Page.getContent()` ‚Üí returns list of entities.
* `Page.getTotalElements()` / `Page.getTotalPages()` ‚Üí total counts.
* `Page.hasNext()` / `Page.hasPrevious()` ‚Üí navigation checks.

---

## 3. Sorting in Spring Data JPA

Sorting can be applied:

* **Independently** using `Sort`:

```java
Sort sort = Sort.by(Sort.Direction.DESC, "createdAt");
List<User> users = userRepository.findAll(sort);
```

* **Combined with pagination**:

```java
Pageable pageable = PageRequest.of(0, 10, Sort.by("name").ascending());
Page<User> users = userRepository.findAll(pageable);
```

* **Multiple sort fields**:

```java
Sort sort = Sort.by("lastName").ascending().and(Sort.by("age").descending());
```

---

## 4. Custom Queries in Spring Data JPA

Custom queries allow developers to **go beyond derived methods**.

### a) Query Derivation from Method Names

Spring can generate queries by parsing method names:

```java
List<User> findByStatusAndAgeGreaterThan(String status, int age);
```

This generates:

```sql
SELECT * FROM users WHERE status = ? AND age > ?
```

---

### b) JPQL Queries

Using `@Query` with JPQL:

```java
@Query("SELECT u FROM User u WHERE u.email = :email")
Optional<User> findByEmail(@Param("email") String email);
```

---

### c) Native SQL Queries

For DB-specific optimizations:

```java
@Query(value = "SELECT * FROM users WHERE created_at > :date", nativeQuery = true)
List<User> findUsersCreatedAfter(@Param("date") LocalDate date);
```

---

### d) Named Queries

Defined at entity level:

```java
@Entity
@NamedQuery(
  name = "User.findByRole",
  query = "SELECT u FROM User u WHERE u.role = :role"
)
class User { ... }
```

Spring will automatically bind `userRepository.findByRole(...)`.

---

### e) Dynamic Queries with Specifications

For **complex filtering**:

```java
public class UserSpecs {
    public static Specification<User> hasStatus(String status) {
        return (root, query, cb) -> cb.equal(root.get("status"), status);
    }
}
List<User> result = userRepo.findAll(Specification.where(hasStatus("ACTIVE")));
```

---

### f) Projections with Custom Queries

Optimized fetching via DTOs:

```java
@Query("SELECT new com.example.dto.UserSummary(u.name, COUNT(o)) " +
       "FROM User u JOIN u.orders o GROUP BY u.name")
List<UserSummary> fetchUserOrderSummary();
```

---

## 5. Advanced Features (Enterprise-Level)

### üîπ Infinite Scrolling (Mobile-Friendly APIs)

* Use `Slice<T>` instead of `Page<T>` to avoid unnecessary `COUNT(*)` queries.

### üîπ Cursor-Based Pagination

* Enterprise APIs (Facebook/Instagram/Twitter) often use **cursors** instead of offset:

  * Faster for large datasets.
  * Implemented via `WHERE id > :lastSeenId LIMIT :pageSize`.

### üîπ Sorting on Nested Entities

* Spring allows sorting by nested fields:

```java
Page<User> result = repo.findAll(PageRequest.of(0, 20, Sort.by("address.city")));
```

### üîπ Query Hints & Performance

* Use `@QueryHints` to optimize custom queries (e.g., read-only).
* Combine with **indexes** at DB level for large-scale sorting.

---

## 6. Real-World Scenarios

* **E-Commerce**: Paginate product listings, sort by price/rating.
* **Social Media**: Infinite scrolling timelines (cursor-based pagination).
* **Analytics Dashboard**: Custom queries aggregating data with sorting by timestamp.
* **Banking**: Transaction history with pagination & sorting by date or amount.

---

## 7. Best Practices

1. **Default to Pageable + Sort in repository methods** for all list-returning queries.
2. **Use Slice<T> for infinite scrolling** to reduce DB load.
3. **Use projections (DTOs)** for read-heavy queries instead of loading entire entities.
4. **Avoid OFFSET pagination** for very large datasets ‚Üí prefer **cursor-based**.
5. **Index frequently used sort/filter columns** in the database.
6. **Use Specifications / Criteria API** for dynamic search filters in enterprise apps.

---

## 8. Common Enterprise-Level Interview Questions

1. How does Spring Data JPA implement pagination under the hood?
2. Difference between `Page`, `Slice`, and `List`. When would you use each?
3. What is cursor-based pagination? Why do large-scale systems prefer it over offset?
4. How do you implement dynamic search filters with Spring Data JPA?
5. Can you explain when to use `@Query` vs derived query vs specification?
6. What is the impact of sorting on large datasets? How do you optimize it?
7. How do projections improve query performance?
8. How would you paginate results across millions of rows efficiently?
9. How do you handle sorting on nested entity fields?
10. What‚Äôs the trade-off between JPQL queries and native SQL in Spring Data JPA?

---



# üõ† Code Example ‚Äî Pagination, Sorting, and Custom Queries

## 1. Entities

### `User`

```java
@Entity
@Table(name = "users")
public class User {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private List<Order> orders = new ArrayList<>();

    // getters and setters
}
```

### `Product`

```java
@Entity
@Table(name = "products")
public class Product {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private double price;
    private double rating;

    // getters and setters
}
```

### `Order`

```java
@Entity
@Table(name = "orders")
public class Order {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDateTime orderDate;
    private String status;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}
```

---

## 2. DTO Projections

### Product Summary (Projection for listing)

```java
public record ProductSummary(Long id, String name, double price) {}
```

### User Order Count (Projection for analytics)

```java
public record UserOrderCount(String userName, Long totalOrders) {}
```

---

## 3. Repositories

### `ProductRepository`

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {

    // Pagination + Sorting
    Page<Product> findByPriceBetween(double min, double max, Pageable pageable);

    // Projection with JPQL
    @Query("SELECT new com.example.dto.ProductSummary(p.id, p.name, p.price) " +
           "FROM Product p WHERE p.rating >= :minRating")
    Page<ProductSummary> findHighRatedProducts(@Param("minRating") double minRating, Pageable pageable);

    // Cursor-based pagination (native query)
    @Query(value = "SELECT * FROM products WHERE id > :lastId ORDER BY id ASC LIMIT :size", 
           nativeQuery = true)
    List<Product> findNextProducts(@Param("lastId") Long lastId, @Param("size") int size);
}
```

---

### `UserRepository`

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    // Derived query with pagination
    Page<User> findByNameContainingIgnoreCase(String keyword, Pageable pageable);

    // DTO Projection
    @Query("SELECT new com.example.dto.UserOrderCount(u.name, COUNT(o)) " +
           "FROM User u LEFT JOIN u.orders o GROUP BY u.name")
    List<UserOrderCount> fetchUserOrderCounts();
}
```

---

## 4. Service Layer

```java
@Service
@RequiredArgsConstructor
public class ProductService {

    private final ProductRepository productRepo;

    // Standard pagination & sorting
    public Page<Product> getProducts(double min, double max, int page, int size, String sortField, String sortDir) {
        Sort sort = sortDir.equalsIgnoreCase("asc") 
            ? Sort.by(sortField).ascending() 
            : Sort.by(sortField).descending();
        Pageable pageable = PageRequest.of(page, size, sort);
        return productRepo.findByPriceBetween(min, max, pageable);
    }

    // Slice-based infinite scrolling
    public Slice<ProductSummary> getInfiniteProducts(double minRating, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("id").ascending());
        return productRepo.findHighRatedProducts(minRating, pageable);
    }

    // Cursor-based pagination (scalable)
    public List<Product> getProductsByCursor(Long lastId, int size) {
        if (lastId == null) lastId = 0L; // start from beginning
        return productRepo.findNextProducts(lastId, size);
    }
}
```

---

## 5. Controller Layer

```java
@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductService productService;

    // Example: /api/products/paged?min=10&max=200&page=0&size=10&sortField=price&sortDir=asc
    @GetMapping("/paged")
    public ResponseEntity<Page<Product>> getPagedProducts(
            @RequestParam double min,
            @RequestParam double max,
            @RequestParam int page,
            @RequestParam int size,
            @RequestParam(defaultValue = "id") String sortField,
            @RequestParam(defaultValue = "asc") String sortDir) {
        return ResponseEntity.ok(productService.getProducts(min, max, page, size, sortField, sortDir));
    }

    // Example: /api/products/infinite?page=0&size=5&minRating=4
    @GetMapping("/infinite")
    public ResponseEntity<Slice<ProductSummary>> getInfiniteProducts(
            @RequestParam int page,
            @RequestParam int size,
            @RequestParam double minRating) {
        return ResponseEntity.ok(productService.getInfiniteProducts(minRating, page, size));
    }

    // Example: /api/products/cursor?lastId=50&size=10
    @GetMapping("/cursor")
    public ResponseEntity<List<Product>> getProductsByCursor(
            @RequestParam(required = false) Long lastId,
            @RequestParam int size) {
        return ResponseEntity.ok(productService.getProductsByCursor(lastId, size));
    }
}
```

---

# üîë Key Enterprise-Level Takeaways

1. **Pagination Types**

   * `Page<T>` ‚Üí Full metadata (good for admin dashboards).
   * `Slice<T>` ‚Üí Infinite scroll (lighter, avoids COUNT).
   * Cursor-based ‚Üí Enterprise-scale APIs (Twitter, Instagram).

2. **Sorting**

   * Dynamic multi-field sorting supported.
   * Always **index sorted columns** in DB to avoid performance hits.

3. **Custom Queries**

   * JPQL ‚Üí For entity-based queries.
   * Native SQL ‚Üí For DB-specific optimizations (cursor pagination).
   * DTO projections ‚Üí Prevent overfetching, improve API response times.

4. **Scalability**

   * For millions of rows ‚Üí **Avoid OFFSET** pagination (`LIMIT 100 OFFSET 1000000`) ‚Äî too slow.
   * Prefer **cursors (id > lastId)** for real-time systems.

---



# üî∑ Database-Level Optimizations for Pagination, Sorting, and Custom Queries

## 1. Indexing for Pagination & Sorting

Indexes speed up lookups and sorting operations.

### Example: Index on `price` and `rating`

```sql
-- Index for price range queries
CREATE INDEX idx_products_price ON products(price);

-- Index for rating filters
CREATE INDEX idx_products_rating ON products(rating);

-- Composite index for frequent sorting + filtering
CREATE INDEX idx_products_price_rating ON products(price, rating);
```

üí° **Enterprise Insight**:

* If queries always **filter by price AND sort by rating**, use a **composite index**.
* If queries filter on `price` but sort on `name`, **separate indexes** are better.

---

## 2. Optimizing OFFSET Pagination

Traditional pagination:

```sql
SELECT * FROM products ORDER BY id ASC LIMIT 10 OFFSET 100000;
```

‚ö†Ô∏è Problem ‚Üí Database scans **100k rows** before returning 10.

* For very large datasets, OFFSET becomes **O(N)** ‚Üí terrible for Enterprise-scale systems.

### Optimized (Keyset/Cursor Pagination)

```sql
SELECT * FROM products 
WHERE id > :lastSeenId 
ORDER BY id ASC LIMIT :size;
```

‚úÖ Performance ‚Üí Constant time (O(1)) per page.
‚úÖ Scales to billions of rows.

---

## 3. Covering Indexes for Projections

If only `id, name, price` are required (DTO projection):

```sql
SELECT id, name, price FROM products WHERE rating >= 4;
```

Create **covering index**:

```sql
CREATE INDEX idx_products_projection ON products(rating, id, name, price);
```

üí° The index itself satisfies the query ‚Üí avoids going back to table (faster).

---

## 4. Query Plans & EXPLAIN

Always check query execution plan:

```sql
EXPLAIN SELECT * FROM products WHERE price BETWEEN 50 AND 100 ORDER BY rating DESC LIMIT 20;
```

* Ensure `Using index` or `Index scan` is shown.
* Avoid `Full table scan` unless necessary.

---

## 5. Caching for Heavy Queries

### a) Second-Level Cache (Hibernate/Ehcache/Redis)

* Cache common queries like ‚Äútop products by rating‚Äù.
* Useful for read-heavy systems (e.g., e-commerce product catalog).

```yaml
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory
```

### b) Application-Level Caching

```java
@Cacheable("popularProducts")
public List<ProductSummary> getPopularProducts() {
    return productRepo.findHighRatedProducts(4.5, PageRequest.of(0, 20));
}
```

### c) Database Query Caching (Redis, Memcached)

* Cache expensive aggregates (e.g., top 10 users by order count).

---

## 6. Sharding & Partitioning (Enterprise-Scale)

* **Vertical partitioning**: Split large tables into multiple schemas.
* **Horizontal partitioning (sharding)**: Split `products` across multiple DB nodes by range or hash.

Example:

* `products_1` (id 1‚Äì1M)
* `products_2` (id 1M‚Äì2M)

üí° Cursor pagination works seamlessly with sharding since queries are id-based.

---

## 7. Practical Enterprise-Style Scenarios

### üîπ E-Commerce Product Listings

* Use cursor-based pagination (`id > lastId`).
* Index on `(category_id, price, rating)` for fast filters.
* Cache ‚ÄúTop N‚Äù queries for trending products.

### üîπ Social Media Timeline

* Cursor-based pagination on `(created_at, id)`.
* Index: `(user_id, created_at DESC)`.
* Partition posts by `user_id` for distributed storage.

### üîπ Banking Transactions

* Partition `transactions` by `account_id`.
* Use composite index `(account_id, created_at)` for fast retrieval.
* Cursors ensure chronological scrolling with strong consistency.

---

## 8. Interview-Style Tradeoffs

1. **OFFSET vs Cursor Pagination**

   * OFFSET ‚Üí simpler but slow on huge datasets.
   * Cursor ‚Üí complex but scales linearly, preferred in Enterprise.

2. **Indexing Tradeoffs**

   * Too many indexes ‚Üí slower writes.
   * Choose **query-driven indexing** based on profiling.

3. **Caching**

   * Application-level (Spring Cache, Redis) for repeated queries.
   * DB query cache often not reliable at Enterprise scale (too volatile).

4. **Sharding**

   * Needed when even indexed queries don‚Äôt scale.
   * Impacts JOINs (must denormalize or aggregate asynchronously).

---

## 9. Common Interview Questions

1. Why is OFFSET pagination slow at scale? How would you fix it?
2. What indexes would you create for queries like:

   * `WHERE price BETWEEN ? AND ? ORDER BY rating DESC`
3. How do covering indexes improve projection queries?
4. What‚Äôs the trade-off between caching at DB vs app layer?
5. How would you design pagination for billions of rows in a social media feed?
6. How do you handle sorting and pagination in a **sharded database**?
7. When would you use `Page<T>` vs `Slice<T>` vs cursor-based pagination?

---

‚úÖ With this, you now have:

* **Spring JPA code** (pagination, sorting, custom queries).
* **Database optimizations** (indexes, cursor pagination, projections).
* **Enterprise-scale extensions** (caching, sharding, partitioning).
* **Interview-ready trade-offs & questions**.


