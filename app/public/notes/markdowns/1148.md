

# Axios, Fetch, Caching, Retry, SWR

---

## ✅ Overview

Modern frontend applications rely heavily on HTTP-based data fetching. The effectiveness of this layer depends not just on calling an endpoint, but on how well you handle **caching**, **retry strategies**, **error handling**, and **developer experience**. The most used tools in the React ecosystem include **Axios**, **Fetch API**, and high-level abstraction libraries like **SWR** and **React Query**.

---

## 🔷 1. **Axios vs Fetch API**

### ✅ Axios

* A popular, promise-based HTTP client.
* Comes with built-in request/response interceptors.
* Automatically transforms JSON responses.
* Has better error handling compared to Fetch (throws on non-2xx).

```ts
import axios from 'axios';

const api = axios.create({
  baseURL: '/api',
  timeout: 5000,
});

api.get('/users').then((res) => console.log(res.data));
```

#### 🔹 Axios Pros

* Interceptors (ideal for token injection or global error handling)
* Supports request cancellation
* Transform request/response payloads
* Default `Content-Type` for JSON

#### 🔹 Axios Cons

* Slightly larger bundle size
* Not built-in; needs installation

---

### ✅ Fetch API

* Native browser API, available globally.
* Low-level, more verbose.
* Requires manual `res.ok` check and `res.json()` parsing.

```ts
fetch('/api/users')
  .then((res) => {
    if (!res.ok) throw new Error("Request failed");
    return res.json();
  })
  .then((data) => console.log(data));
```

#### 🔹 Fetch Pros

* Zero dependencies
* Streams support
* Fully standards-based

#### 🔹 Fetch Cons

* Doesn’t throw on HTTP error (manual handling needed)
* Lacks built-in timeout, interceptors, or request cancel tokens

---

## 🔷 2. **Caching Strategies**

### ✅ Why Cache?

* Reduce network calls
* Improve perceived performance
* Enable offline support
* Control staleness vs freshness

---

### ✅ Common Caching Layers

| Layer                | Tool/Example                  |
| -------------------- | ----------------------------- |
| In-memory            | SWR, React Query, Apollo      |
| Persistent (Storage) | IndexedDB, localStorage       |
| Network-level        | `Cache-Control`, HTTP caching |
| CDN Edge             | Cloudflare, Akamai            |

---

### ✅ Caching Techniques

| Strategy                   | Description                                                                             |
| -------------------------- | --------------------------------------------------------------------------------------- |
| **Stale-While-Revalidate** | Return stale data immediately, then fetch fresh data in the background. Default in SWR. |
| **Cache-first**            | Use cached value if available; avoid fetch unless explicitly invalidated.               |
| **Network-first**          | Try network first; fallback to cache if offline.                                        |
| **Time-based Expiry**      | Cache expires after TTL (e.g., 5 minutes).                                              |
| **Key-based Invalidation** | Use cache keys and versioning to re-fetch only affected data.                           |

---

## 🔷 3. **Retry Strategies**

### ✅ When to Retry

* Transient network errors (e.g., `ECONNRESET`, `503`)
* Timeout errors
* Backend rate limit (429) with `Retry-After` header

---

### ✅ Retry Patterns

| Strategy                | Description                                                      |
| ----------------------- | ---------------------------------------------------------------- |
| **Fixed Delay**         | Retry after a constant interval (e.g., 3 attempts with 1s delay) |
| **Exponential Backoff** | Retry delays increase exponentially (1s, 2s, 4s…)                |
| **Jitter**              | Add randomness to backoff delays to prevent thundering herd      |
| **Conditional Retry**   | Retry only for certain status codes or error types               |

```ts
import axiosRetry from 'axios-retry';

axiosRetry(api, {
  retries: 3,
  retryDelay: axiosRetry.exponentialDelay,
  retryCondition: (err) => axiosRetry.isNetworkOrIdempotentRequestError(err),
});
```

---

## 🔷 4. **SWR (Stale-While-Revalidate)**

> Developed by Vercel, **SWR** is a React hook-based data fetching library that applies caching, revalidation, focus tracking, and retry logic with minimal code.

### ✅ Core Usage

```tsx
import useSWR from 'swr';
import axios from 'axios';

const fetcher = (url) => axios.get(url).then(res => res.data);

export default function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher);

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Failed to load</p>;

  return <h1>Welcome {data.name}</h1>;
}
```

---

### ✅ Key Features of SWR

| Feature                        | Description                                                    |
| ------------------------------ | -------------------------------------------------------------- |
| ✅ Auto Revalidation            | On focus, reconnect, window refocus                            |
| ✅ Deduplication                | Same query won’t trigger multiple requests                     |
| ✅ Error Retry                  | With backoff and max attempts                                  |
| ✅ Pagination & Infinite Scroll | Supported via `useSWRInfinite`                                 |
| ✅ Middleware                   | Extend logic using SWR middleware (e.g., auth token injection) |

---

### ✅ SWR vs React Query

| Feature        | SWR                      | React Query                 |
| -------------- | ------------------------ | --------------------------- |
| API Simplicity | Minimal, fewer options   | Rich, granular control      |
| Mutations      | Manual or `mutate()`     | `useMutation` hook          |
| Devtools       | No built-in devtools     | Excellent built-in devtools |
| Cache Sharing  | Global, shallow equality | Structured, key-based cache |
| Learning Curve | Low                      | Moderate to high            |

---

## 🔷 5. **Error Handling Patterns**

### ✅ Global Axios Interceptors

```ts
api.interceptors.response.use(
  (res) => res,
  (err) => {
    if (err.response.status === 401) {
      redirectToLogin();
    }
    return Promise.reject(err);
  }
);
```

---

### ✅ Centralized Error UI in SWR

```tsx
const { error } = useSWR('/api/data');

if (error?.response?.status === 404) {
  return <NotFound />;
}
```

---

## 🔷 6. **Best Practices Summary**

| Practice                                      | Recommendation                               |
| --------------------------------------------- | -------------------------------------------- |
| ✅ **Use `fetch`** for small or minimal setups | Zero dependencies, small apps                |
| ✅ **Use `axios`** for large-scale apps        | Interceptors, retries, cancel tokens         |
| ✅ **Use `SWR` or `React Query`**              | When you want full data lifecycle control    |
| ✅ **Retry failed GETs with backoff**          | But avoid retrying mutations blindly         |
| ✅ **Add loading, error, and empty states**    | Always consider UX feedback loops            |
| ✅ **Use caching and memoization**             | Reduces unnecessary requests and improves UX |
| ✅ **Debounce search inputs before fetching**  | Prevent request flood                        |

---

## ✅ Interview Questions

1. Compare Axios and Fetch — when would you choose one over the other?
2. How does SWR handle revalidation on tab focus?
3. How would you cache a user profile API result and invalidate it after logout?
4. What's the difference between retry and revalidation in data fetching?
5. Implement exponential backoff with jitter in Axios.

---

## <ins> Use cases & Case studies:

Here are well-structured **Enterprise-level Use Cases and Case Studies** for:


---

## ✅ USE CASES

### 🔹 **Axios**

| Use Case                     | Description                                                                      |
| ---------------------------- | -------------------------------------------------------------------------------- |
| **Authenticated dashboards** | Interceptors make it easy to attach bearer tokens or refresh them automatically. |
| **Global error handling**    | Setup retry, logging (e.g., Sentry), or redirects for 401 responses.             |
| **Upload with progress**     | `onUploadProgress` simplifies tracking large file uploads.                       |
| **Service abstraction**      | Centralized API layers can be easily created using Axios instances.              |

---

### 🔹 **Fetch API**

| Use Case                             | Description                                                       |
| ------------------------------------ | ----------------------------------------------------------------- |
| **Simple apps with no dependencies** | Zero-config usage in micro-frontends or public-facing sites.      |
| **Browser extensions or scripts**    | Works natively inside browser APIs and environments like Workers. |
| **Progressive Web Apps (PWAs)**      | Plays well with Service Workers and stream APIs.                  |

---

### 🔹 **SWR (Stale-While-Revalidate)**

| Use Case                                   | Description                                                    |
| ------------------------------------------ | -------------------------------------------------------------- |
| **User profile, settings, dashboard**      | Fetch once, return cached instantly, revalidate in background. |
| **Mobile apps with intermittent internet** | Works well with stale data and background revalidation.        |
| **Multi-tab session consistency**          | Auto-refetches on tab focus to ensure current data.            |
| **Search results and filters**             | SWR deduplication avoids repeated calls on filter change.      |

---

### 🔹 **Caching**

| Use Case                     | Description                                              |
| ---------------------------- | -------------------------------------------------------- |
| **E-commerce product pages** | Avoid hitting APIs for same product view multiple times. |
| **SaaS tenant data**         | Cache tenant-specific constants, roles, preferences.     |
| **Static app configuration** | Cache CDN-fetched JSON for feature flags, branding.      |

---

### 🔹 **Retry Strategies**

| Use Case                      | Description                                            |
| ----------------------------- | ------------------------------------------------------ |
| **Flaky mobile networks**     | Use exponential backoff for stability.                 |
| **GraphQL polling endpoints** | Retry on timeout with jitter to avoid thundering herd. |
| **CI/CD dashboards**          | Retry 502s or 429s when backend APIs rate-limit.       |

---

## ✅ CASE STUDIES

## Case Study: Axios – Global Error Interception in a B2B Dashboard

**Background**
The company maintained a large-scale React-based B2B dashboard used by internal teams (sales, support, marketing). Users accessed multiple protected views backed by APIs that required JWT-based authentication with expiry policies in place.

**Problem**
When tokens expired, users were being silently logged out. API responses returned `401` or `419`, but the frontend did not react, leading to confusing UX where users remained on the same page but actions failed with no guidance or redirect.

**Multiple Team Efforts**
The frontend team collaborated with backend engineers to standardize error codes for expired or invalid tokens. Design contributed a consistent re-login flow. DevOps helped with setting up logging for expired session events. QA tested across role-based flows and multiple browsers.

**Code or Architectural Decisions**

* A shared `axiosInstance` was created.
* Response interceptors were used to catch `401`/`419` errors.
* Token refresh logic with queuing was added to avoid race conditions.
* On failure, users were redirected to `/login` with a toast notification.
* All micro frontends were updated to use the new API wrapper.

**Broader Business Impact**

* Silent logout issues were fully resolved.
* Support tickets dropped by 65%.
* Developer onboarding improved since no team needed to write repetitive error handling code.
* The shared error handler became part of the company’s frontend core library used across products.

**Lessons Learned / Future Steps**

* Proactive feedback (toast + redirect) is better than generic error modals.
* Plan to introduce session expiration warnings (e.g., countdown toast) to improve UX before logout.

---

## Case Study: SWR – Offline-First LMS for Rural Education

**Background**
A React-based LMS platform served students across both urban and rural areas. Rural users often accessed the platform with unreliable or no internet during class hours or at home.

**Problem**
Students were unable to view lessons if they weren’t connected to the internet, even if the lesson had been previously viewed. This led to dropped sessions and decreased course completion rates.

**Multiple Team Efforts**
Product managers pushed for offline-first support as a priority. The backend team agreed to defer progress sync and allow temporary client-side storage. The QA team tested edge cases like partial syncs and expired cache. Design provided a clear offline-mode indication in the UI.

**Code or Architectural Decisions**

* Integrated SWR with `localForage` (IndexedDB) for persistent storage.
* Used `fallbackData` to show cached content during offline sessions.
* `revalidateOnReconnect` and `mutate()` were used for syncing progress.
* Pending mutations were queued and flushed on reconnect.
* Cache TTL was fine-tuned for accuracy without affecting perceived performance.

**Broader Business Impact**

* Over 45% of lesson views in rural regions were served from cache.
* Course completion rates improved 2.5x in target regions.
* Teacher complaints about session drops nearly vanished.
* The app was endorsed by local educational NGOs and attracted more institutional users.

**Lessons Learned / Future Steps**

* Introduce full lesson downloads (with media) as a premium feature.
* Add sync conflict resolution in future iterations to ensure accuracy.

---

## Case Study: Retry Strategy – Exponential Backoff for Search in Flight Booking App

**Background**
A React-based flight search app served high volumes of users during travel seasons. The frontend queried multiple backend services in parallel to display real-time flight availability and prices.

**Problem**
During peak hours, backend services returned frequent `503 Service Unavailable` errors. Users saw broken pages with no retry logic, leading to a spike in drop-offs at the search stage.

**Multiple Team Efforts**
Frontend and backend teams worked together to analyze failure patterns. SREs defined retry-safe status codes. Product/UX teams introduced graceful fallback UI states for retry attempts and failures.

**Code or Architectural Decisions**

* Integrated `axios-retry` to enable automatic retry on `503`, `504`, and `429`.
* Configured exponential backoff: 1s → 2s → 4s with jitter (±300ms).
* Added a loading spinner and fallback message with a retry button.
* Logged retry attempts and failures for monitoring via Sentry.

**Broader Business Impact**

* 90% of transient errors were resolved via auto-retries.
* Conversion rate on flight search → booking improved by 2.5x.
* Error alert volume to backend teams reduced by 35%.
* Improved perception of app stability, especially during peak traffic.

**Lessons Learned / Future Steps**

* Introduce circuit breaker for repeated backend failures.
* Use user behavior (e.g., retry clicks) as signal to prioritize backend stability investments.

---

## Case Study: Caching – Product Price Lookup in React E-commerce Site

**Background**
An online storefront displayed product cards with real-time price and stock. These were fetched from pricing APIs upon rendering the product grid on category or search pages.

**Problem**
Even when viewing the same product repeatedly, the app re-fetched data every time. This caused redundant API calls, degraded performance, and led to flickers due to loading states on every revisit.

**Multiple Team Efforts**
Frontend engineers worked with backend to validate price TTL expectations. Performance engineers profiled network and re-render behavior. QA ensured cache invalidation did not cause stale prices in checkout flow.

**Code or Architectural Decisions**

* Used SWR with cache key pattern: `product:{id}:price`.
* Configured `dedupingInterval: 3 minutes` and background `revalidateOnFocus`.
* Integrated `mutate()` on cart update to force sync.
* Added fallback UI in case of offline state using last-known cache.

**Broader Business Impact**

* API request volume dropped by 60% on product view pages.
* Average product grid load time improved by 1.3 seconds.
* Checkout accuracy remained intact due to final-stage revalidation.
* Increased user retention and repeat visits based on A/B test data.

**Lessons Learned / Future Steps**

* Plan to prefetch product details for most-viewed SKUs.
* Add versioned cache invalidation on product updates.

---

## Case Study: Fetch – Lightweight News App for Low-End Phones

**Background**
A news aggregator app was targeting users on low-end Android phones in tier-3 Indian cities. These users had very limited RAM and slow 2G/3G networks.

**Problem**
Library-heavy apps using Axios or SWR were crashing or freezing on these devices. Payload sizes and JavaScript bundle size became major performance blockers.

**Multiple Team Efforts**
Frontend team stripped third-party dependencies. UX redesigned layout for faster time-to-interactive. QA tested on actual low-memory devices and unstable networks.

**Code or Architectural Decisions**

* Used native `fetch()` for all network calls.
* Implemented a lightweight `Map`-based in-memory cache with TTL (2 mins).
* Added custom retry logic with exponential backoff and jitter.
* Leveraged `AbortController` for timeout-based request cancellation.
* Used `navigator.onLine` to skip fetch and show cached fallback when offline.

**Broader Business Impact**

* Bundle size reduced by \~33 KB.
* App load time improved by 20% on 3G connections.
* Crashes on low-end devices dropped significantly.
* Tier-3 region users increased by 40% over two months.

**Lessons Learned / Future Steps**

* Explore background sync via Service Workers.
* Replace ad-based monetization with offline push notification-based re-engagement.

---

## <ins> STAR

Here are the **STAR-format case studies** for interview preparation, based on the Axios, SWR, Retry, Caching, and Fetch scenarios:

---

## ⭐ 1. **Global Error Handling using Axios Interceptors**

**SITUATION**
In our B2B React dashboard, users were experiencing silent session expirations. Their API calls would fail with `401` errors, but the app didn’t guide them to log in again.

**TASK**
I needed to implement a centralized solution that would detect token expiration and handle re-authentication automatically, without requiring each team to duplicate error handling logic.

**ACTION**
I created a shared `axiosInstance` with a response interceptor to catch `401` and `419` responses. It triggered a token refresh sequence or redirected to `/login` with a toast message. To avoid duplicate requests during refresh, I introduced a retry queue.

**RESULT**
This completely eliminated “silent logout” issues. User complaints dropped by 65%, and the shared wrapper became a standard across all micro frontends, accelerating onboarding and improving consistency.

---

## ⭐ 2. **Offline Support in LMS using SWR**

**SITUATION**
Our learning platform was struggling to serve students in rural areas who had intermittent internet access. Users couldn’t access lessons unless fully online.

**TASK**
I was responsible for enabling offline-first access to previously viewed content and syncing progress once users came back online.

**ACTION**
Using SWR, I configured `localForage` for persistent cache storage. I implemented `fallbackData` to show cached lessons offline, and used `mutate()` to queue unsynced progress. SWR’s `revalidateOnReconnect` handled background syncing automatically.

**RESULT**
Offline lesson access improved engagement by 2.5x in rural regions. Over 45% of lesson views were served from cache, and user complaints about access failure dropped dramatically.

---

## ⭐ 3. **Retry Logic with Exponential Backoff in Flight Booking**

**SITUATION**
During high-traffic events, our flight search page frequently encountered `503` errors from backend services, causing user drop-offs.

**TASK**
I had to implement a retry strategy that would handle transient failures gracefully without overwhelming backend servers.

**ACTION**
I integrated `axios-retry` with exponential backoff (1s → 2s → 4s) and added jitter to spread retries. I configured retries for `503`, `504`, and `429`, and added a fallback UI with spinner and manual retry option.

**RESULT**
90% of transient API errors were recovered automatically. This improved the conversion rate on flight search by 2.5x and reduced backend alert noise by over 35%.

---

## ⭐ 4. **SWR-Based Caching in E-commerce Product Pages**

**SITUATION**
In our e-commerce frontend, repeated product card renders were hitting the pricing API multiple times, even for the same products.

**TASK**
My goal was to reduce redundant API calls and improve render performance without showing stale prices at checkout.

**ACTION**
I integrated SWR with key-based caching and set a `dedupingInterval` of 3 minutes. I used `revalidateOnFocus` and triggered `mutate()` on cart actions to sync prices when needed. I also added a fallback UI for offline scenarios.

**RESULT**
API calls were reduced by 60%, product grid load time improved by 1.3 seconds, and conversion rates increased without compromising accuracy.

---

## ⭐ 5. **Optimizing Fetch-Based App for Low-End Phones**

**SITUATION**
Our lightweight news app had performance issues on low-end Android phones. Axios and SWR bloated the JS bundle and caused crashes on 2G networks.

**TASK**
I was tasked with replacing heavy dependencies and improving performance for tier-3 device users without sacrificing core functionality.

**ACTION**
I rewrote the entire data fetching layer using native `fetch()` and `AbortController` for timeout. I added a custom in-memory cache using `Map` with TTL, implemented retry with backoff + jitter, and showed cached content offline when available.

**RESULT**
Bundle size dropped by 33 KB, page load improved by 20% on 3G, and usage from low-end devices increased by 40% within two months.

---

## <ins> Code Samples: 

Here are **code samples** for the STAR case studies you requested, covering: **Axios error handling**, **SWR offline support**, **Axios retry with exponential backoff**, **SWR caching**, and **native Fetch with retry/backoff**.

---

## ✅ 1. Global Error Handling with Axios

```ts
// axiosInstance.ts
import axios from 'axios';

const axiosInstance = axios.create({ baseURL: '/api' });

// Token refresh queue
let isRefreshing = false;
let failedQueue: any[] = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (token) {
      prom.resolve(token);
    } else {
      prom.reject(error);
    }
  });
  failedQueue = [];
};

axiosInstance.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        }).then(token => {
          originalRequest.headers['Authorization'] = `Bearer ${token}`;
          return axiosInstance(originalRequest);
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        const { data } = await axios.post('/auth/refresh');
        axiosInstance.defaults.headers.common['Authorization'] = `Bearer ${data.token}`;
        processQueue(null, data.token);
        return axiosInstance(originalRequest);
      } catch (err) {
        processQueue(err, null);
        window.location.href = '/login';
        return Promise.reject(err);
      } finally {
        isRefreshing = false;
      }
    }

    return Promise.reject(error);
  }
);

export default axiosInstance;
```

---

## ✅ 2. SWR with Offline Cache using IndexedDB

```ts
// swrClient.ts
import useSWR from 'swr';
import axios from 'axios';
import localForage from 'localforage';
import { persist } from 'swr-persist';

const fetcher = (url: string) => axios.get(url).then(res => res.data);

export function useOfflineSWR<T = any>(key: string) {
  return useSWR<T>(key, fetcher, {
    use: [
      persist({
        provider: () => localForage,
        key,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
      }),
    ],
    revalidateOnReconnect: true,
    fallbackData: undefined, // can set cached data here
  });
}
```

Usage:

```tsx
const { data, mutate } = useOfflineSWR('/api/lessons/123');
```

---

## ✅ 3. Retry Strategy with Exponential Backoff (Axios)

```ts
// retryAxios.ts
import axios from 'axios';
import axiosRetry from 'axios-retry';

const api = axios.create({ baseURL: '/api' });

axiosRetry(api, {
  retries: 3,
  retryDelay: (retryCount: number) => {
    const base = Math.pow(2, retryCount) * 1000; // exponential backoff
    const jitter = Math.random() * 500; // jitter
    return base + jitter;
  },
  retryCondition: (error) =>
    axiosRetry.isNetworkOrIdempotentRequestError(error) ||
    error.response?.status === 503,
});

export default api;
```

Usage:

```ts
api.get('/search/flights?from=DEL&to=BOM').then(res => {
  console.log(res.data);
});
```

---

## ✅ 4. SWR for Product Caching with TTL + Manual Revalidation

```ts
// useProduct.ts
import useSWR from 'swr';
import axios from 'axios';

const fetcher = (url: string) => axios.get(url).then(res => res.data);

export function useProduct(productId: string) {
  const { data, mutate } = useSWR(`/api/product/${productId}/price`, fetcher, {
    dedupingInterval: 180_000, // 3 mins
    revalidateOnFocus: true,
  });

  return { product: data, refresh: mutate };
}
```

Usage:

```tsx
const { product, refresh } = useProduct('12345');

<button onClick={() => refresh()}>Refresh Price</button>
```

---

## ✅ 5. Native Fetch with Retry and Offline Fallback

```ts
// fetchWithRetry.ts
export async function fetchWithRetry(url: string, options: RequestInit = {}, retries = 3, delay = 1000): Promise<any> {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);

    const res = await fetch(url, { ...options, signal: controller.signal });
    clearTimeout(timeoutId);

    if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
    return await res.json();
  } catch (err) {
    if (retries > 0) {
      await new Promise((res) => setTimeout(res, delay + Math.random() * 300));
      return fetchWithRetry(url, options, retries - 1, delay * 2);
    }
    throw err;
  }
}
```

Usage:

```ts
fetchWithRetry('/api/news/latest')
  .then(data => console.log(data))
  .catch(() => showCachedFallback());
```

---

## <ins>CIQnA

Here are **Enterprise-level Common Interview Questions and Answers** focused on:

---

# 🔷 Frontend Engineering / Data Fetching & API Integration

**Topics Covered**: Axios, Fetch, Caching, Retry Logic, and SWR

---

## ✅ Axios & Fetch

---

### 🔹 Q1: What’s the difference between Axios and Fetch?

**Answer**:

* **Axios** is a third-party library with features like automatic JSON parsing, request/response interceptors, and built-in timeout support.
* **Fetch** is a native browser API — it requires manual parsing of JSON (`res.json()`), doesn't throw for HTTP errors, and lacks features like interceptors.

**Key difference**: Axios throws on non-2xx responses by default; Fetch does not.

---

### 🔹 Q2: When would you prefer using Fetch over Axios?

**Answer**:
Use **Fetch** when:

* You want zero dependencies (e.g., PWA, browser extensions).
* You need fine-grained control with streaming APIs or service workers.
* You’re optimizing bundle size or working in constrained environments (e.g., low-end mobile).

---

### 🔹 Q3: How do you handle timeouts in Axios and Fetch?

**Answer**:

* **Axios**: Use the `timeout` config.

```ts
axios.get('/api', { timeout: 3000 });
```

* **Fetch**: Use `AbortController`.

```ts
const controller = new AbortController();
setTimeout(() => controller.abort(), 3000);
fetch('/api', { signal: controller.signal });
```

---

## ✅ Caching

---

### 🔹 Q4: What is stale-while-revalidate, and how does SWR implement it?

**Answer**:
**Stale-While-Revalidate** is a caching strategy where:

* The cached (stale) data is shown immediately.
* A background request fetches fresh data.
* Once received, the fresh data replaces the stale one in the UI.

SWR applies this automatically unless configured otherwise:

```tsx
useSWR('/api/user', fetcher); // shows cache, then updates in background
```

---

### 🔹 Q5: What are different types of caching layers in frontend apps?

**Answer**:

* **Memory cache**: SWR, React Query (ephemeral, in-RAM)
* **Persistent cache**: IndexedDB, localStorage (`swr-persist`, `react-query-persist`)
* **HTTP-level cache**: via `Cache-Control`, `ETag`, `max-age`
* **CDN caching**: Cloudflare, Akamai, Vercel Edge

Each has trade-offs in consistency, freshness, and control.

---

### 🔹 Q6: How would you cache user settings across sessions?

**Answer**:

* Use SWR or React Query for in-session memory caching.
* Use `localForage` + `swr-persist` to store in IndexedDB across sessions.
* Invalidate on logout or user switch using cache key scoping.

---

## ✅ Retry Logic

---

### 🔹 Q7: How do you implement retry logic in Axios?

**Answer**:
Use the `axios-retry` library:

```ts
import axiosRetry from 'axios-retry';

axiosRetry(api, {
  retries: 3,
  retryDelay: axiosRetry.exponentialDelay,
  retryCondition: (err) => err.response?.status >= 500
});
```

Supports exponential backoff and custom conditions (e.g., `429`, `503`, network failures).

---

### 🔹 Q8: When should you **not** retry an API call?

**Answer**:

* On client-side validation failures (e.g., 400 Bad Request).
* On unauthorized (401) or forbidden (403) errors.
* On non-idempotent mutations (e.g., POST to create a payment).

Retrying these can cause **side effects or duplicate operations**.

---

### 🔹 Q9: What is exponential backoff with jitter?

**Answer**:
Exponential backoff increases retry delay exponentially:

```
1s → 2s → 4s → 8s ...
```

**Jitter** adds randomness to prevent thundering herd problems (e.g., multiple clients retrying at the same time):

```
delay = baseDelay + random jitter
```

---

## ✅ SWR & Real-World Scenarios

---

### 🔹 Q10: What are the core features of SWR?

**Answer**:

* **Stale-while-revalidate** caching
* Automatic revalidation on:

  * Reconnect
  * Focus
  * Window refocus
* Deduplication of concurrent requests
* `mutate()` for optimistic UI or manual cache invalidation
* Extensible with middleware (e.g., auth, logging)

---

### 🔹 Q11: How would you implement offline-first data access?

**Answer**:

* Use SWR with `localForage` to persist cached data in IndexedDB.
* Show `fallbackData` while offline.
* Use `navigator.onLine` or SWR’s `revalidateOnReconnect` to refresh on reconnection.
* Sync unsent mutations with background queue and flush on reconnect.

---

### 🔹 Q12: How do you cancel an in-flight Fetch request?

**Answer**:

```ts
const controller = new AbortController();
fetch('/api', { signal: controller.signal });
controller.abort(); // cancels the fetch
```

This avoids memory leaks or state updates on unmounted components.

---

## ✅ Bonus

---

### 🔹 Q13: How do you share cached data between tabs?

**Answer**:

* Use **BroadcastChannel API** or storage events (`localStorage.setItem`)
* For SWR: Use SWR’s middleware or custom cache provider with cross-tab sync
* For React Query: Use `react-query-persist-client` with IndexedDB and cross-tab sync plugins

---

### 🔹 Q14: How do you implement request deduplication?

**Answer**:

* SWR does it by default: same key → same request (until `dedupingInterval` expires)
* In Axios: build a wrapper using a `Map` of in-flight request promises
* GraphQL clients like Apollo or Relay handle it via normalized caching




