# Scope Chain & Variable Environment

This is the part of JS that decides **which value a name refers to** at runtime. If you can walk an engine’s mental model of *execution contexts*, *lexical environments*, and the *scope chain*, you’ll avoid 90% of “why is this `undefined`?” bugs—and ace interview edge cases.

---

## 1) The high-level picture

* **Lexical (static) scoping**: what a name can see is determined by **where** it’s written in the source, not how the function is called.
* **Scope chain**: a **linked list** of environments the engine searches when resolving an identifier (a variable name).
* **Execution context**: each time code runs (global, module, function, eval), the engine creates an object describing *where we are*: environment links, `this`, `new.target`, etc.
* **Variable Environment vs Lexical Environment**: for historical reasons, `var` and function declarations are stored in the **Variable Environment** (function/global scoped), while `let`/`const`/`class`/`catch`/block bindings live in the **Lexical Environment** (block scoped). In modern explanations, you can think of them as two stacks for the same context.

---

## 2) Two-phase execution (why “hoisting” exists)

When a scope is entered the engine does:

1. **Creation / instantiation**

   * Builds **environment records** (think: frames) for the scope.
   * Registers **bindings** (names → slots).
   * Initializes:

     * `var` → **`undefined`**
     * function declarations → **function objects**
     * `let`/`const`/`class` → **uninitialized** (**TDZ**)

2. **Execution**

   * Runs statements.
   * Assigns to those previously created bindings.

This is why reading a `let` before its line throws (**Temporal Dead Zone**) while reading a `var` gives `undefined`.

---

## 3) The data structures (spec names, practical meaning)

* **Environment Record** = a mapping from identifiers to values with flags (mutable, configurable, etc.). There are flavors:

  * **Declarative Environment Record**: created by blocks/functions/modules for `let`/`const`/`class`/params.
  * **Object Environment Record**: wraps an object’s properties as bindings (e.g., **global object** in scripts, `with`).
  * **Function Environment Record**: like declarative, plus `this`, `super`, `new.target`, `arguments`.
  * **Module Environment Record**: live, immutable bindings for `import`/`export`.

* **Lexical Environment**: `{ envRecord, outer }` — the `outer` pointer builds the **scope chain**.

* **Variable Environment**: same shape, dedicated to `var`/function decls at function/global level.

> Resolution algorithm (informal): to read `x`, start at the **current** env record; if not found, follow `outer` to parent, repeat until found or `null` → ReferenceError.

---

## 4) Kinds of scope (what creates a new environment)

* **Global Script scope** (non-module): one per script; `var` becomes a property of the **global object** (`window` in browsers).
* **Module scope**: one per ES module; top-level bindings **do not** attach to the global object.
* **Function scope**: parameters + `var` live here; also holds `this`, `arguments` (non-arrow).
* **Block scope**: `{}`, `if`, `for`, `switch` blocks create a new lexical environment for `let`/`const`/`class`.
* **Catch scope**: the `catch (e)` parameter creates a *new* binding that shadows outer `e`.
* **With scope** (discouraged): adds an **object environment** link in the chain.
* **Eval scope** (discouraged): can inject bindings dynamically.

---

## 5) Variable Environment vs Lexical Environment (why you care)

Inside a function:

* The **Variable Environment** holds **`var`** and **function declarations** (function-scoped).
* The **Lexical Environment** holds **`let`**, **`const`**, **`class`**, and **block-level function declarations** (block-scoped).

```js
function demo() {               // New execution context
  // Variable Environment (VE): var a; function f(){...} -> initialized
  // Lexical Environment (LE):  let b; const C;        -> TDZ
  console.log(a); // undefined (from VE)
  console.log(b); // ReferenceError (TDZ in LE)
  var a = 1;
  let b = 2;
  function f() {}
}
```

**Why interviews ask this**: It explains why `var` “leaks” out of blocks and why a `var` function expression called early gives **TypeError** (identifier exists but is `undefined`), whereas a `let` one gives **ReferenceError** (TDZ).

---

## 6) Name resolution step-by-step (a concrete trace)

```js
const lang = 'js';              // [Global LE] { lang }
function outer() {              // [Outer VE] { var x, function inner }
  var x = 10;                   // [Outer VE].x = 10
  let y = 20;                   // [Outer LE].y = 20
  return function inner(z) {    // [Inner VE] { var (none), params: z }
    let y = 99;                 // [Inner LE].y shadows outer y
    // Resolving each identifier below:
    return [x, y, z, lang];
  };
}
const f = outer();
f(7); // → [10, 99, 7, 'js']
```

* `x`: not in Inner LE/VE → found in **Outer VE**.
* `y`: found in **Inner LE**, shadows outer `y`.
* `z`: parameter in **Inner VE**.
* `lang`: not found in inner/outer → found in **Global LE**.

---

## 7) Closures & per-iteration bindings (why `let` fixes loops)

A **closure** is just an inner function **keeping a reference** to outer environment records.

**Classic pitfall:**

```js
const fns = [];
for (var i = 0; i < 3; i++) {
  fns.push(() => i);
}
fns.map(fn => fn()); // [3, 3, 3]
```

* `var i` lives in the **function** environment; each arrow closes over the **same** `i`.

**Per-iteration envs with `let`:**

```js
const fns = [];
for (let i = 0; i < 3; i++) { // new LE each iteration
  fns.push(() => i);
}
fns.map(fn => fn()); // [0, 1, 2]
```

The `for` spec creates a **new lexical environment per iteration** when the loop variable is `let`/`const`.

---

## 8) Shadowing, masking, and the TDZ

* **Shadowing**: an inner binding with the same name **hides** an outer one.

```js
let count = 1;
function g() {
  let count = 2;  // shadows outer
  return count;
}
```

* **TDZ** can make even `typeof` throw for a declared-but-uninitialized name in the current LE:

```js
console.log(typeof a); // "undefined" (a is undeclared)
console.log(typeof b); // ReferenceError (b exists in TDZ here)
let b = 1;
```

---

## 9) Global differences: script vs module

```html
<!-- script.js (classic script) -->
<script>
  var x = 1;           // window.x === 1
  let y = 2;           // window.y === undefined
</script>

<!-- module.mjs (ES module) -->
<script type="module">
  var a = 1;           // does NOT attach to window
  let b = 2;           // also not on window
  console.log(this);   // undefined at top-level in modules
</script>
```

* In **scripts**, `var` creates a property on the **global object**; `let/const` create global lexical bindings (not properties).
* In **modules**, top-level bindings **never** become global object properties; each module has its own top-level scope.

Use `globalThis` for a portable global reference.

---

## 10) Scope ≠ `this`

* **Scope** answers “where do I find the variable named `x`?”
* **`this`** answers “what object is the method operating on?” and depends on **call-site** (except arrows, which capture `this` lexically).

Arrows create their own **lexical env** (variables), but **borrow** `this`, `arguments`, `super`, `new.target` from the nearest **function** environment.

---

## 11) `eval` and `with` (why they’re frowned upon)

* **`eval(code)`**: runs code in the **current** scope (or global in strict mode), potentially **mutating** the environment chain dynamically → kills optimization, hurts readability.
* **`with (obj) { ... }`**: pushes an **Object Environment** in front of the chain; property lookups may hit `obj` first → ambiguous resolution, deopts engines.

**Best practice**: avoid both.

---

## 12) Function default parameters: hidden scope & TDZ

Parameter initializers run in a special environment **before** the body:

```js
function f(a = b, b = 2) { return a + b; }
f(); // ReferenceError: b is in TDZ when evaluating a’s default
```

Fix ordering:

```js
function g(b = 2, a = b) { return a + b; } // 4
```

Also, a parameter name shadows outer bindings during its own initializer:

```js
let x = 10;
function h(x = x) { return x; } // ReferenceError (the param x is in TDZ for itself)
```

---

## 13) Memory & performance implications

* A function that **closes over** outer variables keeps the **environment record alive**.
* Large closed-over structures can extend lifetimes → memory pressure.
* **Clean up**: set variables to `null` when done, or isolate heavy data outside closures.

```js
function makeHandler(big) {
  let cache = heavyTransform(big);
  return () => { use(cache); };
}
// If you no longer need `cache`, drop references or recreate handler.
```

---

## 14) Common pitfalls & gotchas (the stuff interviewers love)

1. **Accidental global** (non-strict):

```js
function foo() { wow = 42; } // missing var/let/const → creates global property wow
foo(); window.wow; // 42
```

Use `'use strict'` or ESLint; in strict, this throws.

2. **Early function expression call with `var`**:

```js
bar();             // TypeError: bar is not a function
var bar = function(){};
```

The binding exists (VE) but holds `undefined` until the assignment.

3. **Block function declarations** (strict): block-scoped; often invisible outside the block. Don’t rely on Annex B browser quirks.

4. **`switch` + `var`** hoists to function scope; use `{}` blocks and `let/const` per `case`.

5. **`arguments` vs params**: in non-strict mode they are aliased for simple params; in strict mode they’re decoupled. Arrows have **no** `arguments`.

6. **Module cycles**: `import` bindings exist at module start but might be **uninitialized** during a cycle; accessing too early yields `undefined` or throws. Refactor to break cycles or delay side effects.

---

## 15) Patterns & best practices

* **Declare before use**; don’t rely on hoisting for readability.
* Prefer **`const`**; use `let` when reassignment is intended; avoid `var`.
* Keep scopes **narrow**; use small blocks to limit visibility.
* Avoid shadowing unless intentional; rename inner variables to reduce confusion.
* Don’t use `eval`/`with`; turn on **strict mode** (modules are strict by default).
* Use ESLint rules: `no-undef`, `no-use-before-define`, `block-scoped-var`, `no-shadow`.
* In loops that capture variables, prefer **`let` per iteration**.
* In Node/browser apps, avoid relying on global object attachment; use **module exports/imports**.

---

## 16) Micro-exercises (answer mentally)

**Q1.** What logs and why?

```js
console.log(a); // ?
var a = 1;
{
  console.log(a); // ?
  let a = 2;
}
```

**A:** First `undefined` (var in VE). Second throws **ReferenceError** (inner `a` is in TDZ, shadows outer).

**Q2.** Why does this print `3` thrice?

```js
const out = [];
for (var i = 0; i < 3; i++) out.push(() => console.log(i));
out.forEach(fn => fn());
```

**A:** All closures share the **same** `var i` (function-scoped). Use `let i` for per-iteration environments.

**Q3.** What is `typeof x` in a module after `var x = 1`?
**A:** `"number"`, but **`window.x` is `undefined`** (doesn’t attach in modules).

---

## 17) Reference cheat-sheet (pin these)

* **Resolution order**: Current LE → parent LE → … → function VE → global → `ReferenceError`.
* **`var`** lives in **VE**; **`let/const/class`** live in **LE** (block-scoped).
* **Function declarations** are hoisted **with bodies**; function/arrow **expressions** are not.
* **TDZ** blocks any access (even `typeof`) to `let/const/class` before initialization line.
* **Modules** have their own top-level scope; bindings are **live** across imports.

---

## 18) Deep-dive code you can reason through

```js
// Global (module) LE: { A (class, TDZ), value (const TDZ), run (function decl ready) }
class A {                    // A is now initialized
  static kind = 'alpha';
  m() { return A.kind; }     // closes over A’s binding, not a string copy
}

const value = 10;            // initialize const in LE

function run(flag) {         // VE: var x; function inner
  if (flag) {
    let x = 'block';         // LE (block)
    return () => x;          // closes over that LE
  }
  var x = 'function';        // VE
  return function inner() {  // VE (inner)
    return x;                // resolves to VE.x ('function')
  };
}

console.log(run(true)());    // 'block'
console.log(run(false)());   // 'function'
```

Be able to point to **which environment** supplies each identifier.

---

If you’d like, I can turn this into a **printable PDF cheatsheet** plus a tiny **Jest test suite** that intentionally fails when scope resolution isn’t what you expect—great for drilling the mental model until it’s automatic.
