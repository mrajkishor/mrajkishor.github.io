

# ðŸ”· MySQL Stored Procedures â€” Creating and Calling

## 1. Concept

A **stored procedure** in MySQL is a precompiled collection of SQL statements stored on the server. Unlike ad-hoc SQL queries, stored procedures are compiled once, optimized, and reused. They live inside the database schema, and can encapsulate **business logic**, **data validation**, and **transactional operations** close to the data layer.

Stored procedures are executed with the `CALL` command, and can accept **parameters** (`IN`, `OUT`, `INOUT`) for input/output interaction.

---

## 2. Why Stored Procedures Matter 

At scale (enterprise systems), stored procedures are used strategically rather than casually:

* âœ… **Performance & Network Optimization**
  Reduce network round trips by executing multiple SQL statements in one call.

* âœ… **Security & Access Control**
  Encapsulate business logic and expose only necessary procedures to applications. Prevents direct table access, mitigating SQL injection and privilege abuse.

* âœ… **Consistency & Maintainability**
  Centralized data logic reduces duplication across multiple services and applications.

* âœ… **Transactional Integrity**
  Complex operations with rollbacks can be handled natively in stored procedures.

* âœ… **Enterprise Use Cases**

  * Data warehousing ETL jobs
  * Pre/post-processing in analytics pipelines
  * Multi-tenant SaaS systems for audit logging or enforcing schema rules
  * Microservices requiring **shared DB functions** across services

---

## 3. Syntax & Creation

A stored procedure is created using the `CREATE PROCEDURE` statement.

### Basic Syntax

```sql
DELIMITER $$

CREATE PROCEDURE procedure_name (
    IN param1 INT,
    OUT param2 VARCHAR(50)
)
BEGIN
    -- SQL statements go here
    SELECT column1 INTO param2
    FROM some_table
    WHERE id = param1;
END $$

DELIMITER ;
```

### Key Parts

* `DELIMITER` â†’ changes the command delimiter (default `;`) to allow semicolons inside the procedure body.
* `IN` â†’ input parameter (read-only inside the procedure).
* `OUT` â†’ output parameter (value is returned back).
* `INOUT` â†’ can be read and modified inside procedure, returned back.
* `BEGIN â€¦ END` â†’ encapsulates the procedure body.

---

## 4. Calling Stored Procedures

Stored procedures are invoked using `CALL`.

### Example

```sql
-- Example table
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    name VARCHAR(50),
    salary DECIMAL(10,2)
);

-- Create Procedure
DELIMITER //
CREATE PROCEDURE GetEmployeeSalary (
    IN empId INT,
    OUT empSalary DECIMAL(10,2)
)
BEGIN
    SELECT salary INTO empSalary
    FROM employees
    WHERE emp_id = empId;
END //
DELIMITER ;

-- Call Procedure
CALL GetEmployeeSalary(101, @empSal);

-- Retrieve OUT parameter
SELECT @empSal;
```

### Multiple Parameters

```sql
DELIMITER //
CREATE PROCEDURE UpdateSalary (
    IN empId INT,
    IN increment DECIMAL(10,2)
)
BEGIN
    UPDATE employees
    SET salary = salary + increment
    WHERE emp_id = empId;
END //
DELIMITER ;

-- Call it
CALL UpdateSalary(101, 5000.00);
```

---

## 5. Advanced Usage in Enterprise-scale Systems

* **Error Handling**

  ```sql
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
      -- log error, rollback, etc.
      ROLLBACK;
  END;
  ```

* **Transactions inside Procedures**

  ```sql
  START TRANSACTION;
      -- insert/update/delete
  COMMIT;
  ```

* **Dynamic SQL in Procedures**
  For parameterized queries that canâ€™t be hard-coded.

  ```sql
  SET @qry = CONCAT('SELECT * FROM ', tableName, ' WHERE id = ?', empId);
  PREPARE stmt FROM @qry;
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;
  ```

* **Batch Processing & Loops**

  ```sql
  DECLARE done INT DEFAULT 0;
  DECLARE empId INT;
  DECLARE cur CURSOR FOR SELECT emp_id FROM employees;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  OPEN cur;
  read_loop: LOOP
      FETCH cur INTO empId;
      IF done THEN
          LEAVE read_loop;
      END IF;
      -- process each employee
      UPDATE employees SET salary = salary * 1.1 WHERE emp_id = empId;
  END LOOP;
  CLOSE cur;
  ```

---

## 6. Best Practices (Enterprise-level)

1. **Donâ€™t abuse stored procedures** â†’ keep business logic at service/application layer unless performance/security demands otherwise.
2. **Version control** â†’ manage procedures like code (Git + migration tools like Flyway/Liquibase).
3. **Minimal privileges** â†’ grant EXECUTE on procedures instead of direct table DML rights.
4. **Performance Monitoring** â†’ track procedure runtime with Performance Schema, log slow procedures separately.
5. **Avoid excessive dynamic SQL** â†’ can reintroduce SQL injection risks.
6. **Testability** â†’ procedures should be deterministic, well-unit tested, and ideally idempotent.

---

## 7. Common Interview Questions

1. **Difference between Stored Procedures and Functions in MySQL?**
   â†’ Procedures donâ€™t return values directly (use OUT/INOUT), while functions must return a value and can be used inline with queries.

2. **When would you prefer stored procedures over ORMs?**
   â†’ When optimizing batch operations, reducing network calls, or encapsulating sensitive logic inside the DB layer.

3. **How do you handle transactions in stored procedures?**
   â†’ Use `START TRANSACTION`, `COMMIT`, `ROLLBACK`, plus error handlers to ensure atomicity.

4. **Whatâ€™s the cost of overusing stored procedures in large systems?**
   â†’ Harder maintainability, portability issues across DBs, CI/CD complications.

---


# ðŸ“‘ Code Samples: Creating and Calling Stored Procedures in MySQL

---

## 1. Basic Stored Procedure with `IN` Parameter

```sql
-- Drop if exists
DROP PROCEDURE IF EXISTS GetEmployeeName;

DELIMITER //
CREATE PROCEDURE GetEmployeeName (
    IN empId INT
)
BEGIN
    SELECT name 
    FROM employees 
    WHERE emp_id = empId;
END //
DELIMITER ;

-- Call Procedure
CALL GetEmployeeName(101);
```

ðŸ“Œ **Use case**: Quick data fetch for a single employee.

---

## 2. Stored Procedure with `OUT` Parameter

```sql
DROP PROCEDURE IF EXISTS GetEmployeeSalary;

DELIMITER //
CREATE PROCEDURE GetEmployeeSalary (
    IN empId INT,
    OUT empSalary DECIMAL(10,2)
)
BEGIN
    SELECT salary INTO empSalary
    FROM employees
    WHERE emp_id = empId;
END //
DELIMITER ;

-- Call Procedure
CALL GetEmployeeSalary(101, @sal);

-- Check output
SELECT @sal;
```

ðŸ“Œ **Use case**: Output values to application or client variables.

---

## 3. Stored Procedure with `INOUT` Parameter

```sql
DROP PROCEDURE IF EXISTS IncreaseSalary;

DELIMITER //
CREATE PROCEDURE IncreaseSalary (
    INOUT empSalary DECIMAL(10,2),
    IN increment DECIMAL(10,2)
)
BEGIN
    SET empSalary = empSalary + increment;
END //
DELIMITER ;

-- Example Usage
SET @salary = 45000;
CALL IncreaseSalary(@salary, 5000);
SELECT @salary;   -- Now 50000
```

ðŸ“Œ **Use case**: Modify an input variable and return updated value.

---

## 4. Procedure with Transaction Handling

```sql
DROP PROCEDURE IF EXISTS TransferSalary;

DELIMITER //
CREATE PROCEDURE TransferSalary (
    IN fromEmp INT,
    IN toEmp INT,
    IN amount DECIMAL(10,2)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- rollback in case of error
        ROLLBACK;
    END;

    START TRANSACTION;

    UPDATE employees
    SET salary = salary - amount
    WHERE emp_id = fromEmp;

    UPDATE employees
    SET salary = salary + amount
    WHERE emp_id = toEmp;

    COMMIT;
END //
DELIMITER ;

-- Call it
CALL TransferSalary(101, 102, 2000);
```

ðŸ“Œ **Use case**: Safely transferring values with rollback on failure.

---

## 5. Procedure with Loop & Cursor

```sql
DROP PROCEDURE IF EXISTS GiveBonus;

DELIMITER //
CREATE PROCEDURE GiveBonus (
    IN bonusAmount DECIMAL(10,2)
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE empId INT;
    DECLARE cur CURSOR FOR SELECT emp_id FROM employees;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO empId;
        IF done THEN
            LEAVE read_loop;
        END IF;

        UPDATE employees
        SET salary = salary + bonusAmount
        WHERE emp_id = empId;
    END LOOP;

    CLOSE cur;
END //
DELIMITER ;

-- Call it
CALL GiveBonus(1000);
```

ðŸ“Œ **Use case**: Batch updates for all rows using server-side cursor.

---

## 6. Procedure with Dynamic SQL

```sql
DROP PROCEDURE IF EXISTS DynamicTableQuery;

DELIMITER //
CREATE PROCEDURE DynamicTableQuery (
    IN tblName VARCHAR(50)
)
BEGIN
    SET @qry = CONCAT('SELECT * FROM ', tblName, ' LIMIT 5;');
    PREPARE stmt FROM @qry;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END //
DELIMITER ;

-- Call it
CALL DynamicTableQuery('employees');
```

ðŸ“Œ **Use case**: Dynamic queries where table name or conditions are passed as parameters.

---

## 7. Deleting a Stored Procedure

```sql
DROP PROCEDURE IF EXISTS GetEmployeeSalary;
```

ðŸ“Œ **Use case**: Clean up old or unused procedures.

---

âœ… These cover **all major patterns** youâ€™ll face in Enterprise-level systems:

* `IN`, `OUT`, `INOUT` params
* Transactions
* Error handling
* Cursors & loops for batch jobs
* Dynamic SQL for flexible queries

