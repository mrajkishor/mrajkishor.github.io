

# Hoisting Mechanics (JavaScript Deep Dive)

## 1) The Big Idea (Accurate Mental Model)

Before your code executes, JavaScript does a **setup pass** that:

* **Creates bindings** (variable/function/class/import names) in the right scopes.
* **Associates initial values** (some to `undefined`, some to “not yet initialized”).
* **Links function declarations to real function objects**.

Execution then runs line by line. This 2-phase flow is often called:

1. **Creation / Instantiation phase** (build scopes & bindings)
2. **Execution phase** (run statements and assign values)

> Hoisting is *not* textual moving. It’s the **pre-creation of bindings** so names exist before the line where they’re written.

---

## 2) What Gets Hoisted—and How (Cheat Sheet)

| Construct                        | Binding kind               | Hoisted? |       Initialized at creation? |      Access before line? |
| -------------------------------- | -------------------------- | -------: | -----------------------------: | -----------------------: |
| `var x`                          | Function/global scope      |        ✅ |                    `undefined` | ✅ (value is `undefined`) |
| `let x`                          | Block scope                |        ✅ |                        ❌ (TDZ) |       ❌ (ReferenceError) |
| `const x`                        | Block scope                |        ✅ |                        ❌ (TDZ) |       ❌ (ReferenceError) |
| `function f(){}` (declaration)   | Declared in current scope  |        ✅ |            ✅ (function object) |       ✅ (fully callable) |
| `const f = function(){}` / arrow | Block scope (like `const`) |        ✅ |                        ❌ (TDZ) |       ❌ (ReferenceError) |
| `class C {}` (declaration)       | Block scope                |        ✅ |                        ❌ (TDZ) |       ❌ (ReferenceError) |
| `import {x}` (ESM)               | Module scope               |        ✅ | ✅ (binding set up before code) |    ✅\* (see cycles note) |

**TDZ (Temporal Dead Zone)** = region from the start of the scope to the initializer where the binding exists but is **uninitialized**. Any access throws **ReferenceError**, even `typeof`.

> __More on TDZ:__ 

The **Temporal Dead Zone (TDZ)** is a *deliberate* design choice, added with `let`, `const`, `class`, and modules to make JavaScript safer and more predictable—not a patched-over flaw.

### Why TDZ exists

* **Prevents “use before init” bugs.** With `var`, you could read a variable as `undefined` before it’s assigned. TDZ makes that a **ReferenceError** instead, so you catch mistakes early.
* **Makes `const` meaningful.** If you could access a `const` before its initializer, you’d have a window where it’s neither uninitialized nor constant. TDZ closes that gap.
* **Matches block scoping intuition.** In most languages, “this name doesn’t exist until here.” TDZ enforces that for `let/const/class`.
* **Enables reliable module imports.** ES modules create *live* bindings at load time; TDZ rules keep cyclic imports from silently giving you half-initialized values.

### How to think about it

* During the *setup phase*, the engine creates a binding for `let/const/class`, but leaves it **uninitialized**.
* Until the declaration line runs, any access—even `typeof`—throws. That’s the TDZ.

```js
console.log(x); // ReferenceError (TDZ)
let x = 1;

typeof y;       // ReferenceError (TDZ)
const y = 2;
```

### Is it annoying sometimes?

It can *feel* surprising if you’re used to `var` hoisting, or in edge cases like default parameters:

```js
function f(a = b, b = 2) { /* ... */ } // ReferenceError: b in TDZ
```

…but that strictness is exactly what prevents subtle bugs.

### Performance / practicality

* **No perf penalty you need to worry about.** It’s a compile/runtime check, not an expensive feature.
* **Tooling helps.** Linters (`no-use-before-define`) will flag TDZ issues before you even run code.

### Takeaways

* TDZ is a **guardrail**, not a wart.
* Prefer `const`/`let`, declare before use, and order defaults so each initializer only refers to names already initialized.
* If something throws due to TDZ, it’s revealing a real ordering bug you should fix—not something to work around.







---

## 3) Scopes & Environment Records (Spec-level but practical)

* **Variable Environment**: where `var` lives.
* **Lexical Environment**: where `let`, `const`, `class`, and **catch** parameters live.
* **Function Environment**: parameters and function-level bindings for a call.
* **Module Environment**: bindings for ESM `import`/`export`.

During the **creation phase**, the engine:

1. Creates environments for the scope (script, module, function, block).
2. **Registers declarations**:

   * `function` declarations create **function objects** immediately.
   * `var` creates a binding **initialized to `undefined`**.
   * `let`/`const`/`class` create **uninitialized** bindings (TDZ).
   * `import` creates initialized **live immutable** bindings.

---

## 4) `var` vs `let`/`const`: Hoisting & TDZ

### `var`: hoisted + initialized to `undefined`

```js
console.log(a); // undefined
var a = 10;
```

* Scope is **function** (or global).
* Re-declaration allowed; last assignment wins.
* Inside `switch`, `var` hoists to the **enclosing function**, not per-case (common trap).

### `let` / `const`: hoisted but **uninitialized** (TDZ)

```js
console.log(b); // ReferenceError (TDZ)
let b = 10;

console.log(c); // ReferenceError (TDZ)
const c = 20;
```

* **Block-scoped** (`{}`).
* Must not be used before the initializer line.
* `const` must be initialized at declaration.

**`typeof` gotcha**:

```js
typeof d; // "undefined" if d is undeclared
typeof e; // ReferenceError if e is in TDZ (declared later with let/const)
let e = 1;
```

---

## 5) Functions: Declaration vs Expression vs Arrow

### Function **declarations** are fully hoisted

```js
hoisted();          // "ok"
function hoisted(){ console.log('ok'); }
```

* The **binding and the function object** exist before execution.

### Function **expressions** and **arrow functions** are **not** callable before the line

```js
expr();             // ReferenceError or TypeError (depending on var/let/const)
const expr = () => {};
```

* If declared with `const`/`let`, they’re in TDZ.
* If declared with `var`, the identifier is `undefined` during hoisting, so calling it early is **TypeError**.

### Function declarations **inside blocks**

* In **strict mode** (modules are strict by default), block-level function declarations are **block-scoped** and hoisted **to the block’s top** (not function top).
* In sloppy mode browsers, Annex B “web-compat” semantics can make this **messy**—don’t rely on it.

**Best practice:** avoid function declarations inside `if/for`—use function expressions.

---

## 6) Classes: Hoisted but Uninitialized (Like `let`)

```js
new C();   // ReferenceError (TDZ)
class C {}
```

* Class declarations are hoisted but in TDZ.
* Methods **inside** a class are not hoisted outside; they’re part of the class definition only after it’s evaluated.
* Class **expressions** behave like `const` bindings.

---

## 7) Parameters, Defaults, and the Hidden Scope

Default parameters have **their own scope** that is evaluated **before** the function body and can introduce TDZ surprises.

```js
function f(a = b, b = 2) {
  // At this point, parameter scope is evaluating left-to-right
}
f(); // ReferenceError: b is not defined (b is in TDZ when a’s default runs)
```

Flip the order to remove the TDZ issue:

```js
function g(b = 2, a = b) { return a; }
g(); // 2
```

Also, the parameter scope **shadows** outer bindings:

```js
let x = 10;
function h(x = x) { return x; } // ReferenceError: x (param) is in TDZ for its own initializer
```

---

## 8) Modules (`import`/`export`) and Hoisting

* **`import` declarations are hoisted**: the module loader resolves and creates **live bindings** before top-level code executes.
* You cannot reference an import “too early” within the same module because it’s available from the start.
* **Cycles caveat**: In circular dependencies, accessing an imported binding **before** the exporter has initialized it can throw (TDZ-like) or yield `undefined`. Structure modules to break cycles or move side effects later.

```js
// a.js
export const x = 1;

// b.js
import { x } from './a.js';
console.log(x); // 1 (binding available at start)
```

---

## 9) `switch` + `var` and Other Scope Oddities

```js
function demo(v) {
  switch (v) {
    case 1:
      var k = 'A'; // hoists to function scope
      break;
    case 2:
      var k = 'B'; // same binding!
      break;
  }
  return k; // 'A' or 'B' or undefined
}
```

Prefer `let/const` and introduce blocks per case:

```js
switch (v) {
  case 1: { const k = 'A'; /* ... */ break; }
  case 2: { const k = 'B'; /* ... */ break; }
}
```

**`catch` bindings** are block-scoped:

```js
try { throw 1; } catch (e) { /* e is block-scoped here */ }
```

---

## 10) `var` + Functions Name Collisions

Function declarations **win** over `var` in initialization order, but later assignments still override:

```js
console.log(typeof f); // "function"
var f = 1;
function f() {}
console.log(typeof f); // "number"
```

**Why**: creation phase installs the function object for `f`, then the `var` binding is also created with `undefined`. During execution, `var f = 1` assigns `1` to the same binding, replacing the function.

---

## 11) Real-World Pitfalls Interviewers Ask

### A) Why does this throw?

```js
console.log(foo);
let foo = 10; // TDZ → ReferenceError
```

Because `let` is hoisted but **uninitialized** until the declaration line.

### B) Why is this TypeError (not ReferenceError)?

```js
bar();                // TypeError: bar is not a function
var bar = function() {};
```

`var bar` exists and is `undefined` during creation phase; calling `undefined` as a function gives **TypeError**.

### C) Why does `typeof` sometimes throw?

```js
typeof baz;  // ReferenceError if baz is a TDZ binding
let baz = 1;
```

TDZ forbids any access (including `typeof`) before initialization.

### D) Why do these logs differ?

```js
console.log(A); // ReferenceError
class A {}

console.log(B); // undefined (but calling B() throws)
var B = function(){};
```

Classes are TDZ; `var` is `undefined` at creation.

### E) Function in block (strict mode)

```js
'use strict';
if (true) {
  function x() {}
}
x(); // ReferenceError in many environments (block-scoped func)
```

Block-scoped function declaration not visible outside the block in strict mode.

---

## 12) Execution Trace Examples (Step-by-Step)

### Example 1

```js
console.log(a, typeof b, typeof c);
var a = 1;
let b = 2;
function c(){}
```

**Creation phase**

* Create `a` (var) = `undefined`
* Create `c` (function) = function object
* Create `b` (let) = uninitialized (TDZ)

**First line executes**

* `a` → `undefined`
* `typeof b` → **ReferenceError** (TDZ forbids even `typeof`)
* `typeof c` → `"function"`

So this program actually **throws** before logging. Many devs expect `"undefined" "undefined" "function"`, but TDZ changes the middle part.

Fix by moving the `console.log` after `let b = 2`.

---

## 13) Practical Guidance & Best Practices

* **Declare before use.** Don’t rely on hoisting for readability.
* Prefer **`const`** (and `let` when reassignment is required).
* Avoid function declarations **inside blocks**; use function expressions if you need conditional definition.
* Use **ES modules** (`import`/`export`) over globals and IIFEs.
* Break **circular dependencies** in modules (move side effects to functions or split files).
* Turn on **strict mode** (modules are strict) and a linter:

  * ESLint: `no-use-before-define`, `no-undef`, `block-scoped-var`.
* When debugging hoist/TDZ issues, search for:

  * Access to a name before its declaration line.
  * Default parameter ordering pitfalls.
  * Unexpected `var` behavior in `switch` or loops.

---

## 14) Mini Quiz

1. What prints?

```js
console.log(x);
var x = 5;
(() => {
  console.log(x);
  let x = 10;
})();
```

**Answer:** First `undefined`. Then **ReferenceError** inside IIFE due to TDZ.

2. Why does this fail?

```js
function f(a = b, b = 1) { return a + b; }
f();
```

**Answer:** `a`’s default evaluates first; `b` is in TDZ → ReferenceError.

3. What prints in strict mode?

```js
'use strict';
if (true) {
  function z() { return 1; }
}
console.log(typeof z);
```

**Answer:** Likely `"undefined"` because the function is **block-scoped** in strict mode. (Don’t rely on Annex B variations.)

---

## 15) Takeaway One-Liners

* **`var` is hoisted to `undefined`; `let/const/class` are hoisted to the TDZ.**
* **Function declarations are hoisted with their bodies; expressions are not.**
* **Imports are hoisted and live; cyclic imports can create TDZ-like traps.**
* **Default parameter evaluation has its own scope—watch order.**
* **Don’t rely on hoisting; write declarations before use and avoid block-level function declarations.**

