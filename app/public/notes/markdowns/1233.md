

# 🔷 Printing a Name N Times using Recursion – Deep Dive

## 1. Concept

This problem introduces the idea of **parameterized recursion**, where the recursive function keeps track of state (like how many times a task has been executed) by passing arguments.

* Unlike the previous example where a global counter was used, here the counter is passed as a **parameter**.
* This demonstrates how recursion can simulate iteration, but with **explicit tracking of progress** inside the call stack.

---

## 2. Problem Statement

**Task:** Print a given name (e.g., `"Raj"`) exactly `N` times using recursion.

Key challenges:

1. No global/static variable to track count.
2. Must terminate recursion after exactly `N` prints.
3. Must use recursion parameters (`i`, `n`) to keep state.

---

## 3. Pseudocode

```cpp
void func(int i, int n) {
    if (i > n) return;         // Base condition
    print("Raj");              // Work to do in each call
    func(i + 1, n);            // Recursive case
}

main() {
    int n = 3;
    func(1, n);
}
```

**Explanation:**

* `i` → current iteration count (starts from 1).
* `n` → total number of times to print.
* Base case: stop when `i > n`.
* Recursive case: print once, then call with `i+1`.

---

## 4. Recursion Tree

For `func(1, 3)`:

```
func(1,3) → print("Raj")
    func(2,3) → print("Raj")
        func(3,3) → print("Raj")
            func(4,3) → return (base case hit)
```

Execution order:

* Prints occur **top-down**.
* When `i = 4`, recursion stops.

---

## 5. Core Takeaways

1. **Base Case** → essential to terminate recursion (`i > n`).
2. **Parameterized Approach** → avoids using global variables (safer, cleaner).
3. **Stack Growth** → depth of recursion = `N`.
4. **Unwinding Behavior** → no work done while returning, since printing happens **before recursive call** (pre-order).

---

## 6. Space & Time Complexity

* **Time Complexity:** O(N) (one print per recursive call).
* **Space Complexity:** O(N) (stack frames for each recursive call).

⚠️ In interviews, always highlight **stack overhead** — iterative version only uses O(1) space.

---

## 7. Variations 

This simple problem can be extended to **test deeper recursion understanding**:

1. **Print Name N times in Reverse**

   * Print after recursive call → work happens in **post-order**.

   ```cpp
   void func(int i, int n) {
       if (i > n) return;
       func(i + 1, n);      
       print("Raj");        // printing on return
   }
   ```

   🔹 Output order changes completely.

2. **Remove Parameters (use global/static variable)**
   Simpler, but **less modular**. Discuss pros & cons in interviews.

3. **Tail Recursion Optimization (TRO)**
   Some compilers can optimize tail recursion (if the recursive call is the last operation). In our example, `func(i+1, n)` is indeed a **tail call**.

   * **Interview note:** Tail recursion can be transformed into iteration automatically in optimized compilers (not guaranteed in Java/Python, partially in C++ with flags).

4. **Functional Programming Parallel**
   In FP languages (Haskell, Scala), recursion replaces loops entirely. Understanding **parameter passing** is key.

---

## 8. Real-World Analogy

Think of recursion here as a **person handing tasks down a chain**:

* Person 1 prints once, tells Person 2 to do the same.
* Person 2 prints once, tells Person 3.
* … until Person `N`.
* Person `N+1` stops → chain ends.

This analogy helps **explain recursion intuitively in interviews**.

---

## 9. Common Interview Pitfalls

* ❌ Forgetting base case → infinite recursion.
* ❌ Incorrect condition (`i == n` instead of `i > n`) → off-by-one errors.
* ❌ Confusing **pre-order** vs **post-order** printing.
* ❌ Not mentioning **stack overhead** in complexity analysis.

Interviewers often ask:
👉 *“What happens if N = 10^6?”*
Answer: Stack overflow in most languages (since recursion depth is too large). Iterative solution is better for large N.

---

## 🔑 Summary

* This problem teaches **parameterized recursion**.
* Recursion tree shows **progression & termination**.
* Space = O(N), Time = O(N).
* Printing location (before or after recursive call) defines order.
* Interviewers expect discussion on:

  * Base case correctness
  * Iterative vs recursive trade-offs
  * Stack limitations & TRO

----


# 🔷 Recursion Problems


## 1. Print Name N Times

### Concept
- **Problem Statement**: Print a given name exactly `N` times using recursion (without loops or global variables).  
- **Recursive Idea**: Treat each print as a recursive step until the base case halts execution.  
- **Function Signature**: `f(i, n)` where `i` starts at 1 and increments until it exceeds `n`.  

### Code

```java
public class RecursionProblems {

    // Print name N times
    static void printName(int i, int n) {
        if (i > n) return;   // base case
        System.out.println("Raj");  // replace with your name
        printName(i + 1, n); // recursive call
    }

    public static void main(String[] args) {
        int n = 5;
        printName(1, n);
    }
}
```

### Recurrence Relation
- **Base Case**: If `i > n`, stop recursion (`return`).  
- **Recursive Step**: Print name → call `f(i+1, n)`.

### Time & Space Complexity
- **Time**: `O(N)` (N print operations).  
- **Space**: `O(N)` due to recursion stack depth.

### Insight
- This is the simplest recursion pattern: **linear recursion with a single recursive branch**.  
- Mirrors “iterative loop” logic but is memory-heavier due to stack calls.  
- Often asked in interviews to test whether candidates can map loops → recursion.

---

## 2. Print Numbers from 1 to N (Linearly Increasing)

### Concept
- **Problem Statement**: Print integers from 1 to N sequentially using recursion.  
- **Recursive Idea**: Each function call handles one number and passes control to the next.  

### Code

```java
public class RecursionProblems {

    static void print1ToN(int i, int n) {
        if (i > n) return;   // base case
        System.out.println(i);
        print1ToN(i + 1, n); // recurse forward
    }

    public static void main(String[] args) {
        int n = 5;
        print1ToN(1, n);
    }
}
```

### Recurrence Relation
- `f(i, n)`: if `i > n`, stop. Otherwise, print `i`, then call `f(i+1, n)`.

### Example (N=4)
```
f(1,4) → print(1)
f(2,4) → print(2)
f(3,4) → print(3)
f(4,4) → print(4)
f(5,4) → base case (stop)
```

### Insight
- Introduces the concept of **pre-order execution** in recursion (work first, recurse later).  
- Useful analogy: tree traversals often follow similar patterns.

---

## 3. Print Numbers from N to 1 (Linearly Decreasing)

### Concept
- **Problem Statement**: Print integers in reverse order from N down to 1.  
- **Recursive Idea**: Start with N, decrement by 1 each call until reaching base condition.  

### Code

**==Using recursion==**

```java
public class RecursionProblems {

    static void printNTo1(int i) {
        if (i < 1) return;   // base case
        System.out.println(i);
        printNTo1(i - 1);    // recurse backward
    }

    public static void main(String[] args) {
        int n = 5;
        printNTo1(n);
    }
}
```

==**Using backtracking** | further discussed below==

```java
   public class RecursionProblems {
    
        static void print1ToN(int i, int n) {
            if (i > n) return;   // base case
            print1ToN(i + 1, n); // recurse forward
            System.out.println(i);
        }
    
        public static void main(String[] args) {
            int n = 5;
            print1ToN(1, n);
        }
    }
```

### Recurrence Relation
- `f(i, n)`: if `i < 1`, stop. Otherwise, print `i`, then call `f(i-1, n)`.

### Example (N=3)
```
f(3,3) → print(3)
f(2,3) → print(2)
f(1,3) → print(1)
f(0,3) → base case (stop)
```

###  Insight
- Demonstrates how recursion flow direction (increment vs decrement) changes traversal order.  
- Reinforces symmetry in recursion: moving forward or backward is just a parameter flip.

---

## 4. Print 1 to N Using Backtracking

### Concept
- **Problem Statement**: Print integers from 1 to N, but recursion must start from N and decrement.  
- **Constraint**: Printing should happen after recursion call → forces output in increasing order.  

### Code

```java
public class RecursionProblems {

    static void print1ToNBacktrack(int i) {
        if (i < 1) return;   // base case
        print1ToNBacktrack(i - 1);  // recursive call first
        System.out.println(i);      // **action after recursion** <= this is the core definition of backtracking
    }

    public static void main(String[] args) {
        int n = 5;
        print1ToNBacktrack(n);
    }
}
```


### Technique
- Define `f(i, n)` with:  
  - **Base Case**: if `i < 1`, return.  
  - **Recursive Call**: `f(i-1, n)`.  
  - **Action After Recursion**: print `i`.

### Example (N=3)
```
f(3,3):
  f(2,3):
    f(1,3):
      f(0,3) → stop
      print(1)
    print(2)
  print(3)
```
**Output**: `1 2 3`

### Insight
- Introduces **post-order execution** (do recursive call first, then work).  
- Key takeaway: **position of the print statement relative to recursion** determines order of output.  
- This idea generalizes to DFS tree traversals: pre-order vs post-order vs in-order.

---

## 5. Challenge: Print N to 1 Using Backtracking

### Code

```java
public class RecursionProblems {

    static void printNTo1Backtrack(int i, int n) {
        if (i > n) return;   // base case
        printNTo1Backtrack(i + 1, n);  // recurse forward
        System.out.println(i);         // action after recursion
    }

    public static void main(String[] args) {
        int n = 5;
        printNTo1Backtrack(1, n);
    }
}
```

Output for n=5:

```sh
5
4
3
2
1
```


### Concept
- Opposite of #4.  
- **Constraint**: Cannot directly decrement `i` in the recursive call.  
- Candidate must reason about where to place the print relative to recursion.

###  Insight
- This is left as an **interview exercise** to test creative recursion design.  
- Core lesson: recursion flow + print placement → controls execution order.  
- Teaches candidates to think beyond “just writing recursive calls” and focus on **execution context**.

---

# 🔷 Complexity Summary

- **All problems** run in:
  - Time: `O(N)` (each number/name printed once).  
  - Space: `O(N)` (stack depth equals number of recursive calls).  
- Optimization: Tail recursion could optimize stack usage (compiler dependent).  
- In interviews, be ready to compare recursion with iterative solutions and justify trade-offs (clarity vs stack overhead).

---

# 🔷  Interview Takeaways
1. Always define **base case** clearly → prevents infinite recursion.  
2. Understand **where to place operations** (before vs after recursive call).  
3. Map iterative loops into recursion → demonstrates clarity of thought.  
4. Think in terms of **recursion tree expansion and unwinding**.  
5. Be prepared to **analyze space complexity** (stack frames are implicit).  
6. Recognize that backtracking = recursion + decision at unwind time.  

---

👉 These problems are deliberately simple but are the **foundation of recursion patterns** used in interview questions (e.g., permutations, combinations, subset generation, DFS traversals, dynamic programming).  

