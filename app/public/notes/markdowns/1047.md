

###  **Overview**

---

### üîç **What is the Shortest Path Problem?**

The **Shortest Path Problem** refers to finding the path between two nodes in a graph such that the sum of the weights of its constituent edges is minimized.

It is fundamental in **graph theory**, **network design**, **routing algorithms**, and **AI pathfinding**. Depending on the type of graph and the presence of edge weights (positive/negative), different algorithms are used.

---

### üìÇ **Types of Shortest Path Problems**

| Category                               | Description                                                                                |
| -------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Single Source Shortest Path (SSSP)** | Find the shortest paths from a **single source** node to **all other** nodes in the graph. |
| **Single Pair Shortest Path**          | Find the shortest path between **two specific nodes**.                                     |
| **All-Pairs Shortest Path (APSP)**     | Find the shortest paths between **every pair of nodes** in the graph.                      |

---

### üìö **Graph Characteristics Affecting Algorithm Choice**

| Graph Property              | Impact on Algorithm                                                               |
| --------------------------- | --------------------------------------------------------------------------------- |
| **Weighted vs. Unweighted** | BFS works for unweighted graphs; Dijkstra for weighted with non-negative weights. |
| **Negative Edge Weights**   | Requires Bellman-Ford (SSSP) or Johnson's Algorithm (APSP).                       |
| **Cyclic vs. Acyclic**      | Topological sort-based algorithms work only on DAGs (Directed Acyclic Graphs).    |
| **Dense vs. Sparse Graphs** | Dense graphs ‚Üí Floyd-Warshall may be fine. Sparse graphs ‚Üí Dijkstra is faster.    |

---

### üß† **Why Are There Multiple Algorithms?**

Each algorithm is tailored to a **specific graph scenario**. There is **no single universal shortest path algorithm** because of:

* Negative weights
* Cycles
* Weighted vs. unweighted constraints
* Scalability and complexity trade-offs

---

### üèÅ **High-Level Algorithms Overview**

| Algorithm                    | Graph Type                 | Negative Weights? | Use Case                                                |
| ---------------------------- | -------------------------- | ----------------- | ------------------------------------------------------- |
| **DFS (for Trees only)**     | Unweighted, Acyclic        | ‚ùå                 | Used when graph is a tree                               |
| **BFS**                      | Unweighted                 | ‚ùå                 | Shortest path in unweighted graphs                      |
| **Multi-Source BFS**         | Unweighted                 | ‚ùå                 | Start from multiple sources simultaneously              |
| **Dijkstra's Algorithm**     | Weighted, Non-negative     | ‚ùå                 | Most widely used for SSSP                               |
| **Bellman-Ford Algorithm**   | Weighted                   | ‚úÖ                 | Handles negative weights & detects negative cycles      |
| **Topological Sort Based**   | DAG                        | ‚úÖ                 | Linear time for DAGs with weights                       |
| **Floyd-Warshall Algorithm** | Weighted                   | ‚úÖ                 | APSP in dense graphs, uses DP                           |
| **Johnson‚Äôs Algorithm**      | Weighted                   | ‚úÖ                 | APSP in sparse graphs, reweights to use Dijkstra        |
| **A* (A-Star)*\*             | Weighted, heuristic-guided | ‚ùå                 | AI pathfinding, approximates best path using heuristics |

---

### üìä **Time and Space Complexity Summary**

| Algorithm                | Time Complexity      | Space Complexity | Notes                                      |
| ------------------------ | -------------------- | ---------------- | ------------------------------------------ |
| DFS                      | O(V)                 | O(V)             | Only works in trees                        |
| BFS                      | O(V + E)             | O(V)             | For unweighted graphs                      |
| Dijkstra                 | O(E log V)           | O(V)             | With min-priority queue                    |
| Bellman-Ford             | O(V¬∑E)               | O(V)             | Slower, but supports negative weights      |
| Topological Sort + Relax | O(V + E)             | O(V)             | Only for DAGs                              |
| Floyd-Warshall           | O(V¬≥)                | O(V¬≤)            | APSP via DP                                |
| Johnson's Algorithm      | O(V¬≤ log V + VE)     | O(V¬≤)            | APSP with negative weights                 |
| A\* Search               | O(E log V) (average) | O(V)             | Heuristic-based, non-optimal in worst case |

---

### üíº **Real-World Applications**

* **Navigation systems (Google Maps, GPS)** ‚Äì Dijkstra, A\*
* **Network routing (OSPF, BGP)** ‚Äì Bellman-Ford, Dijkstra
* **Game AI (Pathfinding)** ‚Äì A\* Search
* **Transport logistics (Airline/Train/Delivery)** ‚Äì Floyd-Warshall, Johnson
* **Social networks** ‚Äì BFS for connection path, influence graphs

---

### üìå **Important GATE Considerations**

| Topic                                               | Frequently Asked? |
| --------------------------------------------------- | ----------------- |
| Dijkstra's working & PQ usage                       | ‚úÖ                 |
| Bellman-Ford vs. Dijkstra (negative weights)        | ‚úÖ                 |
| Detecting negative cycles                           | ‚úÖ                 |
| Floyd-Warshall state transitions                    | ‚úÖ                 |
| Complexity comparison & when to use which algorithm | ‚úÖ                 |
| BFS/DFS shortest path assumptions                   | ‚úÖ                 |
| Real-world application scenarios                    | ‚ö†Ô∏è Sometimes      |

---

### üß™ **Common Pitfalls**

* Trying to use **Dijkstra on graphs with negative weights** ‚Äì leads to incorrect answers.
* Not initializing distances properly (e.g., source = 0, others = ‚àû).
* Forgetting to **check for cycles** in Bellman-Ford after `V-1` relaxations.
* Using **Floyd-Warshall** unnecessarily on sparse graphs ‚Üí high memory/time cost.

---

### üîö Summary

The **Shortest Path Overview** forms the foundation of many algorithmic applications in GATE, AI, and real-world systems. Knowing **when and why** to use each algorithm is more important than memorizing code. Focus on **graph type**, **edge weights**, and **optimization needs** to choose the right algorithm.


