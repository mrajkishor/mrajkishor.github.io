
### JavaScript Interview Questions & Answers

---

## 1) What are the different data types in JavaScript?

**Short list**

* **Primitives** (immutable): `string`, `number` (includes `NaN`, `Infinity`), `bigint`, `boolean`, `undefined`, `symbol`, `null`
* **Non-primitives** (objects): `object` (arrays, functions, dates, regexps, maps/sets, etc.)

**Key details & gotchas**

* `typeof null === "object"` (historic bug—know it).
* Arrays, functions, dates… are **all objects**:

  * `Array.isArray([])` ⇒ true
  * `typeof function(){} === "function"` (a **callable object**).
* `number` is IEEE-754 double; watch out for precision: `0.1 + 0.2 !== 0.3`.
* `bigint` is for integers of arbitrary size: `123n`; **cannot mix** with `number` in arithmetic.
* `symbol` creates unique identifiers: `Symbol('id') !== Symbol('id')`.
* **Boxed primitives** (`new String("a")`) are objects; prefer literals.

**Useful checks**

```js
typeof 42            // "number"
typeof NaN           // "number"
typeof undefined     // "undefined"
typeof null          // "object"  <- gotcha
Object.prototype.toString.call(/re/) // "[object RegExp]"
```

---

## 2) Difference between `var`, `let`, and `const`?

* **Scope**

  * `var` → **function** scope (or global if outside any function).
  * `let`/`const` → **block** scope (`{ ... }`, `if`, `for`).
* **Hoisting**

  * All declarations are hoisted, but:

    * `var` is initialized to `undefined`.
    * `let`/`const` sit in the **Temporal Dead Zone (TDZ)** until the line where declared.
* **Re-bind / Re-declare**

  * `var` can be **redeclared** and **reassigned**.
  * `let` can be **reassigned** (not redeclared in same scope).
  * `const` can **not** be reassigned (but object contents can mutate).

**Loop gotcha**

```js
// var: all timeouts log 3 (same binding reused)
for (var i = 0; i < 3; i++) setTimeout(() => console.log(i));
// let: 0,1,2 (new binding per iteration)
for (let j = 0; j < 3; j++) setTimeout(() => console.log(j));
```

---

## 3) Explain hoisting.

**Mental model:** Before code runs, the engine scans the scope and **registers declarations**.

* **Function declarations** are hoisted **with their bodies**.
* **var** is hoisted and initialized to `undefined`.
* **let/const** are hoisted but uninitialized → **TDZ** until the declaration line.

```js
say();               // "hi" (works: function decl hoisted w/ body)
function say(){ console.log('hi'); }

console.log(a);      // undefined (var hoisted, set to undefined)
var a = 5;

console.log(b);      // ReferenceError (TDZ)
let b = 5;
```

**Function expression vs declaration**

```js
foo();               // TypeError: foo is not a function
var foo = function(){};
```

---

## 4) `==` vs `===`

* `===` **strict**: same type + same value.
* `==` **loose**: uses coercion rules (error-prone).

**Memorize a few `==` quirks**

```js
0 == '0'           // true
'' == 0            // true
false == '0'       // true
null == undefined  // true
[] == ''           // true
[] == 0            // true
[1] == 1           // true
```

**When to use what**

* Prefer `===` everywhere.
* If you truly need “nullish or undefined”: `x == null` is a concise test (true for both).
* `Object.is(a, b)` is like strict equality but:

  * `Object.is(NaN, NaN)` ⇒ true
  * `Object.is(0, -0)` ⇒ false

---

## 5) Explain closures.

A **closure** happens when a function **remembers** variables from its outer scope, even after that outer function finished.

**Why it matters**

* Encapsulation / private state
* Partial application / currying
* Memoization
* Event handlers & async code

```js
function counter() {
  let c = 0;
  return () => ++c;
}
const inc = counter();
inc(); // 1
inc(); // 2
```

**Classic pitfall (fixed with `let`)**

```js
for (var i=1; i<=3; i++) setTimeout(()=>console.log(i), 0); // 4,4,4
for (let j=1; j<=3; j++) setTimeout(()=>console.log(j), 0); // 1,2,3
```

---

## 6) What is the event loop?

The **event loop** coordinates:

* **Call stack** (sync JS)
* **Task (macrotask) queue**: `setTimeout`, `setInterval`, DOM events, I/O
* **Microtask queue**: `Promise.then/catch/finally`, `queueMicrotask`, MutationObserver

**Order (browser)**

1. Run all synchronous code on the **stack**.
2. Drain the **microtask queue** completely.
3. Take one **task** (macrotask) and run it.
4. Repeat.

```js
console.log('A');
setTimeout(()=>console.log('T'), 0);
Promise.resolve().then(()=>console.log('M'));
console.log('B');
// A, B, M, T
```

**Node.js nuance**: has `process.nextTick()` (runs **before** other microtasks) and additional phases, but the microtask-before-macrotask rule still applies.

---

## 7) What are promises and `async/await`?

**Promise**: an object representing an async result with states:

* **pending → fulfilled** (value) **or → rejected** (reason)

**Chaining & error handling**

```js
fetch('/api')
  .then(r => r.json())
  .then(data => console.log(data))
  .catch(err => console.error(err))
  .finally(() => console.log('done'));
```

**`async/await`** is syntax over promises:

```js
async function load() {
  try {
    const [u1, u2] = await Promise.all([fetch('/u1'), fetch('/u2')]);
    return [await u1.json(), await u2.json()];
  } catch (e) {
    // handle
  }
}
```

**Tips**

* Use `Promise.all` for **parallel** work; multiple `await`s in sequence are **serial**.
* Unhandled rejections crash Node in strict settings—always `.catch` or try/catch.
* Inside `async`, thrown errors become rejected promises.

---

## 8) What is `this` in JavaScript?

`this` is **dynamic** and depends on **call-site**, not where you wrote the function.

* **Global (non-strict)**: `this === window` in browsers.
* **Strict mode**: `this === undefined` in plain functions.
* **Method call**: `obj.m()` ⇒ `this === obj`.
* **Constructor**: `new F()` ⇒ `this` is the newly created object.
* **Explicit binding**: `fn.call(x)`, `fn.apply(x)`, `fn.bind(x)`.
* **Arrow functions**: **no own `this`**; they **lexically inherit** `this` from the surrounding scope (great for callbacks in classes).

```js
const obj = {
  x: 1,
  m() { console.log(this.x); }
};
const f = obj.m;
f();          // undefined (or error in strict) — lost receiver
f.call(obj);  // 1
```

---

## 9) `null` vs `undefined`

* **`undefined`**: “no value assigned” (default for uninitialized variables, missing function args, missing object properties).
* **`null`**: “intentional absence of value” set by the programmer.

**Equality**

```js
null == undefined   // true (only this pair)
null === undefined  // false
```

**Practical**

* Use `x == null` as a compact check for both nullish values.
* Prefer explicit `null` to signal “cleared” or “no result” intentionally.

---

## 10) `call()`, `apply()`, `bind()`

All three set the `this` value for a function:

* **`fn.call(thisArg, a, b)`** – invoke immediately, pass args individually.
* **`fn.apply(thisArg, [a, b])`** – invoke immediately, pass args as **array** (handy for spread before ES6).
* **`fn.bind(thisArg, a, b)`** – **does not call**; returns a **new function** with `this` and (optionally) **pre-set** arguments (partial application).

```js
function greet(g, n){ return `${g}, ${n}! from ${this.city}`; }
const ctx = { city: 'Bangalore' };

greet.call(ctx, 'Hi', 'Ava');
greet.apply(ctx, ['Hi', 'Ava']);

const hiFromBLR = greet.bind(ctx, 'Hi');
hiFromBLR('Ava');
```

**Arrow functions note:** `bind/call/apply` **don’t change** `this` of arrow functions (they’re lexical).

---

## 11) Debouncing vs Throttling

* **Debounce**: wait for silence. The function runs **after** no calls have happened for `wait` ms.
  Use cases: search box, window resize, auto-save.

* **Throttle**: limit the rate. The function runs at most **once every** `wait` ms, ignoring extra calls.
  Use cases: scroll handlers, mousemove, continuous gestures.

```js
const debounced = debounce(save, 300);  // run 300ms after user stops typing
const throttled = throttle(trackMouse, 100); // run at most every 100ms
```

**Options** (common in libraries like Lodash):

* leading/trailing calls
* cancel/flush methods

---

## 12) Shallow copy vs Deep copy

* **Shallow copy**: copies the **top level**; nested objects share references.

```js
const a = { nest: { x: 1 } };
const b = { ...a };          // shallow
b.nest.x = 2;
a.nest.x; // 2 (same nested object)
```

* **Deep copy**: recursively clones.

**Ways**

* `structuredClone(value)` (modern, handles Map/Set/Date/RegExp/ArrayBuffer; not functions/DOM nodes).
* Custom recursive clone with a `WeakMap` to handle cycles.
* `JSON.parse(JSON.stringify(obj))` (simple but lossy: drops `undefined`, `Symbol`, functions; dates become strings, loses prototypes).

---

## 13) Prototypal inheritance

Every object has an internal `[[Prototype]]` (accessible via `Object.getPrototypeOf(obj)` or `obj.__proto__`). Property lookup **walks up the chain** until found or reaches `null`.

```js
const parent = { greet(){ return 'hi'; } };
const child = Object.create(parent);
child.greet(); // "hi" (from parent)

function Person(name){ this.name = name; }
Person.prototype.say = function(){ return 'I am ' + this.name; };
new Person('Sam').say(); // works via prototype
```

**Clarifications**

* `prototype` property exists on **functions** (used when calling with `new`) to set the `[[Prototype]]` of instances.
* `class` in JS is **syntax sugar** over prototypes (plus `super`, field initializers).
* Use `hasOwnProperty` to check own vs inherited props.

---

## 14) Memory management in JS

JS uses **automatic garbage collection** (mark-and-sweep). If an object becomes **unreachable** from GC roots (globals, current stack, closures), it’s eligible for collection.

**Common leak patterns**

* **Accidentally global** variables (`window` references).
* **Uncleared timers** / intervals / event listeners.
* **Detached DOM nodes** kept in JS data structures.
* **Long-lived caches** without eviction.

**Tips**

* Null out large references when done: `bigArray = null`.
* `finally` blocks to clean up.
* For caches, use `Map` + eviction (LRU) or `WeakMap`/`WeakSet` so keys don’t prevent GC.

---

## 15) Modules in JavaScript

**Why modules?** Encapsulation, reuse, separate dependency graph, tree-shaking.

### ES Modules (ESM)

* Syntax: `import` / `export`
* **Static** structure: imports must be at top level (enables tree-shaking).
* **Module scope** (no globals leaked).
* `import` is **hoisted**; **top-level await** is supported.
* Browser: `<script type="module">`.
* Node: use `.mjs` or `"type": "module"` in `package.json`.

```js
// math.js
export const PI = 3.14;
export default function area(r){ return PI*r*r; }

// use.js
import area, { PI } from './math.js';
```

### CommonJS (CJS)

* Node’s older system.
* Syntax: `const x = require('./x')`; `module.exports = ...`
* **Dynamic** (can require conditionally).
* Not tree-shakable by default.

```js
// math.cjs
exports.PI = 3.14;
module.exports.area = r => exports.PI*r*r;
```

**Interop notes**

* Mixing ESM & CJS can be tricky; prefer one style per package.
* In bundlers, ESM is preferred for optimization.

