Here are the **most commonly asked Java interview questions on Multithreading**, with clear and concise answers ‚Äî tailored for **Java full-stack developers with 7+ years of experience** (Wipro, TCS, Infosys, Product companies).

---

## ‚úÖ **1. What is a Thread in Java?**

**Answer:**
A thread is the **smallest unit of execution** in a Java program. Java uses threads to allow **multiple tasks to run concurrently**.

---

## ‚úÖ **2. How do you create a thread in Java?**

**Answer:**
There are **3 ways**:

1. **Extend `Thread` class**:

   ```java
   class MyThread extends Thread {
       public void run() { /* task */ }
   }
   ```
2. **Implement `Runnable` interface** (preferred):

   ```java
   class MyTask implements Runnable {
       public void run() { /* task */ }
   }
   ```
3. **Use `Executors` and `Callable` (modern way)**:

   ```java
   ExecutorService executor = Executors.newFixedThreadPool(2);
   executor.submit(() -> { /* task */ });
   ```

---

## ‚úÖ **3. What is the difference between `Runnable` and `Callable`?**

| Feature      | Runnable                        | Callable                          |
| ------------ | ------------------------------- | --------------------------------- |
| Return value | No (`void run()`)               | Yes (`V call() throws Exception`) |
| Exceptions   | Cannot throw checked exceptions | Can throw checked exceptions      |
| Usage        | `Thread`, `ExecutorService`     | `ExecutorService` + `Future`      |

---

## ‚úÖ **4. What is the difference between `start()` and `run()` method in threads?**

**Answer:**

* `start()` ‚Üí creates a **new thread**, then calls `run()` inside it.
* `run()` ‚Üí just a normal method, runs in **current thread** if called directly.

```java
new MyThread().start(); // ‚úÖ multi-threaded
new MyThread().run();   // ‚ùå single-threaded, no actual thread started
```

---

## ‚úÖ **5. What is Thread Lifecycle in Java?**

1. **New** ‚Üí Thread created
2. **Runnable** ‚Üí After `start()`, ready to run
3. **Running** ‚Üí Actually executing
4. **Blocked/Waiting/Sleeping** ‚Üí Temporarily inactive
5. **Terminated (Dead)** ‚Üí Completed or crashed

---

## ‚úÖ **6. What is the difference between `synchronized` method and block?**

| Feature     | Synchronized Method       | Synchronized Block           |
| ----------- | ------------------------- | ---------------------------- |
| Scope       | Entire method             | Specific code block          |
| Lock object | Current instance (`this`) | Custom object or class-level |
| Flexibility | Low                       | High (can reduce contention) |

**Block example:**

```java
synchronized(lock) {
    // critical section
}
```

---

## ‚úÖ **7. What is a Race Condition?**

**Answer:**
A **race condition** occurs when two or more threads access shared data at the same time, and the **result depends on the timing of the thread execution**.

Example:

```java
counter++;
```

is **not atomic** ‚Äî multiple threads can read the same value and overwrite each other‚Äôs increments.

---

## ‚úÖ **8. What is `volatile` keyword?**

**Answer:**

* Ensures **visibility** of changes to variables across threads.
* Prevents **caching** of variable by threads ‚Äî always read from **main memory**.

**Use case:**

```java
volatile boolean flag = true;
```

Without `volatile`, a thread may never see the latest value of `flag`.

---

## ‚úÖ **9. What is Thread Safety?**

**Answer:**
Code is **thread-safe** if it functions correctly when **accessed by multiple threads concurrently**, without introducing race conditions or inconsistent state.

Ways to achieve:

* `synchronized`
* `volatile`
* Atomic classes (e.g., `AtomicInteger`)
* `ReentrantLock`
* Using thread-safe data structures (`ConcurrentHashMap`, etc.)

---

## ‚úÖ **10. What is `ThreadPool` and why use it?**

**Answer:**
A **ThreadPool** manages a fixed number of reusable threads ‚Äî instead of creating a new thread for every task.

Used via:

```java
ExecutorService pool = Executors.newFixedThreadPool(5);
pool.submit(() -> { /* task */ });
```

‚úÖ Benefits:

* Better performance
* Controlled concurrency
* Resource management

---

## ‚úÖ **11. Difference between `sleep()` and `wait()`?**

| Feature           | `sleep()`                       | `wait()`                                        |
| ----------------- | ------------------------------- | ----------------------------------------------- |
| From              | `Thread` class                  | `Object` class                                  |
| Holds lock?       | Yes (if in synchronized method) | No (releases lock)                              |
| Wake-up?          | After time expires              | Only when `notify()` or `notifyAll()` is called |
| Checked Exception | Yes                             | Yes                                             |

---

## ‚úÖ **12. What are `synchronized`, `ReentrantLock`, and `Atomic` classes?**

| Mechanism           | Use For                   | Notes                           |
| ------------------- | ------------------------- | ------------------------------- |
| `synchronized`      | Basic locking             | Easy but coarse-grained         |
| `ReentrantLock`     | Advanced locking          | Manual control over lock/unlock |
| `AtomicInteger` etc | Lock-free thread-safe ops | Fast, for counters, flags, etc. |
    
---

More...

### üîí 1. **What is the `synchronized` keyword in Java?**

**Answer:**

The `synchronized` keyword is used to control access to critical sections of code or objects by multiple threads. It ensures that only one thread at a time can execute the synchronized block/method.

There are two main forms:

* **Synchronized method**: Locks on the object (or class, for static methods).
* **Synchronized block**: Allows locking on any object for finer control.

```java
public synchronized void increment() {
    count++;
}

public void increment() {
    synchronized (this) {
        count++;
    }
}
```

**Why use it?**
To avoid **race conditions**, where two threads read-modify-write shared data concurrently, leading to inconsistent state.

---

### ‚ö° 2. **What is `volatile` in Java and how is it different from `synchronized`?**

**Answer:**

`volatile` is a keyword used to mark a variable's **visibility across threads**. When a variable is declared `volatile`, every read will be from main memory and not from thread-local caches.

```java
private volatile boolean running = true;

public void run() {
    while (running) {
        // do work
    }
}

public void stop() {
    running = false;
}
```

**Key differences with `synchronized`:**

| Feature     | `volatile`                   | `synchronized`                   |
| ----------- | ---------------------------- | -------------------------------- |
| Visibility  | Ensures visibility only      | Ensures visibility and atomicity |
| Atomicity   | Not guaranteed               | Guaranteed                       |
| Performance | Lightweight                  | Heavier due to locking           |
| Use Case    | Flags, read/write primitives | Complex logic, compound actions  |

---

### üßµ 3. **What is `ThreadPoolExecutor` and how does it work?**

**Answer:**

`ThreadPoolExecutor` is a powerful Java class in `java.util.concurrent` that provides a flexible thread pool mechanism to execute tasks concurrently without the overhead of creating new threads each time.

```java
ExecutorService executor = new ThreadPoolExecutor(
    2,                   // corePoolSize
    4,                   // maximumPoolSize
    10, TimeUnit.SECONDS, // keepAliveTime
    new LinkedBlockingQueue<>(100) // task queue
);
executor.submit(() -> {
    System.out.println("Task executed");
});
```

**Parameters Explained:**

* `corePoolSize`: Minimum number of threads always alive.
* `maximumPoolSize`: Max allowed threads.
* `keepAliveTime`: Time for which excess threads remain alive.
* `workQueue`: Queue to hold tasks before execution.

**Benefits:**

* Reuses threads ‚Üí avoids thread creation cost.
* Handles burst loads using queue + max threads.
* Allows custom policies for rejection, monitoring, scaling.

---

### üîÅ 4. **What are the thread pool rejection policies in `ThreadPoolExecutor`?**

**Answer:**

When the task queue is full and all threads are busy, the executor uses a **RejectedExecutionHandler**:

Common policies:

* `AbortPolicy` (default): Throws `RejectedExecutionException`.
* `CallerRunsPolicy`: Runs task in the caller‚Äôs thread.
* `DiscardPolicy`: Silently drops the task.
* `DiscardOldestPolicy`: Drops oldest task in the queue.

```java
new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(10),
    new ThreadPoolExecutor.AbortPolicy()
);
```

---

### üîÑ 5. **How does `ThreadPoolExecutor` differ from `Executors.newFixedThreadPool()`?**

**Answer:**

`Executors.newFixedThreadPool(n)` is a **factory method** that internally uses `ThreadPoolExecutor` with:

* `corePoolSize == maxPoolSize == n`
* An **unbounded queue**, meaning it will not grow beyond `n` threads and may lead to OOM if too many tasks are queued.

Using `ThreadPoolExecutor` directly gives **fine-grained control** over all aspects: pool size, queue size, thread timeouts, custom rejection, etc.

---

### ‚ö†Ô∏è 6. **What problems can arise if `volatile` is used for compound actions like `count++`?**

**Answer:**

`volatile` only ensures **visibility**, not **atomicity**. Compound actions like `count++` (read-modify-write) are **not atomic** and can still lead to race conditions.

```java
volatile int count = 0;

void increment() {
    count++; // Not thread-safe even with volatile!
}
```

Use `synchronized`, `AtomicInteger`, or `LongAdder` instead for atomic updates.

---

### üß† 7. **When should you use `synchronized`, `volatile`, and `ThreadPoolExecutor`?**

| Use Case                                        | Best Tool                        |
| ----------------------------------------------- | -------------------------------- |
| Simple flag check, visibility                   | `volatile`                       |
| Compound operations (read-modify-write)         | `synchronized` or `AtomicXXX`    |
| Running multiple independent tasks concurrently | `ThreadPoolExecutor`             |
| Scaling application under heavy load            | `ThreadPoolExecutor` with tuning |
| Avoiding memory consistency errors              | `synchronized` or `volatile`     |

