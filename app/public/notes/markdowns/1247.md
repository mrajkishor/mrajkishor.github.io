
# 📘 Node.js Coding Essentials for LeetCode

### 🟢 Node Basics → Input & Output (`fs.readFileSync`, `console.log`)

---

## 1. Why Input/Output Matters in DSA with Node.js

* Coding platforms (LeetCode, HackerRank, Codeforces) provide **stdin** and expect results in **stdout**.
* Node.js doesn’t have `Scanner` or `input()` → instead use:

  * `fs.readFileSync(0, "utf-8")` → read stdin buffer.
  * `console.log()` → print to stdout.

⚡ **Why it matters** → Large constraints (10⁵–10⁶ inputs) require **fast I/O**.
`fs.readFileSync(0)` = Node’s equivalent of Java’s `BufferedReader` or Python’s `sys.stdin.read()`.

---

## 2. Basic Input Example

```javascript
// Input: "5\n1 2 3 4 5\n"
const fs = require("fs");
const input = fs.readFileSync(0, "utf-8").trim().split("\n");

const n = parseInt(input[0]);                 // first line
const arr = input[1].split(" ").map(Number);  // second line
console.log(n, arr);
```

✅ Works directly on LeetCode.
⚠️ Running locally → after typing input, press **Ctrl+D (Linux/Mac)** or **Ctrl+Z + Enter (Windows)** to send EOF.

---

## 3. Multiple Test Cases

```javascript
const fs = require("fs");
const data = fs.readFileSync(0, "utf-8").trim().split("\n");

let t = parseInt(data[0]); // number of test cases
let line = 1;

while (t--) {
  const n = parseInt(data[line++]);               // size of array
  const arr = data[line++].split(" ").map(Number);
  console.log("Sum =", arr.reduce((a, b) => a + b, 0));
}
```

👉 This loop pattern is **critical** in CP + LeetCode discussions.

---

## 4. Efficient Output (Avoid TLE)

```javascript
let output = [];
for (let i = 0; i < 5; i++) {
  output.push(i * i);
}
console.log(output.join("\n"));
```

⚡ **Pro Tip** → Multiple `console.log()` calls = slow.
Always buffer results into `output[]` → print once.

---

## 5. Edge Cases in Input

* Extra spaces → use `.trim()` and `.split(/\s+/)`.
* Empty lines → `.filter(Boolean)`.
* Very large integers → use `BigInt`.

```javascript
const arr = data[1].trim().split(/\s+/).map(BigInt);
```

---

## 6. Common Mistakes in Interviews

❌ Forget `.trim()` → results in `NaN`.
❌ Multiple `console.log()` calls → slows output.
❌ Not converting with `map(Number)` → you’re stuck with strings.
❌ Forgetting `BigInt` for large constraints.

---

## 7. LeetCode-Level Best Practices

1. Always start with:

   ```javascript
   const data = fs.readFileSync(0, "utf-8").trim().split("\n");
   ```

2. Buffer results → `output.join("\n")`.

3. Use `.map(Number)` for arrays.

4. Use `BigInt` if constraints exceed `2^53 - 1`.

5. Wrap parsing/logic in a function for reusability.

---

## 8. Example Problem

**Problem**: Square each element in the array.

```javascript
const fs = require("fs");
const data = fs.readFileSync(0, "utf-8").trim().split("\n");

const n = parseInt(data[0]);
const arr = data[1].split(" ").map(Number);

let output = [];
for (let x of arr) output.push(x * x);
console.log(output.join(" "));
```

**Input**

```
5
1 2 3 4 5
```

**Output**

```
1 4 9 16 25
```

---

# 🚀 Node.js LeetCode I/O Snippet Library

👉 Copy-paste ready, covers 99% of problems.

---

### 1. Single Integer

```javascript
const n = parseInt(fs.readFileSync(0, "utf-8").trim());
console.log(n);
```

### 2. Single Test Case (Array)

```javascript
const data = fs.readFileSync(0, "utf-8").trim().split("\n");
const arr = data[1].split(" ").map(Number);
console.log(arr);
```

### 3. Multiple Test Cases

```javascript
let t = parseInt(data[0]);
let line = 1, output = [];

while (t--) {
  const n = parseInt(data[line++]);
  const arr = data[line++].split(" ").map(Number);
  output.push(arr.reduce((a, b) => a + b, 0));
}

console.log(output.join("\n"));
```

### 4. Matrix Input

```javascript
const [n, m] = data[0].split(" ").map(Number);
let matrix = [];
for (let i = 1; i <= n; i++) {
  matrix.push(data[i].split(" ").map(Number));
}
```

### 5. Graph (Adjacency List)

```javascript
const [n, m] = data[0].split(" ").map(Number);
let adj = Array.from({ length: n + 1 }, () => []);
for (let i = 1; i <= m; i++) {
  const [u, v] = data[i].split(" ").map(Number);
  adj[u].push(v);
  adj[v].push(u);
}
```

### 6. Grid / Board

```javascript
const [n, m] = data[0].split(" ").map(Number);
let grid = [];
for (let i = 1; i <= n; i++) {
  grid.push(data[i].trim().split(""));
}
```

### 7. BigInt Handling

```javascript
const [a, b] = data.map(BigInt);
console.log((a + b).toString());
```

### 8. Buffered Output

```javascript
let output = [];
for (let i = 1; i <= 100000; i++) output.push(i);
console.log(output.join("\n"));
```

---

# ✅ Final Takeaways

* `fs.readFileSync(0)` = Node’s **fastest I/O**.
* Always `.trim()` → no `NaN` issues.
* Use `.split(" ").map(Number)` for arrays.
* Batch outputs with `join("\n")`.
* Switch to `BigInt` for large constraints.
* Keep **templates ready** (single input, multiple test cases, matrix, graph, grid).



