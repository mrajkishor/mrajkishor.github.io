

# 📘 Avoiding Memory Leaks in Loops  

---

## 1. Why Memory Leaks Happen in Loops  

In competitive coding with Node.js, you often deal with **large inputs** (`10^5 – 10^6` elements). If you’re not careful, loops can accidentally:  

- **Retain references** to unused arrays/objects → memory not freed.  
- **Re-allocate new arrays** inside loops instead of reusing → high GC overhead.  
- **Use closures/functions inside loops** → captures unnecessary variables.  
- **Console.log inside loops** → builds hidden buffers.  

⚡ Unlike C++/Java, Node.js uses **automatic garbage collection (GC)**. If objects are still referenced (even unintentionally), they won’t be collected → memory leaks.  

---

## 2. Common Patterns that Cause Memory Leaks  

### 🔹 2.1 Re-declaring Large Arrays in Loops
```js
for (let t = 0; t < T; t++) {
  let arr = new Array(1e5).fill(0); // ❌ allocated every iteration
  // process arr
}
```
- Each loop creates a **new 100k array**, previous ones linger until GC kicks in.  

✅ Fix: Reuse memory  
```js
let arr = new Array(1e5);
for (let t = 0; t < T; t++) {
  arr.fill(0); // reset instead of recreate
  // process arr
}
```

---

### 🔹 2.2 Using `.map() / .filter() / .reduce()` Inside Hot Loops
```js
for (let i = 0; i < 1e5; i++) {
  let squared = bigArr.map(x => x * x); // ❌ allocates new array each time
}
```
- Creates **new arrays on every iteration** → memory ballooning.  

✅ Fix: Use in-place loops  
```js
for (let i = 0; i < bigArr.length; i++) {
  bigArr[i] = bigArr[i] * bigArr[i]; // ✅ no new allocation
}
```

---

### 🔹 2.3 Console Logging Inside Loops
```js
for (let i = 0; i < 1e6; i++) {
  console.log(i); // ❌ slows + buffers logs in memory
}
```
- LeetCode/HackerRank buffers `stdout` → memory usage spikes.  

✅ Fix: Collect in array and output once  
```js
let output = [];
for (let i = 0; i < 1e6; i++) output.push(i);
console.log(output.join("\n"));
```

---

### 🔹 2.4 Accidental String Concatenation in Loops
```js
let s = "";
for (let i = 0; i < 1e5; i++) {
  s += i; // ❌ O(n^2) time + memory copies
}
```

✅ Fix: Use array join  
```js
let result = [];
for (let i = 0; i < 1e5; i++) result.push(i);
let s = result.join("");
```

---

### 🔹 2.5 Closures Capturing Loop Variables
```js
let funcs = [];
for (var i = 0; i < 1e5; i++) {
  funcs.push(() => console.log(i)); // ❌ captures single reference to i
}
```

- Keeps references alive → memory retained unnecessarily.  

✅ Fix: Use `let` (block scoped)  
```js
for (let i = 0; i < 1e5; i++) {
  funcs.push(() => console.log(i));
}
```

---

## 3. Techniques to Avoid Memory Leaks  

### ✅ 3.1 Reuse Buffers  
- Allocate large arrays once.  
- Use `.fill()` or overwrite values instead of recreating.  

### ✅ 3.2 Avoid Nested Array Allocations  
- Don’t create temp arrays in every loop iteration.  
- Instead, create once and reset.  

### ✅ 3.3 Control Scope  
- Use `let` / `const` instead of `var` → prevents accidental global leaks.  
- Minimize variables declared outside their needed scope.  

### ✅ 3.4 Batch Output  
- Buffer output in arrays, flush once with `console.log(joinedString)`.  

### ✅ 3.5 Avoid Unnecessary Object Growth  
- Clear objects when done:  
  ```js
  obj = null; // allows GC
  ```
- Use `delete obj.key` cautiously (slows hidden classes). Prefer resetting:  
  ```js
  obj.key = undefined;
  ```

### ✅ 3.6 Profile Memory (if needed)  
- Use `--inspect` with Chrome DevTools to check leaks:  
  ```bash
  node --inspect solution.js < input.txt
  ```

---

## 4. Example: Remove Duplicates from Sorted Array  

LeetCode #26 — **In-place Removal (avoid memory leaks)**  

❌ Wrong (uses `.filter`, allocates new array):  
```js
return nums.filter((x, i) => nums.indexOf(x) === i).length;
```

✅ Correct (mutates in-place, no extra memory):  
```js
let k = 1;
for (let i = 1; i < nums.length; i++) {
  if (nums[i] !== nums[i - 1]) nums[k++] = nums[i];
}
return k;
```

---

## 5. Big-O & Memory Considerations  

| Pattern                  | Time | Space | Mutation? | Safe for Large Inputs? |
|---------------------------|------|-------|-----------|-------------------------|
| `map/filter/reduce` in loop | O(n²) | O(n²) | ❌ | ❌ |
| Re-declaring large arrays | O(n·m) | O(n·m) | ❌ | ❌ |
| `splice` in loops         | O(n²) | O(1) | ✅ | ❌ |
| `slice` for subarrays     | O(k) | O(k) | ❌ | ✅ (if not in hot loop) |
| In-place overwrites       | O(n) | O(1) | ✅ | ✅ |

---

## ✅ In Summary  

- **Mutation vs Non-mutation matters**:  
  - Use **in-place updates** (`for`, overwrite arrays) to prevent leaks.  
  - Avoid `.map/.filter/.reduce` in tight loops with large inputs.  

- **Output carefully**:  
  - Collect in buffer → print once.  

- **Scope carefully**:  
  - Use `let`/`const`, nullify large objects after use.  

- **Re-use memory**:  
  - Allocate large structures once, reset inside loops.  

⚡ This difference is what separates a **just AC solution** from an **optimal solution** in Node.js.  

---



# ⚡ Node.js LeetCode Template (Performance + Memory-Safe)

```javascript
// ===============================
// 📘 Node.js LeetCode Template
// Performance-Safe (Avoids Memory Leaks)
// ===============================

const fs = require("fs");
const data = fs.readFileSync(0, "utf-8").trim().split(/\s+/);

let idx = 0;
const next = () => data[idx++];        // string
const nextInt = () => parseInt(next()); // integer
const nextBig = () => BigInt(next());   // big integer

// ---------- Constants ----------
const MOD = 1000000007n; // For modular arithmetic

// ---------- Example Solver ----------
function solveOneCase() {
  const n = nextInt();

  // ✅ Pre-allocate array once, reuse inside loops
  let arr = new Array(n);
  for (let i = 0; i < n; i++) arr[i] = nextInt();

  // ✅ Avoid filter/map inside loop → do in-place
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += arr[i];
  }

  return sum;
}

// ---------- Main Execution ----------
function main() {
  let t = 1;
  if (idx < data.length) {
    t = nextInt(); // multi-test-case support
  }

  // ✅ Use output buffer → avoids console.log spam
  let results = new Array(t);

  for (let i = 0; i < t; i++) {
    results[i] = solveOneCase();
  }

  // ✅ Print once
  console.log(results.join("\n"));
}

main();
```

---

## 🔑 Why This Template is Interview-Ready

### ✅ Input Handling

* Uses **`fs.readFileSync(0)`** with `.split(/\s+/)` → handles both spaces & newlines efficiently.
* `next()`, `nextInt()`, `nextBig()` → safe token readers.

### ✅ Memory Safety

* **Pre-allocate arrays once** (instead of recreating in inner loops).
* Overwrite values with `arr[i] = ...` instead of `.map()` or `.filter()`.
* No accidental closures inside hot loops.

### ✅ Output Buffer

* Collects results in `results[]`.
* Prints once at the end → avoids **stdout buffering leak**.

### ✅ Performance-Oriented Patterns

* `for` loops (fastest) instead of `.forEach` or `.map` inside critical loops.
* BigInt support included (`nextBig`) for combinatorics.
* Modular arithmetic constant for typical competitive problems.

---

## 🔎 Example Run

Input:

```
2
5
1 2 3 4 5
3
10 20 30
```

Output:

```
15
60
```

---

✅ With this template, you can directly drop your algorithm inside `solveOneCase()` and stay safe from the **most common Node.js pitfalls on LeetCode** (like TLEs from `.map()` or memory leaks from logging inside loops).

