

# üìö Understanding Types of Indexes in MongoDB

Indexes in MongoDB are essential for high-performance data retrieval. As your dataset grows, efficient indexing becomes the backbone of scalable and responsive applications. MongoDB provides various types of indexes, each designed to support different query patterns and data models.

In this post, we‚Äôll explore all major **types of indexes** in MongoDB with real-world use cases and code examples.

---

## üîç What Is an Index in MongoDB?

An **index** is a data structure (typically a B-tree) that stores a small subset of fields in a sorted form to make data retrieval faster. Without indexes, MongoDB must perform a **collection scan**, which is slow and inefficient for large datasets.

---

## üß© 1. **Single Field Index**

### ‚úÖ Description:

* Indexes a single field.
* Most basic and commonly used index.

### üîß Syntax:

```js
db.users.createIndex({ email: 1 })  // ascending
db.users.createIndex({ age: -1 })   // descending
```

### üìå Use Case:

* Searching users by email or filtering by age.
* Supports queries like:

```js
db.users.find({ email: "john@example.com" })
```

---

## üß© 2. **Compound Index**

### ‚úÖ Description:

* Indexes multiple fields in a defined order.
* Useful when queries involve multiple fields.

### üîß Syntax:

```js
db.orders.createIndex({ customerId: 1, orderDate: -1 })
```

### üìå Use Case:

* Searching orders by `customerId` and sorting them by `orderDate`.

> ‚ö†Ô∏è Important: MongoDB can only use the **prefix** of a compound index (i.e., leading fields in order).

---

## üß© 3. **Multikey Index**

### ‚úÖ Description:

* Automatically created when indexing an **array** field.
* Indexes each value in the array separately.

### üîß Syntax:

```js
db.products.createIndex({ tags: 1 })  // tags is an array
```

### üìå Use Case:

* Searching products that contain certain tags.

> ‚ö†Ô∏è Limitation: You cannot create a compound multikey index if more than one field is an array.

---

## üß© 4. **Text Index**

### ‚úÖ Description:

* Supports full-text search on string fields.
* Can be created on one or multiple fields.

### üîß Syntax:

```js
db.blogs.createIndex({ title: "text", content: "text" })
```

### üìå Use Case:

* Searching documents by keyword using:

```js
db.blogs.find({ $text: { $search: "mongodb indexing" } })
```

> ‚ö†Ô∏è Each collection can only have **one** text index.

---

## üß© 5. **Hashed Index**

### ‚úÖ Description:

* Indexes the **hash** of a field‚Äôs value instead of the value itself.
* Mostly used in sharded clusters.

### üîß Syntax:

```js
db.users.createIndex({ userId: "hashed" })
```

### üìå Use Case:

* Enables even distribution of data across shards using a hashed shard key.

> ‚ùóNot suitable for range queries.

---

## üß© 6. **Geospatial Indexes**

### ‚úÖ Description:

* Supports location-based queries using 2D or 2D sphere coordinates.

### üìç a. `2dsphere` Index:

Used for real-world spherical geometry.

```js
db.places.createIndex({ location: "2dsphere" })
```

* Supports queries like:

```js
db.places.find({
  location: {
    $near: {
      $geometry: { type: "Point", coordinates: [ 77.5946, 12.9716 ] },
      $maxDistance: 1000
    }
  }
})
```

### üìç b. `2d` Index:

Used for flat geometry, like game maps.

```js
db.map.createIndex({ location: "2d" })
```

---

## üß© 7. **Wildcard Index (MongoDB 4.2+)**

### ‚úÖ Description:

* Indexes **all fields** or fields matching a pattern.
* Useful for semi-structured documents (dynamic keys).

### üîß Syntax:

```js
db.logs.createIndex({ "$**": 1 }) // wildcard on all fields
```

### üìå Use Case:

* Indexing unpredictable or nested fields in log/event data.

---

## üß© 8. **TTL Index (Time to Live)**

### ‚úÖ Description:

* Automatically deletes documents after a specified number of seconds.
* Ideal for expiring sessions, cache, logs, etc.

### üîß Syntax:

```js
db.sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 })
```

### üìå Use Case:

* Delete documents 1 hour after `createdAt`.

> ‚ö†Ô∏è TTL works only on **date fields**.

---

## ‚öôÔ∏è Recap: When to Use Each Type

| Index Type   | Best For                                |
| ------------ | --------------------------------------- |
| Single Field | Basic lookups and sorts                 |
| Compound     | Multi-field queries and sort operations |
| Multikey     | Array field lookups                     |
| Text         | Full-text search                        |
| Hashed       | Sharding evenly across nodes            |
| Geospatial   | Location-based search                   |
| Wildcard     | Dynamic schema documents                |
| TTL          | Auto-expiry of documents                |

---

## ‚úÖ Best Practices

* Use `explain()` to analyze index usage:

```js
db.collection.find({ field: value }).explain("executionStats")
```

* Avoid creating unnecessary indexes ‚Äî each index slows down **writes**.
* Regularly monitor and remove **unused indexes**.
* Prefer **compound indexes** over multiple single-field indexes if queries combine fields.

---

## üìå Conclusion

Choosing the right index type is a critical skill in MongoDB database optimization. Whether you're dealing with geospatial data, full-text search, or dynamic schemas, MongoDB‚Äôs diverse index options offer flexible solutions for almost every use case. Mastering these index types helps you build faster, more efficient applications that scale smoothly.


