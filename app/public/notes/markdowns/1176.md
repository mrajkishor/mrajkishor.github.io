## **Targeted list of common interview questions** on JavaScript Core Concepts

---


## **==Execution Context & Lexical Environment==**



## **1. What is an Execution Context in JavaScript?**

**Definition**
An **Execution Context (EC)** is the environment in which JavaScript code is evaluated and executed.
It’s like a *container* that holds:

* **Variables** and their values
* **Functions**
* **References** to the outer environment
* The value of `this`

You can think of it as the **"snapshot"** of everything JavaScript needs to run a piece of code at a particular moment.

**Key Points**

* Every time you run JS code, it’s inside *some* execution context.
* Created **before** the code actually runs (creation phase), then used during execution.
* Managed by the **Call Stack**.

---

## **2. What are the different types of Execution Contexts?**

JavaScript has **three main types**:

1. **Global Execution Context (GEC)**

   * Created once when the program starts.
   * Has a global object (`window` in browsers, `global` in Node.js).
   * `this` refers to the global object (in non–strict mode).
   * All global variables/functions are stored here.

2. **Function Execution Context (FEC)**

   * Created whenever a function is called.
   * Has its own scope, variables, and `this` value (depending on call-site).
   * Can access outer variables via **scope chain**.

3. **Eval Execution Context** *(rarely used)*

   * Created when code inside `eval()` is executed.
   * Generally discouraged for performance and security reasons.

---

## **3. What happens during the creation phase of an Execution Context?**

Execution Context creation happens in **two phases**:

**(A) Creation Phase (a.k.a. Memory Allocation)**

* **Global / Function Object Setup**

  * A *Variable Environment* is created (holding `var` declarations and function declarations).
  * A *Lexical Environment* is created (holding `let` and `const` declarations).
* **Hoisting** happens here:

  * Function declarations are stored in memory fully.
  * `var` variables are initialized to `undefined`.
  * `let` and `const` are placed in **Temporal Dead Zone (TDZ)** (accessible only after initialization).
* `this` is set (global object in non–strict mode, `undefined` in strict mode).

**(B) Execution Phase**

* Code runs line-by-line.
* Variables are assigned actual values.
* Function calls create new execution contexts and push them to the call stack.

---

## **4. What is a Lexical Environment and how is it different from a Scope?**

**Lexical Environment**
A Lexical Environment is a structure that stores:

* The **environment record** (variables, constants, functions)
* A reference to the **outer Lexical Environment** (for scope chain)

It’s created **whenever a new scope is created**:

* Global scope
* Function scope
* Block scope (for `let` / `const`)

**Difference from Scope**

* **Scope** → The set of variables accessible in a given part of the code. (Conceptual)
* **Lexical Environment** → The *actual runtime structure* in memory that holds variable bindings.

Think of scope as the **rule**, and lexical environment as the **data structure implementing it**.

---

## **5. How does JavaScript find variables using the Lexical Environment?**

JavaScript uses the **Scope Chain**:

1. Starts looking for the variable in the **current environment record**.
2. If not found, moves up to the **outer lexical environment**.
3. Repeats until:

   * Found
   * Or reaches the **Global Lexical Environment** (if not found, `ReferenceError` is thrown).

Example:

```js
let x = 10;
function outer() {
  let y = 20;
  function inner() {
    console.log(x, y); // found via scope chain
  }
  inner();
}
outer();
```

Here:

* `x` → Found in **global** lexical environment.
* `y` → Found in `outer()`’s lexical environment.

---

## **6. Can a Lexical Environment exist without a Variable Environment?**

Not exactly — but **Variable Environment** is actually a **subset** of Lexical Environment.

* In ES5 terminology, **Variable Environment** referred to `var` bindings, while **Lexical Environment** handled `let`/`const`.
* In modern JS, **Lexical Environment** includes both, so there’s no execution context without *some* variable environment.
* You can have an *empty* environment record (e.g., an empty block `{}`), but it still exists as part of a lexical environment.

---

## **7. What is the difference between a Global Execution Context and a Functional Execution Context?**

| Feature             | Global Execution Context (GEC)                                                     | Functional Execution Context (FEC)                 |
| ------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------------- |
| **Created**         | When JS starts running                                                             | Every time a function is invoked                   |
| **Variables**       | Global variables and functions                                                     | Function’s parameters, local vars, inner functions |
| **this** binding    | Global object (`window` / `global`) in non-strict mode, `undefined` in strict mode | Depends on how the function is called              |
| **Outer reference** | `null` (no outer environment)                                                      | Parent’s lexical environment                       |
| **Lifetime**        | Until program ends                                                                 | Until function finishes execution                  |

---

#### **Tricky Q\&A set with code examples** for Execution Context & Lexical Environment




### **Q1: Hoisting & TDZ Trap**

```js
console.log(a);  
console.log(b);  
var a = 1;
let b = 2;
```

**Answer:**

* `a` → `undefined` (hoisted and initialized to `undefined` in creation phase)
* `b` → **ReferenceError** (hoisted but in Temporal Dead Zone until initialization)

**Execution Context Reasoning:**

1. **Creation Phase**:

   * `var a` → Memory allocated, initialized to `undefined`.
   * `let b` → Memory allocated, **not** initialized (TDZ).
2. **Execution Phase**:

   * `console.log(a)` → `undefined`
   * `console.log(b)` → TDZ → `ReferenceError`

---

### **Q2: Function Declaration vs Expression in Hoisting**

```js
foo();  
bar();  

function foo() { console.log("foo called"); }

var bar = function() { console.log("bar called"); }
```

**Answer:**

* `"foo called"`
* **TypeError** (because `bar` is `undefined` at call time)

**Reasoning:**

* Function declarations are fully hoisted.
* Function expressions are treated like variables → `bar` is hoisted as `undefined`.

---

### **Q3: Nested Lexical Environment Variable Lookup**

```js
let x = 10;
function outer() {
  let y = 20;
  function inner() {
    let z = 30;
    console.log(x + y + z);
  }
  inner();
}
outer();
```

**Answer:**

* Output: `60`

**Reasoning:**

* `inner`’s lexical environment → `z`
* Outer’s lexical environment → `y`
* Global lexical environment → `x`
* Scope chain resolves variables outward.

---

### **Q4: Variable Shadowing in Lexical Environment**

```js
let a = 5;
function test() {
  let a = 10;
  console.log(a);
}
test();
console.log(a);
```

**Answer:**

* `10`
* `5`

**Reasoning:**

* `a` inside `test` shadows outer `a` (different lexical environment records).

---

### **Q5: Lexical Environment & Closures**

```js
function counter() {
  let count = 0;
  return function() {
    count++;
    return count;
  }
}
const c1 = counter();
console.log(c1());
console.log(c1());
```

**Answer:**

* `1`
* `2`

**Reasoning:**

* The returned function closes over `count` in its lexical environment.
* Even after `counter()` finishes, that lexical environment is preserved.

---

### **Q6: Function Inside Block Scope**

```js
if (true) {
  function sayHi() { console.log("Hi"); }
}
sayHi();
```

**Answer:**

* **Browser (non-strict)** → `"Hi"`
* **Strict mode / Node.js** → `ReferenceError`

**Reasoning:**

* In strict mode, function declarations inside blocks are block-scoped.
* In sloppy mode, browsers historically hoist them to the enclosing scope.

---

### **Q7: Global vs Function Execution Context**

```js
var x = 1;
function f() {
  console.log(x);
  var x = 2;
}
f();
```

**Answer:**

* `undefined`

**Reasoning:**

* In FEC for `f`, `var x` is hoisted and initialized to `undefined`.
* Logs local `x`, not global.

---

### **Q8: Scope Chain Resolution**

```js
let a = 1;
function first() {
  let b = 2;
  function second() {
    let c = 3;
    console.log(a, b, c);
  }
  second();
}
first();
```

**Answer:**

* `1 2 3`

**Reasoning:**

* `c` → `second`'s env
* `b` → `first`'s env
* `a` → global env

---

### **Q9: The Closure Loop Problem**

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);
}
```

**Answer:**

* `3 3 3`

**Reasoning:**

* `var` is function-scoped, all callbacks share the same lexical environment → final `i` value is `3`.

[See more...](/notes#/contents/full-stack-developer-course/frontend-development/final-contents/frontend-engineering/JavaScript%20&%20TypeScript%20Mastery/javascript-deep-dive/core-concepts/Appendix/the-closure-loop-problem-in-depth)

---

### **Q10: Fixing the Closure Loop Problem**

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0);
}
```

**Answer:**

* `0 1 2`

**Reasoning:**

* `let` creates a new lexical environment for each iteration.


[See more...](/notes#/contents/full-stack-developer-course/frontend-development/final-contents/frontend-engineering/JavaScript%20&%20TypeScript%20Mastery/javascript-deep-dive/core-concepts/Appendix/the-closure-loop-problem-in-depth)


---

## **==Call Stack & Memory Heap==**

8. **What is the call stack and how does it work in JavaScript?**
9. **What is the memory heap used for?**
10. **How do call stack and memory heap interact during function execution?**
11. **What causes a stack overflow in JavaScript?**
12. **How can memory leaks happen in JavaScript, and how do you prevent them?**

---

## **Hoisting Mechanics**

13. **What is hoisting in JavaScript?**
14. **How are `var`, `let`, and `const` hoisted differently?**
15. **Are function declarations hoisted?**
16. **Are arrow functions hoisted?**
17. **What is the Temporal Dead Zone (TDZ) and why does it exist?**
18. **How does hoisting work for class declarations?**

---

## **Scope Chain & Variable Environment**

19. **What is the scope chain in JavaScript?**
20. **How does the scope chain help in variable resolution?**
21. **What is the difference between scope chain and prototype chain?**
22. **How is the variable environment different from the lexical environment?**
23. **What happens if a variable is not found in the scope chain?**

---

## **this Binding Rules**

24. **What does `this` refer to in JavaScript?**
25. **Explain the default binding rule for `this`.**
26. **Explain the implicit binding rule for `this`.**
27. **How does explicit binding work using `call`, `apply`, and `bind`?**
28. **How does `this` behave inside arrow functions?**
29. **What happens when you lose `this` in a callback function?**
30. **How does `this` behave in event listeners vs arrow functions inside event listeners?**
31. **What happens to `this` in strict mode vs non-strict mode?**

---

## **Primitive vs Reference Types**

32. **What are primitive types in JavaScript?**
33. **What are reference types?**
34. **How are primitive values stored in memory vs reference values?**
35. **What happens when you copy a primitive value vs an object reference?**

---

## **Deep vs Shallow Copy**

36. **What is the difference between a shallow copy and a deep copy?**
37. **How do you create a deep copy in JavaScript?**
38. **Why can `JSON.parse(JSON.stringify())` fail for deep cloning?**
39. **What are the pros and cons of using structuredClone()?**

---

## **Equality in JS**

40. **What is the difference between `==` and `===`?**
41. **When would `Object.is()` be preferable over `===`?**
42. **Why is `NaN === NaN` false, and how does `Object.is(NaN, NaN)` behave?**
43. **Why is `0 === -0` true but `Object.is(0, -0)` false?**

---

## **Based on Core Concepts in General**

44. **Explain the difference between lexical scope and dynamic scope.**
45. **What is a closure and how does it relate to the lexical environment?**
46. **Can `this` and lexical scope affect each other?**
47. **What is variable shadowing and how does it occur?**
48. **What is the difference between execution context and call stack?**

