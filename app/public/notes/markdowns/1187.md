
> Heavily tested in GATE.


# **Chapter 7 – Deadlocks**

---

## **7.1 System Model**

* **Resources** are things a process needs: CPU cycles, memory, I/O devices, files, semaphores, etc.
* Each resource type can have multiple **instances**.
* **Process states in terms of resources:**

  * **Request** → Process asks for a resource.
  * **Use** → Process holds the resource and performs operations.
  * **Release** → Process gives up the resource after use.

---

## **7.2 Deadlock Definition**

A **deadlock** occurs when a set of processes are **permanently blocked** because each process is holding at least one resource and waiting for another resource held by another process in the set.

**Example (Two Processes & Two Resources):**

* P1 holds R1, requests R2.
* P2 holds R2, requests R1.
* Neither can proceed — *deadlock*.

---

## **7.3 Conditions for Deadlock (Coffman’s Conditions)**

For deadlock to occur, all **four** must hold **simultaneously**:

1. **Mutual Exclusion** – At least one resource is non-shareable.
2. **Hold and Wait** – A process holding resources can request new ones.
3. **No Preemption** – Resources cannot be forcibly taken; must be released voluntarily.
4. **Circular Wait** – A set of processes {P1, P2, …, Pn} exists where each Pi waits for a resource held by P(i+1), and Pn waits for P1.

**GATE Tip:** If you break **any one** condition, deadlock cannot occur.

---

## **7.4 Resource-Allocation Graph (RAG)**

* **Nodes**:

  * Process → Circle (P1, P2, …)
  * Resource type → Rectangle with dots for instances.
* **Edges**:

  * Request edge (P → R)
  * Assignment edge (R → P)
* **Cycle in RAG**:

  * Single instance per resource → Cycle means deadlock.
  * Multiple instances → Cycle may or may not mean deadlock.

---

## **7.5 Handling Deadlocks**

Three main strategies:

1. **Deadlock Prevention** – Ensure one Coffman condition never holds.
2. **Deadlock Avoidance** – Decide resource allocation dynamically so the system never enters unsafe states.
3. **Deadlock Detection & Recovery** – Allow deadlock, detect it, and recover.

---

### **7.6 Deadlock Prevention**

**Break the conditions**:

* **Mutual Exclusion** → Make resources sharable (not always possible).
* **Hold and Wait** → Force processes to request all resources at once.
* **No Preemption** → If request denied, release held resources.
* **Circular Wait** → Impose a strict ordering of resource types.

---

### **7.7 Deadlock Avoidance**

**Banker’s Algorithm** (by Dijkstra):

* Works if processes declare **maximum resource needs** in advance.
* Uses the **Safe State** concept:

  * A state where there is at least one sequence in which all processes can finish without deadlock.
* **Steps**:

  1. Check if resources can be allocated without entering an unsafe state.
  2. Allocate only if safe.

**GATE Tip:** Banker’s Algorithm problems are frequent in numerical sections.

---

### **7.8 Deadlock Detection**

* **Single instance per resource** → Use Wait-for Graph (simplified RAG without resource nodes).
* **Multiple instances** → Use detection algorithm similar to Banker’s, but instead of prevention, check for cycles and unfinishable processes.

---

### **7.9 Deadlock Recovery**

* **Process termination**:

  * Abort all processes in deadlock.
  * Abort one at a time until deadlock is gone.
* **Resource preemption**:

  * Take resources from other processes (carefully to avoid starvation).

---

## **7.10 GATE Exam Notes**

* Expect **theory**: Coffman’s conditions, prevention vs avoidance.
* Expect **numericals**: Banker’s Algorithm, safe sequence finding.
* Know **graph-based** detection for single-instance vs multi-instance.
* Understand **starvation vs deadlock** differences.


