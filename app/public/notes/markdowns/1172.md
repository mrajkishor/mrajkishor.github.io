# **Explicit Binding (`call`, `apply`, `bind`)**

---

## **1. What Is Explicit Binding?**

**Explicit binding** is when you tell JavaScript **exactly** what you want `this` to be during a function call, using the **Function.prototype.call**, **Function.prototype.apply**, or **Function.prototype.bind** methods.

Unlike **implicit binding** (where `this` comes from the object before the dot), **explicit binding** lets you override the call-site default and set `this` directly.

---

## **2. Why It Exists**

JavaScript functions are **first-class values** — they can be passed around, detached from objects, and still be called.
When a function is called **without an owner object**, it normally falls back to **default binding** (`global` or `undefined`).
Explicit binding gives you a way to **force** the function to use a specific `this` value regardless of call site.

---

## **3. The Three APIs**

| Method                           | Calls immediately? | Pass arguments as                  | Returns                      |
| -------------------------------- | ------------------ | ---------------------------------- | ---------------------------- |
| `call(thisArg, arg1, arg2, ...)` | ✅ Yes              | Comma-separated list               | Return value of the function |
| `apply(thisArg, [argsArray])`    | ✅ Yes              | Single array or array-like         | Return value of the function |
| `bind(thisArg, arg1, arg2, ...)` | ❌ No               | Comma-separated list (pre-applied) | **New bound function**       |

---

## **4. `call()`**

Calls the function **immediately**, binding `this` to the first argument (`thisArg`).

```js
function greet(msg) {
  return `${msg}, my name is ${this.name}`;
}
const user = { name: 'Ava' };

greet.call(user, 'Hi'); // "Hi, my name is Ava"
```

**Key points:**

* Arguments after the first are passed individually.
* If `thisArg` is `null`/`undefined`:

  * Non-strict mode → global object
  * Strict mode → remains `null`/`undefined`.

---

## **5. `apply()`**

Almost identical to `call()`, but takes arguments as an array (or array-like object).

```js
greet.apply(user, ['Hello']); // "Hello, my name is Ava"
```

**When useful:**

* When you already have arguments in an array form (e.g., spread from user input).
* Historical note: before ES6’s spread syntax (`fn(...arr)`), `apply` was the only way to pass arrays as individual arguments.

---

## **6. `bind()`**

Creates a **new function** with `this` permanently set to `thisArg`.

```js
const boundGreet = greet.bind(user, 'Hey');
boundGreet(); // "Hey, my name is Ava"
```

**Key points:**

* Does not invoke immediately.
* Useful for callbacks and event handlers where `this` would otherwise be lost.
* Partial application: arguments given to `bind` are “pre-filled” for later calls.

---

## **7. Explicit Binding Precedence**

In the **`this` binding precedence hierarchy**:

```
new binding > explicit binding (call/apply/bind) > implicit binding > default binding
```

* **`new` wins over `bind`:**

```js
function Foo(name) { this.name = name; }
const BoundFoo = Foo.bind({ name: 'obj' });
const a = new BoundFoo('newName');
console.log(a.name); // 'newName'
```

When used with `new`, the bound `thisArg` is ignored; the newly created object is used.

---

## **8. Borrowing Methods**

Explicit binding lets you borrow methods from one object to use on another:

```js
const person = { fullName() { return `${this.first} ${this.last}`; } };
const other = { first: 'Ada', last: 'Lovelace' };

person.fullName.call(other); // "Ada Lovelace"
```

---

## **9. Working with Array-Like Objects**

DOM collections, `arguments`, and strings can be manipulated like arrays using borrowed methods:

```js
function logArgs() {
  Array.prototype.forEach.call(arguments, arg => console.log(arg));
}
logArgs('a', 'b', 'c');
```

---

## **10. `apply` for Math Functions**

Before spread syntax:

```js
const nums = [5, 6, 2, 8];
Math.max.apply(null, nums); // 8
```

Now: `Math.max(...nums)`.

---

## **11. Pitfalls & Gotchas**

### **Losing binding with `bind`**

If you store a bound function, the binding is permanent — you can’t rebind it:

```js
function show() { return this.x; }
const obj1 = { x: 1 }, obj2 = { x: 2 };
const bound = show.bind(obj1);
console.log(bound.call(obj2)); // 1 (bind is permanent)
```

### **Binding primitives**

When you bind a primitive (`string`, `number`, `boolean`) as `thisArg`, JS will wrap it in its object form (`String`, `Number`, `Boolean`) in non-strict mode.

### **Performance**

Creating bound functions in hot code paths can cause unnecessary allocations — cache them if reused.

---

## **12. Common Interview Questions**

### **Q1: Difference between call, apply, bind**

```js
function f(a, b) { return [this.x, a, b]; }
const obj = { x: 10 };

f.call(obj, 1, 2);   // [10, 1, 2]
f.apply(obj, [1, 2]); // [10, 1, 2]
const bound = f.bind(obj, 1);
bound(2);            // [10, 1, 2]
```

### **Q2: Method extraction fix**

```js
const user = { name: 'Ava', hi() { return this.name; } };
setTimeout(user.hi, 0); // undefined (default binding)
setTimeout(user.hi.bind(user), 0); // 'Ava'
```

### **Q3: Borrowing array methods for `arguments`**

```js
function sum() {
  return Array.prototype.reduce.call(arguments, (a, b) => a + b, 0);
}
sum(1, 2, 3); // 6
```

---

## **13. Best Practices**

* Use `bind` in constructors (React class components) for event handlers to avoid losing `this`.
* Use `call`/`apply` for:

  * Function borrowing.
  * Manipulating array-like objects.
  * Performance-sensitive code where binding per-call is acceptable.
* Avoid rebinding bound functions; remember that `bind` is **permanent**.
* Prefer ES6+ spread (`fn(...arr)`) instead of `apply` when dealing with arrays.

---


# **`call()` vs `apply()` vs `bind()` — Comparison & Usage Guide**

---

## **1. Quick Reference Table**

| Feature                        | `call()`                             | `apply()`                       | `bind()`                                       |
| ------------------------------ | ------------------------------------ | ------------------------------- | ---------------------------------------------- |
| **Executes Immediately?**      | ✅ Yes                                | ✅ Yes                           | ❌ No                                           |
| **Arguments Format**           | Comma-separated list                 | Single array / array-like       | Comma-separated (partially applied)            |
| **Return Value**               | Function’s return value              | Function’s return value         | **New bound function**                         |
| **Mutates Original Function?** | ❌ No                                 | ❌ No                            | ❌ No                                           |
| **Use Case**                   | Pass individual args, borrow methods | Pass args already in array form | Preserve `this` for later, partial application |

---

## **2. Memory & Performance Considerations**

| Factor                         | `call()`                        | `apply()`                       | `bind()`                                                   |
| ------------------------------ | ------------------------------- | ------------------------------- | ---------------------------------------------------------- |
| **Function Creation Overhead** | Low — no extra function created | Low — no extra function created | Medium — creates new function object                       |
| **Best in Hot Loops?**         | ✅ Yes                           | ✅ Yes                           | ⚠️ Cache bound function to avoid repeated allocations      |
| **Garbage Collection Impact**  | Minimal                         | Minimal                         | Bound functions remain in memory until all references drop |

---

## **3. Time Complexity**

All three have **O(1)** time complexity for the binding step, but actual execution time depends on:

* **Function logic** (most important factor)
* Argument preparation (array destructuring for `apply`)
* Allocation cost (`bind` creates a new function object)

---

## **4. When to Use Each (Practical Guide)**

| Scenario                                                                    | Best Choice             | Why                                  |
| --------------------------------------------------------------------------- | ----------------------- | ------------------------------------ |
| You have arguments individually                                             | `call()`                | Direct and fast                      |
| You have arguments in an array-like form                                    | `apply()`               | Avoids manual spread                 |
| You want to borrow methods for arrays/strings                               | `call()` or `apply()`   | Depends on data format               |
| You need to pass a function to an async/event handler without losing `this` | `bind()`                | Keeps `this` locked                  |
| You want partial function application                                       | `bind()`                | Can pre-fill arguments               |
| Before ES6, to spread arrays into functions                                 | `apply()`               | Used for `Math.max.apply(null, arr)` |
| Modern JS with spread syntax                                                | `call()` with `...args` | Avoids `apply` overhead              |

---

## **5. Interview Tip — Mental Model**

Think of them like **"How and When the function runs"**:

* **`call`** → *Call now* with `this` = `X` and args: 1, 2, 3
* **`apply`** → *Call now* with `this` = `X` and args in array `[1, 2, 3]`
* **`bind`** → *Create a new function* with `this` = `X` and (optional) pre-filled args

---

## **6. Example Scenarios**

### **Borrowing Methods**

```js
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
Array.prototype.join.call(arrayLike, '-'); // 'a-b'
```

### **Math Operations on Arrays**

```js
const nums = [1, 5, 3];
Math.max.apply(null, nums); // 5
// Modern equivalent:
Math.max(...nums);
```

### **Fixing Lost `this` in Callbacks**

```js
const obj = { name: 'Ava', greet() { console.log(this.name); } };
setTimeout(obj.greet.bind(obj), 0); // Ava
```

### **Partial Application**

```js
function multiply(a, b) { return a * b; }
const double = multiply.bind(null, 2);
double(5); // 10
```

---

## **7. Common Pitfalls**

* `bind` creates a **permanent binding** — you cannot override `this` later.
* Passing `null` or `undefined` as `thisArg` defaults to **global object** in non-strict mode, **remains null/undefined** in strict mode.
* Overusing `bind` in render loops (e.g., in React) can cause unnecessary re-renders due to new function references.

---


Here’s a **Call stack timeline diagram** for **`call()` vs `apply()` vs `bind()`** that clearly shows **execution vs preparation phase** differences and how `this` is set.



## **Call Stack Timeline: `call()` vs `apply()` vs `bind()`**

```
PHASE 1: CODE DEFINITION (Load Time)
------------------------------------
Function is stored in memory, not executed yet.
this = undefined (in strict) or global (non-strict) until call site.

   function greet(g1, g2) {
       console.log(g1, g2, 'from', this.name);
   }

   const person = { name: 'Alice' };

(No function execution happens here — just definition)

---------------------------------------------------------
PHASE 2: EXECUTION (Call Site) — call() & apply()
---------------------------------------------------------

T0: 
Stack: [ main() ]
Action: `greet.call(person, 'Hi', 'there');`
   - Creates execution context for greet()
   - Sets this = person
   - Passes args individually
   - Executes immediately
Stack: [ greet() ]
Logs: "Hi there from Alice"
Stack: [ main() ]

T1: 
Stack: [ main() ]
Action: `greet.apply(person, ['Hi', 'there']);`
   - Same as call(), but takes args array
   - Executes immediately
Stack: [ greet() ]
Logs: "Hi there from Alice"
Stack: [ main() ]

---------------------------------------------------------
PHASE 3: EXECUTION (Call Site) — bind()
---------------------------------------------------------

T2:
Stack: [ main() ]
Action: `const boundGreet = greet.bind(person, 'Hi');`
   - DOES NOT execute greet()
   - Creates **new function object** with this locked to `person`
   - Pre-fills first arg with 'Hi'
   - Returns bound function reference
Stack: [ main() ]

T3:
Stack: [ main() ]
Action: `boundGreet('there');`
   - Creates execution context for greet()
   - this = person (locked by bind)
   - g1 = 'Hi' (from bind), g2 = 'there'
   - Executes
Stack: [ greet() ]
Logs: "Hi there from Alice"
Stack: [ main() ]
```

---

### **Key Visualization of `this` Binding Flow**

```
[ Function Definition Phase ]
    |
    +--> this = undefined (strict) / global (non-strict)
    |
[ call(obj, ...) ] → Immediately sets this = obj → executes now
[ apply(obj, [...]) ] → Immediately sets this = obj → executes now
[ bind(obj, ...) ] → Creates new fn with this locked to obj → executes later
```

---

### **Memory & Timing Differences**

| Method  | Execution Timing       | Creates New Function? | `this` Locked? | Arg Handling             |
| ------- | ---------------------- | --------------------- | -------------- | ------------------------ |
| `call`  | Immediate              | No                    | At call site   | Comma list               |
| `apply` | Immediate              | No                    | At call site   | Array                    |
| `bind`  | Delayed (when invoked) | ✅ Yes                 | At bind time   | Comma list (can prefill) |

---

✅ **Interview Tip**
When an interviewer asks *"What happens if you pass an object method to `setTimeout`?"* —
this diagram helps you explain:

* `setTimeout(obj.method, 0)` → loses `this` → default binding
* Fix: `setTimeout(obj.method.bind(obj), 0)` or arrow function wrapper




