

## **Spring for GraphQL Overview**

---

### 🔷 What is Spring for GraphQL?

**Spring for GraphQL** is a modern integration between **Spring Boot** and **GraphQL Java**, enabling developers to build **declarative, flexible, type-safe APIs** using GraphQL within the Spring ecosystem.

Released as a **first-class Spring project in 2022**, it combines:

* The reactive/non-blocking power of **Spring WebFlux**
* The familiar programming model of **Spring MVC**
* With the expressive query capabilities of **GraphQL**

It supersedes `graphql-spring-boot-starter` (from graphql-java-kickstart) and is now the **official Spring-supported** way to build GraphQL APIs.

---

### 🔷 Core Concepts

| Concept                              | Description                                                                |
| ------------------------------------ | -------------------------------------------------------------------------- |
| **GraphQL Schema**                   | Strongly-typed contract (`.graphqls` files) for querying and mutating data |
| **Resolvers**                        | Java methods that handle fields (`@SchemaMapping`, `@QueryMapping`, etc.)  |
| **DataFetcher**                      | Low-level mechanism to map GraphQL fields to data                          |
| **Query/Mutation/Subscription**      | Types of operations supported by GraphQL                                   |
| **ExecutionInput / ExecutionResult** | Represents a GraphQL request/response under the hood                       |

---

### 🔷 Key Features of Spring for GraphQL

✅ Annotation-based GraphQL handler model
✅ Schema-first development using `.graphqls`
✅ DataLoader support for batching + caching
✅ WebSocket-based subscriptions (with RSocket)
✅ Works with both **Spring MVC** and **WebFlux**
✅ Reactive types support (Mono, Flux)
✅ Error handling and validation integration
✅ Integration with Spring Security and Observability (Micrometer)

---

### 🔷 Architecture

```
┌──────────────┐
│  HTTP/RSocket│
└──────┬───────┘
       ↓
┌────────────────────────┐
│ GraphQL HTTP Handler   │ ← Spring Web layer
└────────┬───────────────┘
         ↓
┌──────────────────────────────┐
│ Execution Graph (GraphQL Java)│
└────────┬─────────────────────┘
         ↓
┌────────────────────────────┐
│ Resolvers / DataFetchers   │
└────────┬───────────────────┘
         ↓
┌────────────────────────────┐
│ Application / DB / Service │
└────────────────────────────┘
```

---

### ✅ Getting Started

#### `pom.xml` (Spring Boot + GraphQL Starter)

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-graphql</artifactId>
</dependency>
<dependency>
  <groupId>com.graphql-java</groupId>
  <artifactId>graphql-java-tools</artifactId>
</dependency>
```

#### `application.yml`

```yaml
spring:
  graphql:
    schema:
      locations: classpath:graphql/
    graphiql:
      enabled: true  # optional, use with Altair/GraphiQL playground
```

---

### ✅ Example: Query, Mutation, Schema

#### `schema.graphqls`

```graphql
type Query {
  bookById(id: ID!): Book
}

type Mutation {
  addBook(input: BookInput): Book
}

type Book {
  id: ID!
  title: String
  author: String
}

input BookInput {
  title: String!
  author: String!
}
```

---

### ✅ Java Code: Query + Mutation + Resolver

```java
@Component
public class BookResolver {

    private final BookService bookService;

    public BookResolver(BookService bookService) {
        this.bookService = bookService;
    }

    @QueryMapping
    public Book bookById(@Argument String id) {
        return bookService.getBookById(id);
    }

    @MutationMapping
    public Book addBook(@Argument BookInput input) {
        return bookService.save(input);
    }

    @SchemaMapping(typeName = "Book", field = "author")
    public String resolveAuthor(Book book) {
        return book.getAuthor().toUpperCase();
    }
}
```

#### `BookInput.java`

```java
@Data
public class BookInput {
    private String title;
    private String author;
}
```

---

### ✅ Reactive Support (Spring WebFlux)

```java
@QueryMapping
public Mono<Book> bookByIdReactive(@Argument String id) {
    return bookRepository.findById(id); // returns Mono<Book>
}
```

Supports `Mono<T>` and `Flux<T>` in both queries and mutations.

---

### 🔷 Subscriptions (Streaming via WebSocket/RSocket)

```graphql
type Subscription {
  bookAdded: Book
}
```

```java
@SubscriptionMapping
public Flux<Book> bookAdded() {
    return publisher.getNewBooksFlux(); // emits books as they're added
}
```

---

### 🔷 Integration Highlights

#### ✅ With Spring Security

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().anyRequest().authenticated()
            .and().httpBasic(); // or JWT bearer
    }
}
```

Then use `@PreAuthorize("hasRole('ADMIN')")` on GraphQL methods.

---

### 🔷 Advanced Features

| Feature            | Usage                                                            |
| ------------------ | ---------------------------------------------------------------- |
| **DataLoader**     | Batch fetch related objects (avoids N+1)                         |
| **Custom Scalars** | Add `DateTime`, `UUID`, etc. using `RuntimeWiringConfigurer`     |
| **Error Handling** | `@ControllerAdvice`, `GraphQLErrorHandler`, or custom formatters |
| **Validation**     | Use `javax.validation` annotations on input arguments            |
| **Observability**  | Integrates with Micrometer, tracing tools like Zipkin            |

---

### 🔷 Testing GraphQL APIs

```java
@SpringBootTest
@AutoConfigureWebTestClient
public class BookQueryTest {

    @Autowired
    WebTestClient client;

    @Test
    void testGetBook() {
        client.post().uri("/graphql")
              .bodyValue("{\"query\":\"{ bookById(id: \\\"1\\\"){title} }\"}")
              .exchange()
              .expectStatus().isOk()
              .expectBody().jsonPath("$.data.bookById.title").isEqualTo("1984");
    }
}
```

---

### 🔷 Tools and UI Playground

* [Altair GraphQL Client](https://altair.sirmuel.design/)
* [GraphiQL](https://github.com/graphql/graphiql)
* [Insomnia / Postman](for GraphQL testing)

---

### 🔷 Real-world Use Cases

| Use Case               | Example                                     |
| ---------------------- | ------------------------------------------- |
| E-Commerce Product API | Flexible querying of product details by UI  |
| Analytics Dashboard    | Dynamic querying of metrics, dimensions     |
| CMS Headless API       | Fetch blogs, authors, tags in a single call |
| Mobile Backend         | Reduces overfetching and underfetching      |
| Fintech Account APIs   | Query multiple asset types in one request   |

---

### 🔷 Common Interview Questions (Enterprise)

1. What are the benefits of GraphQL over REST?
2. How does Spring for GraphQL resolve schema fields?
3. How does batching work with `DataLoader`?
4. Can you explain the difference between `@QueryMapping` and `@SchemaMapping`?
5. How are subscriptions handled in Spring for GraphQL?
6. How do you secure GraphQL APIs using Spring Security?
7. What are N+1 problems and how does GraphQL mitigate them?

---

# To Do: 

### Case Studies

### STAR

### Code Samples
