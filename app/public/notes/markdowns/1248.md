
# Node Basics / Primitive Types & Objects

---

## 1. Why Node.js for Competitive Programming?

Most platforms like **LeetCode, HackerRank, Codeforces, AtCoder** allow Node.js as a submission language.
However, unlike **Java/Python**, Node has no built-in `input()` or `Scanner`. You must explicitly handle **stdin/stdout** with performance in mind:

* **Fast Input Handling**:

  ```js
  const fs = require("fs");
  const data = fs.readFileSync(0, "utf-8").trim().split("\n");
  ```

  * `0` â†’ file descriptor for stdin.
  * Splitting by `\n` â†’ separates test cases.

* **Fast Output Handling**:

  ```js
  console.log(result);
  ```

  Avoid concatenated logs in loops â†’ buffer results and print once.

This makes Node.js very **close to C++ in performance**, provided I/O is optimized.

---

## 2. Node.js Basics (Essentials for DSA)

### ðŸ”¹ Modules & Execution

* Node executes files with the **V8 engine**.
* `require("fs")` â†’ CommonJS import for file system.
* For LeetCode-style problems, almost always:

  ```js
  const fs = require("fs");
  ```

### ðŸ”¹ Input Template (LeetCode-Ready)

```js
const fs = require("fs");
const data = fs.readFileSync(0, "utf-8").trim().split("\n");

let t = parseInt(data[0]); // number of test cases
let line = 1;

while (t--) {
  const n = parseInt(data[line++]);
  const arr = data[line++].split(" ").map(Number);
  // process arr
}
```

### ðŸ”¹ Output Template

```js
let output = [];
for (let i = 0; i < results.length; i++) {
  output.push(results[i]);
}
console.log(output.join("\n"));
```

---

## 3. Primitive Types in Node.js

In JavaScript/Node.js, **all values are either primitive or objects**.
Primitives are **immutable** and stored directly (not as references).

| Primitive Type | Example                                                               | Notes                                                                         |
| -------------- | --------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| `Number`       | `42`, `3.14`, `NaN`, `Infinity`                                       | 64-bit floating point. Integers safe only in **â€“(2^53 â€“ 1) â€¦ 2^53 â€“ 1**.      |
| `BigInt`       | `9007199254740991n`                                                   | Arbitrary large integers (not mixed with `Number`). Useful for combinatorics. |
| `String`       | `"leetcode"`, `'abc'`, `` `xyz` ``                                    | Immutable sequences of UTF-16 code units.                                     |
| `Boolean`      | `true`, `false`                                                       | Strict equality (`===`) avoids coercion.                                      |
| `Undefined`    | declared but not assigned.                                            |                                                                               |
| `Null`         | intentional empty value (`typeof null === "object"` quirk).           |                                                                               |
| `Symbol`       | `Symbol("id")`                                                        | Unique identifiers; rarely used in DSA.                                       |
| `BigInt`       | introduced in ES2020; very useful for factorials, modular arithmetic. |                                                                               |

**Key Points for LeetCode**:

* Use `BigInt` for factorial/large power problems.
* `Number.MAX_SAFE_INTEGER` = `2^53 - 1` â‰ˆ 9e15.
* Prefer `Math.floor(x)` over `parseInt(x)` for performance.

---

## 4. Objects in Node.js

Objects are **reference types** (mutable).
They are widely used in DSA as **hash maps, sets, or custom data structures**.

### ðŸ”¹ Object Basics

```js
let obj = { a: 1, b: 2 };
obj.c = 3;       // add property
delete obj.a;    // remove property
```

### ðŸ”¹ Key Data Structures

* **Object** â†’ `{}` : general key-value mapping.
* **Map** â†’ preserves insertion order, allows non-string keys.
* **Set** â†’ stores unique values efficiently.

Example: Counting Frequencies

```js
let freq = {};
for (let x of arr) {
  freq[x] = (freq[x] || 0) + 1;
}
```

Example: Using Map

```js
let freq = new Map();
for (let x of arr) {
  freq.set(x, (freq.get(x) || 0) + 1);
}
```

### ðŸ”¹ Choosing Correct DS

* **Object** â†’ fast, but keys auto-converted to strings.
* **Map** â†’ safe for mixed key types.
* **Set** â†’ uniqueness checks (`O(1)` avg).

---

## 5. Essential Node Tricks for LeetCode

1. **Fast String to Number Conversion**

   ```js
   +str   // faster than parseInt()
   ```

2. **Efficient Array Traversal**

   ```js
   for (let i = 0; i < n; i++) {}   // fastest
   for (const x of arr) {}          // clean
   arr.forEach(...)                 // slower
   ```

3. **BigInt Modular Arithmetic**

   ```js
   const MOD = 1000000007n;
   let res = (a * b) % MOD;
   ```

4. **Avoid `console.log` Inside Loops**
   Buffer results in an array, print once.

5. **Use Typed Arrays for Large Data** (rare in LeetCode, but interview-level optimization).

   ```js
   let arr = new Int32Array(n);
   ```

---

## 6. Interview-Level Pitfalls & Optimizations

* **Pitfall: Floating-Point Precision**

  ```js
  0.1 + 0.2 === 0.3  // false
  ```

  Use `BigInt` or integer scaling in problems requiring exact arithmetic.

* **Pitfall: Deep Copy vs Shallow Copy**

  ```js
  let a = [1,2,3];
  let b = a;        // reference copy
  let c = [...a];   // shallow copy
  ```

* **Pitfall: Recursion Depth**

  * Default recursion limit in Node â‰ˆ 10^4.
  * For DFS problems, prefer iterative stack-based solutions.

* **Optimization: Precompute**

  * Use `Array.from({length: n}, (_, i) => i+1)` for fast initialization.
  * Use `Map` and `Set` over arrays for membership checks (`O(1)` vs `O(n)`).

---

âœ… **In Summary**

* **Node.js in LeetCode** is mainly about mastering `fs` I/O, avoiding performance bottlenecks, and leveraging JS primitives/objects correctly.
* For **Interview prep**, focus on:

  * I/O speed (`fs.readFileSync`, output buffering).
  * Choosing the right data structure (`Object` vs `Map` vs `Set`).
  * Handling large numbers (`BigInt`, modular arithmetic).
  * Avoiding precision & recursion pitfalls.

--- 

## Node.js LeetCode template | Reusable boilerplate code snippets | Don't re-invent the wheel, re-use it.  


# Node.js LeetCode Template

```javascript
// ===============================
// ðŸ“˜ Node.js LeetCode Template
// ===============================

// Fast input reading
const fs = require("fs");
const data = fs.readFileSync(0, "utf-8").trim().split(/\s+/);

let idx = 0;
const next = () => data[idx++];       // returns string
const nextInt = () => parseInt(next());
const nextBig = () => BigInt(next());

// ---------- Common Constants ----------
const MOD = 1000000007n;  // Change if problem defines different MOD

// ---------- Example Function ----------
function solveOneCase() {
  const n = nextInt();
  let arr = [];
  for (let i = 0; i < n; i++) {
    arr.push(nextInt());
  }

  // Example: sum of array
  let sum = 0;
  for (let x of arr) sum += x;

  return sum;  // return single answer for this case
}

// ---------- Main Execution ----------
function main() {
  let t = 1; // default for problems with single test case
  if (data.length > 0) t = nextInt();

  let results = [];
  for (let i = 0; i < t; i++) {
    results.push(solveOneCase());
  }

  // Print all results at once
  console.log(results.join("\n"));
}

main();
```

---

## ðŸ”‘ How It Works

* **Input Handling**

  * `fs.readFileSync(0, "utf-8")` â†’ reads entire stdin.
  * `.split(/\s+/)` â†’ splits by whitespace (handles both spaces and newlines).
  * `next()`, `nextInt()`, `nextBig()` â†’ utility functions for parsing tokens.

* **Output Buffering**

  * Store answers in `results[]`.
  * Print all at once with `join("\n")` â†’ faster than logging each line.

* **BigInt Support**

  * Use `nextBig()` when handling factorials, combinatorics, or huge integers.
  * Modular arithmetic example:

    ```js
    let res = (a * b) % MOD;
    ```

---

## âœ… Usage Examples

### Example 1: Array Sum

Input:

```
2
5
1 2 3 4 5
3
10 20 30
```

Solution inside `solveOneCase()`:

```js
let sum = arr.reduce((a, b) => a + b, 0);
return sum;
```

Output:

```
15
60
```

---

### Example 2: Modular Exponentiation (BigInt)

```js
function modPow(base, exp, mod) {
  base = BigInt(base) % mod;
  exp = BigInt(exp);
  let result = 1n;
  while (exp > 0) {
    if (exp & 1n) result = (result * base) % mod;
    base = (base * base) % mod;
    exp >>= 1n;
  }
  return result;
}

function solveOneCase() {
  const a = nextBig();
  const b = nextBig();
  return modPow(a, b, MOD).toString(); // convert BigInt â†’ string for output
}
```

---

âš¡ With this template, you can focus only on the **algorithm logic**, not on I/O or boilerplate.



