

# **Chapter 23: Query Processing and Optimization**

---

## **23.1 Steps in Query Processing**

When a SQL query is issued, the DBMS doesn‚Äôt execute it directly. Instead, it undergoes multiple steps to transform high-level SQL into efficient low-level operations on data.

The main steps are:

1. **Parsing and Translation**

   * SQL query is parsed by the DBMS into a **parse tree**.
   * Syntactic errors (e.g., missing keywords) and semantic errors (e.g., wrong column names) are checked.
   * The parse tree is converted into an **internal representation**, usually a **relational algebra expression**.

2. **Optimization**

   * The relational algebra expression is not unique; there are many logically equivalent forms.
   * The **query optimizer** searches for the most efficient execution plan using **algebraic transformations** and **cost-based analysis**.
   * For example:

     ```sql
     SELECT name FROM student WHERE age > 20 AND course = 'CS';
     ```

     may be optimized into a sequence of **selections + projection** with different orders.

3. **Code Generation**

   * The optimized relational algebra plan is translated into **low-level query execution plan** (QEP), often shown as a **query tree**.
   * Each node in the tree represents a DB operator (scan, join, sort, etc.).

4. **Execution**

   * The query executor runs the QEP, calling appropriate **access methods** (sequential scan, index scan, hashing, etc.).
   * Results are returned to the user.

üîë **Takeaway:** Query processing converts **high-level SQL** ‚Üí **relational algebra** ‚Üí **query execution plan** ‚Üí **results**.

---

## **23.2 Measures of Query Cost**

Not all equivalent query plans perform equally well. The **query optimizer** uses cost models to compare different execution plans.

### 1) Main Factors Affecting Cost

* **Disk I/O cost** (dominant factor in large databases):

  * Number of block reads/writes.
* **CPU cost**:

  * Time spent in comparisons, sorting, hashing.
* **Communication cost**:

  * Important in distributed DBs (network latency).
* **Memory usage**:

  * Intermediate results may or may not fit in RAM.

### 2) Cost Estimation

* Each operator (join, sort, selection) has a known formula to estimate cost based on:

  * **Number of tuples (n)**
  * **Number of blocks (b)**
  * **Index availability**
  * **Selectivity factor (fraction of tuples satisfying a condition)**

Example:

* A **linear scan** of a relation with 1,000 blocks ‚Üí cost ‚âà 1,000 block reads.
* An **indexed search** might cost only **log‚ÇÇ(n)** index lookups + few block accesses.

üîë **Takeaway:** The optimizer usually picks the plan with **lowest estimated disk I/O** (unless CPU/network dominates).

---

## **23.3 Selection Operation**

The **selection (œÉ)** retrieves tuples satisfying a condition.
How efficiently this runs depends on **indexes, sorting, and data distribution**.

### 1) Methods of Evaluation

1. **Linear search (brute force):**

   * Scan entire table block by block.
   * Cost = **b** block accesses (if relation has b blocks).
   * Used if no indexes are available.

2. **Binary search:**

   * If relation is sorted on the attribute.
   * Cost = **log‚ÇÇ(b) + (#blocks with matching tuples)**.

3. **Primary index or clustering index:**

   * Direct access to matching tuples.
   * Very efficient (retrieves contiguous blocks).

4. **Secondary index:**

   * If attribute is not the primary key but has an index.
   * Cost depends on index depth + number of matching entries.

5. **Composite selection:**

   * For multiple conditions (AND/OR), optimizer may:

     * Use **intersection of indexes** (AND).
     * Use **union of indexes** (OR).
     * Choose the most selective predicate first.

### 2) Example

```sql
SELECT * FROM Employee WHERE dept = 'HR';
```

* If `dept` has a clustering index ‚Üí fast access.
* If no index ‚Üí full table scan.

üîë **Takeaway:** Optimizers always prefer **indexed access** over full scans when possible.

---

## **23.4 Sorting**

Sorting is required in operations like:

* `ORDER BY`, `GROUP BY`
* Duplicate elimination (`DISTINCT`)
* Set operations (`UNION`, `INTERSECT`)
* Merge-sort joins

### 1) Methods of Sorting

1. **Internal sorting (fits in RAM):**

   * If relation fits entirely in memory, use **quicksort/heap sort**.
   * Time complexity: **O(n log n)**.

2. **External merge sort (large data):**

   * Works in two phases:

     1. **Run generation phase:**

        * Break relation into chunks that fit in memory.
        * Sort each chunk and write back to disk ‚Üí called ‚Äúruns.‚Äù
     2. **Merge phase:**

        * Merge runs using multi-way merge until sorted relation is obtained.

   * Example: With 3 buffers in memory, you can merge 2 runs at a time.

### 2) Cost of External Sort

* Let **b = number of blocks**, **M = memory blocks available**.
* Pass 0: read b blocks, sort chunks of size M ‚Üí write back (‚âà 2b I/Os).
* Subsequent passes: each pass reads + writes all blocks.
* Total cost ‚âà **O(b logM(b))** block I/Os.

üîë **Takeaway:** Sorting is **expensive**; optimizers avoid it unless strictly necessary.

---

# ‚úÖ Quick Comparison Table

| Step                    | Purpose                                     | Key Concern                     |
| ----------------------- | ------------------------------------------- | ------------------------------- |
| Query Processing (23.1) | SQL ‚Üí Relational Algebra ‚Üí Plan ‚Üí Execution | Transform SQL to efficient plan |
| Query Cost (23.2)       | Estimate plan efficiency                    | Disk I/O, CPU, memory           |
| Selection (23.3)        | Filter tuples                               | Indexes vs scans                |
| Sorting (23.4)          | Order/group results                         | Expensive, external merge sort  |

