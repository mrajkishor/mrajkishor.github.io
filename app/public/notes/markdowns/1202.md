

# 📘 Chapter 14 – Normalization

---

## 1. Introduction

* **Normalization** = Process of **organizing data** in a database to reduce **redundancy** and improve **data integrity**.
* Proposed by **E.F. Codd** (the father of the relational model).
* Normalization is applied during **logical database design**.

**Why Normalize?**

* Eliminates anomalies:

  * **Insertion anomaly** – can’t add data because other data is missing.
  * **Deletion anomaly** – deleting a record causes unintended data loss.
  * **Update anomaly** – inconsistent data when updating in multiple places.

---

## 2. Functional Dependencies (FDs)

* **Definition**: Attribute **Y is functionally dependent on X (X → Y)** if, for each value of X, there is exactly one value of Y.
* Example: `RollNo → Name, Branch`
* FDs are the **foundation** of normalization.

**Types of FD:**

* **Full FD**: Y depends fully on X, not on a subset.
* **Partial FD**: Y depends on part of a composite key.
* **Transitive FD**: If `X → Y` and `Y → Z`, then `X → Z`.

---

## 3. Normal Forms

### 3.1 First Normal Form (1NF)

* Table should contain only **atomic values** (no repeating groups/multivalued attributes).
* Example ❌: A student table with multiple phone numbers in one field.
* Fix ✅: Separate into multiple rows or a new relation.

---

### 3.2 Second Normal Form (2NF)

* Must be in **1NF**.
* No **partial dependency** (no attribute should depend on part of a composite key).
* Example:

  * Student(CourseID, RollNo, Name, CourseName)
  * `CourseName` depends only on `CourseID`.
  * Fix ✅: Split into `Course(CourseID, CourseName)` and `Student(CourseID, RollNo, Name)`.

---

### 3.3 Third Normal Form (3NF)

* Must be in **2NF**.
* No **transitive dependency** (non-key attributes should not depend on other non-key attributes).
* Example:

  * Employee(EmpID, DeptID, DeptName)
  * `DeptName` depends on `DeptID`, not directly on `EmpID`.
  * Fix ✅: Separate into Employee(EmpID, DeptID) and Department(DeptID, DeptName).

---

### 3.4 Boyce–Codd Normal Form (BCNF)

* Stronger form of 3NF.
* For every FD `X → Y`, **X must be a superkey**.
* Removes remaining anomalies that 3NF may still allow.
* Example:

  * Relation: (Course, Teacher, Time)
  * If one teacher can only teach one course, but a course may have many teachers → anomaly exists.
  * Splitting ensures correctness.

---

### 3.5 Fourth Normal Form (4NF)

* Must be in **BCNF**.
* No **multivalued dependencies** (MVDs).
* Example:

  * Person(Name, Language, Hobby)
  * If Language and Hobby are independent but stored together → redundancy.
  * Fix ✅: Split into PersonLanguage(Name, Language) and PersonHobby(Name, Hobby).

---

### 3.6 Fifth Normal Form (5NF) / PJ/NF

* Must be in **4NF**.
* Removes **join dependency** anomalies.
* Rarely applied in practice.

---

### 3.7 Domain-Key Normal Form (DKNF)

* A relation is in DKNF if **all constraints** are logical consequences of **domain** and **key constraints**.
* Considered the ultimate normal form but impractical.

---

## 4. Denormalization

* In practice, sometimes databases are **denormalized** for performance (joins become costly).
* Trade-off: **Speed vs Integrity**.

---

## 5. Normalization in GATE & Interviews

* **Key Questions Asked**:

  * Define **FD, partial, transitive dependency**.
  * Convert a relation into **1NF → 2NF → 3NF → BCNF**.
  * Difference between **3NF and BCNF**.
  * When to use **denormalization**.
* **Common traps**:

  * Remember: Every **BCNF relation is in 3NF**, but not vice versa.
  * 4NF handles **multivalued dependencies**, not functional dependencies.

---

## 🔑 Key Takeaways

1. Normalization removes **redundancy** and **anomalies** using **FDs**.
2. Normal Forms:

   * **1NF** – atomic values.
   * **2NF** – remove partial dependency.
   * **3NF** – remove transitive dependency.
   * **BCNF** – every determinant is a superkey.
   * **4NF** – no multivalued dependencies.
   * **5NF** – no join dependencies.
3. Higher forms (4NF, 5NF, DKNF) are theoretical but less common in practice.
4. GATE & interviews mostly focus on **FDs, 1NF–BCNF, and anomalies**.

---

✅ That completes **Chapter 14 (Normalization)**.

----

# Examples:

Let’s go through **worked examples of Normalization step by step (up to BCNF)** – exactly the kind of thing that appears in **GATE & interview questions**.



# 📘 Worked Examples on Normalization

---

## **Example 1: Student Database**

We are given a relation:

**R(StudentID, CourseID, Instructor, InstructorPhone)**

And the following Functional Dependencies (FDs):

1. `StudentID, CourseID → Instructor`
2. `Instructor → InstructorPhone`

---

### **Step 1: Check 1NF**

* All attributes are atomic (no multi-valued fields like `{Phone1, Phone2}` inside one column).
* ✅ Relation is in **1NF**.

---

### **Step 2: Check 2NF**

* Candidate Key: `(StudentID, CourseID)` (together they uniquely identify a row).
* Check for **Partial Dependencies**:

  * None of the non-key attributes depend on only part of `(StudentID, CourseID)`.
* ✅ Already in **2NF**.

---

### **Step 3: Check 3NF**

* Rule: No **Transitive Dependency**.
* Here:

  * `(StudentID, CourseID) → Instructor`
  * and `Instructor → InstructorPhone`
  * So: `(StudentID, CourseID) → InstructorPhone` (transitive dependency ❌).

**Fix**: Decompose →

1. `StudentCourse(StudentID, CourseID, Instructor)`
2. `InstructorInfo(Instructor, InstructorPhone)`

* ✅ Now in **3NF**.

---

### **Step 4: Check BCNF**

* For **Instructor → InstructorPhone**:

  * Left side `Instructor` is not a superkey.
  * ❌ Not BCNF.

**Fix**: Same decomposition we did above.

* `Instructor` becomes a key in `InstructorInfo`.
* ✅ Now in **BCNF**.

---

## **Example 2: Employee-Department Relation**

**R(EmpID, EmpName, DeptID, DeptName, DeptLocation)**

FDs:

1. `EmpID → EmpName, DeptID`
2. `DeptID → DeptName, DeptLocation`

---

### **Step 1: Candidate Key**

* From FD1 and FD2: `EmpID → everything`.
* So **Candidate Key = EmpID**.

---

### **Step 2: Check 1NF**

* All attributes are atomic. ✅

---

### **Step 3: Check 2NF**

* Key is **single attribute (EmpID)** → No partial dependency possible.
* ✅ Already in **2NF**.

---

### **Step 4: Check 3NF**

* Check for Transitive Dependency:

  * `EmpID → DeptID`
  * `DeptID → DeptName, DeptLocation`
  * So: `EmpID → DeptName, DeptLocation` (transitive ❌).

**Fix**: Decompose →

1. `Employee(EmpID, EmpName, DeptID)`
2. `Department(DeptID, DeptName, DeptLocation)`

* ✅ Now in **3NF**.

---

### **Step 5: Check BCNF**

* In `Department`:

  * FD: `DeptID → DeptName, DeptLocation`
  * Left side `DeptID` is a key ✅.
* In `Employee`:

  * FD: `EmpID → EmpName, DeptID`
  * Left side `EmpID` is a key ✅.
* ✅ Both relations are in **BCNF**.

---

## **Example 3: Trick Question (3NF but not BCNF)**

**R(Course, Instructor, Room)**

FDs:

1. `(Course, Instructor) → Room`
2. `Room → Instructor`

---

### **Step 1: Candidate Key**

* `(Course, Instructor)` is a key.

---

### **Step 2: 3NF Check**

* `Room → Instructor`:

  * Here Instructor is **prime attribute** (part of a candidate key).
  > 👉 The “transitive dependency” here is only apparent, because it collapses into a trivial dependency (Course, Instructor) → Instructor. That’s why it doesn’t break 3NF.
  ![alt text](image-163.png)
  * So ✅ it satisfies 3NF.

---

### **Step 3: BCNF Check**

* BCNF condition: 
    > A relation is in BCNF if for every FD X → Y:
    X is a superkey.

* For FD `Room → Instructor`:

  * `Room` is not a superkey. ❌
* Not in BCNF.

**Fix**: Decompose →

1. `R1(Room, Instructor)`
2. `R2(Course, Room)`

Now both are in BCNF.

---

# 🔑 Takeaways for GATE & Interviews

1. Always check **candidate keys** first.
2. Apply normalization step-by-step (1NF → 2NF → 3NF → BCNF).
3. **3NF vs BCNF**:

   * 3NF allows dependencies where the RHS is a **prime attribute**.
   * BCNF is stricter: **every FD must have a superkey on LHS**.
4. GATE often asks:

   * *“Given a relation with FDs, decompose it into BCNF.”*
   * *“Which normal form does this relation belong to?”*

---

# ==Extras (Imp) :== 

<ins>About Super key, Candidate key, Primary key and foreign key.


# 🔑 Keys in DBMS

## 1. **Super Key**

* **Definition**: Any set of attributes that **uniquely identifies a row** in a relation.
* A super key may contain extra/unnecessary attributes.
* Every **candidate key** is a super key, but not vice versa.

✅ Example:
Relation: `Student(RollNo, Name, Email, Phone)`

* `{RollNo}` → uniquely identifies a student.
* `{RollNo, Email}` → also uniquely identifies, but extra attribute included → still a super key.
* `{RollNo, Name, Phone}` → also a super key (though redundant).

---

## 2. **Candidate Key**

* **Definition**: A **minimal super key** (no attribute can be removed while still uniquely identifying rows).
* There can be **multiple candidate keys**.
* DBMS chooses one of them as **primary key**.

✅ Example:
Relation: `Employee(EmpID, AadhaarNo, PAN, Name)`

* Super keys = `{EmpID}`, `{AadhaarNo}`, `{PAN}`, `{EmpID, Name}`, etc.
* Candidate keys = `{EmpID}`, `{AadhaarNo}`, `{PAN}` (all minimal, no extra attributes).

---

## 3. **Primary Key**

* **Definition**: One **chosen candidate key** to uniquely identify records.
* Properties:

  * Cannot be NULL.
  * Must be unique.
  * At most one **primary key** per table.

✅ Example:
`Student(RollNo, Email, Phone, Name)`

* Candidate keys: `{RollNo}`, `{Email}`.
* If DBMS chooses `RollNo` → that becomes the **Primary Key**.

---

## 4. **Foreign Key**

* **Definition**: An attribute in one table that refers to the **primary key in another table**.
* Maintains **referential integrity** between two tables.

✅ Example:
Table: `Department(DeptID, DeptName)`

* `DeptID` is the **Primary Key** here.

Table: `Employee(EmpID, Name, DeptID)`

* `DeptID` in Employee is a **Foreign Key**, referencing `DeptID` in Department.

---

# 📊 Quick Comparison Table

| Key Type          | Definition                                           | Uniqueness                | Nullable?                              | Example                             |
| ----------------- | ---------------------------------------------------- | ------------------------- | -------------------------------------- | ----------------------------------- |
| **Super Key**     | Any set of attributes that uniquely identifies a row | Yes                       | Can include NULL (unless chosen as PK) | {RollNo, Email}                     |
| **Candidate Key** | Minimal super key (no redundancy)                    | Yes                       | No NULLs allowed                       | {RollNo}, {Email}                   |
| **Primary Key**   | Chosen candidate key                                 | Yes                       | ❌ Not allowed                          | RollNo                              |
| **Foreign Key**   | Refers to primary key in another table               | Not required (can repeat) | Can be NULL (unless constrained)       | Employee.DeptID → Department.DeptID |

---

# 📝 Interview-Style Tips

* **Super key** = “at least enough”
* **Candidate key** = “exactly enough”
* **Primary key** = “chosen one”
* **Foreign key** = “reference to another table’s chosen one”


