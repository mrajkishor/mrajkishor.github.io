
# **Fibonacci Numbers**

## **Concept**

The Fibonacci sequence is a famous mathematical series where each term is the sum of the two preceding ones.

**Definition**:

$$
F(n) = F(n-1) + F(n-2), \quad n > 1
$$

with base cases:

$$
F(0) = 0, \quad F(1) = 1
$$

So the sequence is:
`0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …`

---

## **Approaches**

### **1. Recursive (Naive)**

* Directly follow the definition:
  `F(n) = F(n-1) + F(n-2)`
* **Example**:
  `F(5) = F(4) + F(3) = (F(3) + F(2)) + (F(2) + F(1)) …`
* **Time Complexity**: `O(2^n)` (exponential, many repeated calls).
* **Space Complexity**: `O(n)` (stack depth).
* **Drawback**: Very slow for large `n`.

---

### **2. Recursion with Memoization (Top-Down DP)**

* Use a **cache** to store computed Fibonacci values.
* Avoids recomputation.
* **Time Complexity**: `O(n)`
* **Space Complexity**: `O(n)` (recursion + cache).

---

### **3. Iterative Dynamic Programming (Bottom-Up DP)**

* Compute values from 0 → n using an array.
* **Steps**:

  * `dp[0] = 0`, `dp[1] = 1`
  * For i from 2 → n: `dp[i] = dp[i-1] + dp[i-2]`
* **Time Complexity**: `O(n)`
* **Space Complexity**: `O(n)`.

---

### **4. Space-Optimized Iterative**

* Instead of storing the whole array, just keep the last two values.
* **Steps**:

  * Initialize `a = 0, b = 1`
  * Loop n times: `c = a + b`, update `a = b`, `b = c`
* **Time Complexity**: `O(n)`
* **Space Complexity**: `O(1)` (best practical approach).

---

### **5. Matrix Exponentiation**

* Fibonacci can be represented using matrix multiplication:

  $$
  \begin{bmatrix} F(n+1) \\ F(n) \end{bmatrix} =
  \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^n
  \cdot
  \begin{bmatrix} 1 \\ 0 \end{bmatrix}
  $$
* Compute power of the matrix using **fast exponentiation** (divide & conquer).
* **Time Complexity**: `O(log n)`
* **Space Complexity**: `O(1)`.
* **Useful for very large n**.

---

### **6. Binet’s Formula (Closed-Form)**

* Derived using the **golden ratio (φ)**:

  $$
  F(n) = \frac{\phi^n - (1 - \phi)^n}{\sqrt{5}}
  $$

  where $\phi = \frac{1 + \sqrt{5}}{2}$.
* **Time Complexity**: `O(1)`
* **Drawback**: Floating-point errors for large `n`. Works reliably for small/medium `n`.

---

### **7. Using Generators (Streaming Fibonacci)**

* Generate Fibonacci sequence **lazily** on demand.
* **Useful in functional programming / infinite sequences**.
* Time complexity per number: `O(1)`.

---

## **Comparison of Approaches**

| Approach                  | Time     | Space | Notes                   |
| ------------------------- | -------- | ----- | ----------------------- |
| Recursive (Naive)         | O(2^n)   | O(n)  | Worst, educational only |
| Recursion + Memoization   | O(n)     | O(n)  | Easy fix for recursion  |
| Iterative DP              | O(n)     | O(n)  | Simple, intuitive       |
| Space-Optimized Iterative | O(n)     | O(1)  | **Best practical**      |
| Matrix Exponentiation     | O(log n) | O(1)  | Fast for large n        |
| Binet’s Formula           | O(1)     | O(1)  | Floating-point issues   |
| Generators / Streams      | O(1)/num | O(1)  | On-demand generation    |

---

## **Applications of Fibonacci**

* Algorithms (e.g., Fibonacci search, heap)
* Dynamic programming examples
* Nature patterns (flower petals, shells)
* Financial market analysis
* Coding interviews (common test problem)

---

⚡ In real-world coding interviews:

* **Small n** → Iterative (O(n)).
* **Large n (like n > 10^9)** → Matrix exponentiation or Binet’s formula.
* **When memory is tight** → Space-optimized iterative.

---

## Code



# ✅ Java Implementations

### **1. Naive Recursive**

```java
public class Fibonacci {
    // Naive recursive approach
    public static int fibRecursive(int n) {
        if (n <= 1) return n;
        return fibRecursive(n - 1) + fibRecursive(n - 2);
    }

    public static void main(String[] args) {
        System.out.println(fibRecursive(6)); // 8
    }
}
```

---

### **2. Recursion with Memoization**

```java
import java.util.HashMap;

public class Fibonacci {
    static HashMap<Integer, Integer> memo = new HashMap<>();

    public static int fibMemo(int n) {
        if (n <= 1) return n;
        if (memo.containsKey(n)) return memo.get(n);

        int result = fibMemo(n - 1) + fibMemo(n - 2);
        memo.put(n, result);
        return result;
    }

    public static void main(String[] args) {
        System.out.println(fibMemo(40)); // 102334155
    }
}
```

---

### **3. Iterative DP**

```java
public class Fibonacci {
    public static int fibDP(int n) {
        if (n <= 1) return n;

        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }

    public static void main(String[] args) {
        System.out.println(fibDP(10)); // 55
    }
}
```

---

### **4. Space Optimized Iterative**

```java
public class Fibonacci {
    public static int fibOptimized(int n) {
        if (n <= 1) return n;

        int a = 0, b = 1;
        for (int i = 2; i <= n; i++) {
            int c = a + b;
            a = b;
            b = c;
        }
        return b;
    }

    public static void main(String[] args) {
        System.out.println(fibOptimized(10)); // 55
    }
}
```

---

### **5. Matrix Exponentiation**

```java
public class Fibonacci {
    static int[][] multiply(int[][] A, int[][] B) {
        int[][] C = new int[2][2];
        C[0][0] = A[0][0]*B[0][0] + A[0][1]*B[1][0];
        C[0][1] = A[0][0]*B[0][1] + A[0][1]*B[1][1];
        C[1][0] = A[1][0]*B[0][0] + A[1][1]*B[1][0];
        C[1][1] = A[1][0]*B[0][1] + A[1][1]*B[1][1];
        return C;
    }

    static int[][] power(int[][] M, int n) {
        if (n == 1) return M;
        if (n % 2 == 0) {
            int[][] half = power(M, n/2);
            return multiply(half, half);
        } else {
            return multiply(M, power(M, n-1));
        }
    }

    public static int fibMatrix(int n) {
        if (n == 0) return 0;
        int[][] F = {{1,1},{1,0}};
        int[][] Fn = power(F, n-1);
        return Fn[0][0];
    }

    public static void main(String[] args) {
        System.out.println(fibMatrix(10)); // 55
    }
}
```

---

### **6. Binet’s Formula**

```java
public class Fibonacci {
    public static int fibBinet(int n) {
        double phi = (1 + Math.sqrt(5)) / 2;
        return (int)Math.round(Math.pow(phi, n) / Math.sqrt(5));
    }

    public static void main(String[] args) {
        System.out.println(fibBinet(10)); // 55
    }
}
```

---

# ✅ TypeScript Implementations

### **1. Naive Recursive**

```typescript
function fibRecursive(n: number): number {
  if (n <= 1) return n;
  return fibRecursive(n - 1) + fibRecursive(n - 2);
}

console.log(fibRecursive(6)); // 8
```

---

### **2. Memoization**

```typescript
function fibMemo(n: number, memo: Record<number, number> = {}): number {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];

  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
  return memo[n];
}

console.log(fibMemo(40)); // 102334155
```

---

### **3. Iterative DP**

```typescript
function fibDP(n: number): number {
  if (n <= 1) return n;

  const dp: number[] = new Array(n + 1);
  dp[0] = 0;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}

console.log(fibDP(10)); // 55
```

---

### **4. Space Optimized Iterative**

```typescript
function fibOptimized(n: number): number {
  if (n <= 1) return n;

  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

console.log(fibOptimized(10)); // 55
```

---

### **5. Matrix Exponentiation**

```typescript
function multiply(A: number[][], B: number[][]): number[][] {
  return [
    [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],
    [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]
  ];
}

function power(M: number[][], n: number): number[][] {
  if (n === 1) return M;
  if (n % 2 === 0) {
    const half = power(M, Math.floor(n / 2));
    return multiply(half, half);
  } else {
    return multiply(M, power(M, n - 1));
  }
}

function fibMatrix(n: number): number {
  if (n === 0) return 0;
  const F = [[1,1],[1,0]];
  const Fn = power(F, n - 1);
  return Fn[0][0];
}

console.log(fibMatrix(10)); // 55
```

---

### **6. Binet’s Formula**

```typescript
function fibBinet(n: number): number {
  const phi = (1 + Math.sqrt(5)) / 2;
  return Math.round(Math.pow(phi, n) / Math.sqrt(5));
}

console.log(fibBinet(10)); // 55
```

---

⚡ **Key Takeaways**:

* For **small n** → Recursive/Memoized is fine.
* For **medium n** (~10^5) → Iterative/Optimized iterative is best.
* For **very large n** (~10^9) → Matrix Exponentiation wins.
* Binet’s formula is elegant but may fail for very large n due to floating-point precision.

