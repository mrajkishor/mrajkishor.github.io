
Here’s a focused, interview-ready set of **Symbol** questions with crisp, practical answers and tiny code nuggets.

---

## 1) What is a `Symbol` in JavaScript?

**Answer:**
`Symbol` is a **primitive type** whose values are **unique and immutable**. You typically use symbols as **object property keys** to avoid name collisions.

```js
const s1 = Symbol('id');
const s2 = Symbol('id');
s1 === s2; // false (descriptions don't affect identity)
```

---

## 2) How do you create Symbols? What’s the description for?

**Answer:**
Use `Symbol(description?)`. The description is **only a debug label**—it doesn’t impact equality.

```js
const token = Symbol('auth-token');
token.description; // "auth-token"
String(token);     // "Symbol(auth-token)"
```

---

## 3) What’s the difference between `Symbol()` and `Symbol.for()`?

**Answer:**

* `Symbol()` creates a **fresh, unique** symbol every time.
* `Symbol.for(key)` looks up a symbol in the **global registry** by `key`; if absent, it **creates** and registers one. Reusing the same key returns the **same** symbol.

```js
Symbol('x') === Symbol('x');     // false
Symbol.for('x') === Symbol.for('x'); // true (same global symbol)
```

Use `Symbol.for` when you need to **share** a symbol across modules in the same runtime.

---

## 4) How do you retrieve the registry key of a global symbol?

**Answer:**
Use `Symbol.keyFor(sym)`. It returns the string key for **registry** symbols, or `undefined` for non-registry symbols.

```js
const g = Symbol.for('glob');
Symbol.keyFor(g);            // "glob"
Symbol.keyFor(Symbol('x'));  // undefined
```

---

## 5) Why use symbols as object keys?

**Answer:**
To create properties that **won’t collide** with other keys and are **not accidentally enumerated** by common loops.

```js
const ID = Symbol('id');
const user = { name: 'Ava', [ID]: 123 };

for (const k in user) console.log(k);  // logs only "name"
Object.keys(user);                      // ["name"]
user[ID];                               // 123
```

Symbols help you attach metadata without risking clashes with existing string keys.

---

## 6) Are symbol properties truly private?

**Answer:**
No—just **harder to stumble upon**. They’re skipped by `for…in`, `Object.keys`, and `JSON.stringify`, but they’re still discoverable:

```js
Object.getOwnPropertySymbols(user); // [Symbol(id)]
Reflect.ownKeys(user);              // ["name", Symbol(id)]
```

For true encapsulation, use **class private fields** (`#x`) or closures.

---

## 7) Do common reflection and serialization APIs see symbols?

**Answer:**

* **Ignored:** `for…in`, `Object.keys`, `JSON.stringify`
* **Visible:** `Object.getOwnPropertySymbols`, `Reflect.ownKeys`, `Object.getOwnPropertyDescriptors`
* **Copied:** `Object.assign` copies **enumerable** own properties, including symbol keys.

---

## 8) Can Symbols be implicitly converted to strings or numbers?

**Answer:**
No—implicit conversion throws. Convert **explicitly** with `String(sym)` or `sym.description`. Boolean coercion is allowed.

```js
const s = Symbol('x');
'' + s;     // TypeError
String(s);  // "Symbol(x)"
!!s;        // true
```

---

## 9) What are “well-known symbols” and why do they matter?

**Answer:**
They are predefined symbols that let you **customize language behaviors** (iteration, coercion, etc.). Common ones:

* `Symbol.iterator` – sync iteration (`for…of`)
* `Symbol.asyncIterator` – async iteration (`for await…of`)
* `Symbol.toStringTag` – branding for `Object.prototype.toString`
* `Symbol.toPrimitive` – customize primitive coercion
* `Symbol.hasInstance` – customize `instanceof`
* `Symbol.match`, `Symbol.replace`, `Symbol.search`, `Symbol.split` – RegExp protocol
* `Symbol.isConcatSpreadable`, `Symbol.species`, `Symbol.unscopables`

---

## 10) Show a custom iterable using `Symbol.iterator`.

**Answer:**

```js
const range = {
  from: 3, to: 5,
  [Symbol.iterator]() {
    let cur = this.from, last = this.to;
    return {
      next() { return { value: cur, done: cur++ > last }; }
    };
  }
};
[...range]; // [3, 4, 5]
```

---

## 11) Show `Symbol.asyncIterator` for async iteration.

**Answer:**

```js
const asyncNums = {
  cur: 1,
  async *[Symbol.asyncIterator]() {
    while (this.cur <= 3) {
      await new Promise(r => setTimeout(r, 50));
      yield this.cur++;
    }
  }
};
for await (const n of asyncNums) console.log(n); // 1,2,3
```

---

## 12) How do you control string/number coercion with `Symbol.toPrimitive`?

**Answer:**

```js
const price = {
  amount: 1999,
  [Symbol.toPrimitive](hint) {
    if (hint === 'number') return this.amount;
    if (hint === 'string') return `$${(this.amount/100).toFixed(2)}`;
    return this.amount; // default
  }
};

+price;          // 1999
String(price);   // "$19.99"
price + 1;       // 2000  (default hint)
```

---

## 13) How is `Symbol.toStringTag` useful?

**Answer:**
Changes the tag used by `Object.prototype.toString.call(obj)`—handy for branding custom types.

```js
const bag = { [Symbol.toStringTag]: 'Bag' };
Object.prototype.toString.call(bag); // "[object Bag]"
```

---

## 14) When would you use symbols instead of strings for “enum” values?

**Answer:**
When you need **guaranteed uniqueness** and want to prevent accidental collisions.

```js
const Status = Object.freeze({
  PENDING: Symbol('PENDING'),
  DONE:    Symbol('DONE')
});

function isDone(s) { return s === Status.DONE; }
```

Caveat: Symbols don’t serialize to JSON; use strings if you must serialize.

---

## 15) Can you polyfill Symbols?

**Answer:**
Not fully. Libraries can **shim** some behaviors, but true Symbol uniqueness and engine support (e.g., well-known symbols) require native implementation.

---

## 16) Do Symbols affect performance?

**Answer:**
They’re comparable to string keys for object property access. The main cost is **creating** a symbol; that’s usually negligible. Choose symbols for **semantics** (uniqueness / hidden keys), not for speed.

---

## 17) How do symbols interact with `Object.defineProperty` and descriptors?

**Answer:**
Exactly like string keys:

```js
const secret = Symbol('secret');
const obj = {};
Object.defineProperty(obj, secret, {
  value: 42, enumerable: false, writable: false
});
Object.getOwnPropertySymbols(obj); // [Symbol(secret)]
```

---

## 18) Will `JSON.stringify` include symbol-keyed properties?

**Answer:**
No, it **skips** symbol keys (and values that are symbols). If you must serialize them, transform first (e.g., map to strings).

---

## 19) How do you iterate symbol keys on an object?

**Answer:**

```js
const syms = Object.getOwnPropertySymbols(obj); // own symbol keys only
for (const s of syms) console.log(s, obj[s]);

// or everything (strings + symbols):
for (const k of Reflect.ownKeys(obj)) console.log(k);
```

---

## 20) What are some practical use cases for Symbols?

**Answer:**

* **Non-colliding property keys** for libraries/mixins/metadata.
* **Opt-in protocols** via well-known symbols (`Symbol.iterator`, etc.).
* **Semi-hidden** fields you don’t want in normal enumeration.
* **Branding/types** with `Symbol.toStringTag`.
* **Custom coercion** with `Symbol.toPrimitive`.

---

If you want, I can bundle these into a quick **Symbol cheatsheet** with runnable snippets and tiny exercises (e.g., implement a custom iterable + toPrimitive) so you can practice fast.
