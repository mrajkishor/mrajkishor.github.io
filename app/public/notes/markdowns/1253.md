

# 📘 Data Structures via JS Objects → Object as HashMap

---

## 1. Why HashMaps Matter in LeetCode  

- Many Leetcode problems require **fast lookups / counting**:  
  - Two Sum  
  - Anagrams  
  - Frequency counters  
  - Prefix/suffix maps  
- A **HashMap** provides **O(1) average time** for `insert`, `delete`, and `lookup`.  

In Node.js, the simplest way to implement a hash map is via **plain objects (`{}`)** or **`Map`**. Here we focus on **Objects**.  

---

## 2. JavaScript Object as HashMap  

```js
let freq = {};
freq["apple"] = 3;
freq["banana"] = 5;

console.log(freq["apple"]);  // 3
console.log("banana" in freq); // true
```

- **Key**: always stored as **string (or symbol)**.  
  - If you use numbers, they get coerced to strings:  
    ```js
    let obj = {};
    obj[1] = "one";
    console.log(obj["1"]); // "one"
    ```  
- **Value**: can be any type (number, array, object, boolean, etc.).  

---

## 3. Common Operations (HashMap Patterns)  

### 🔹 Insert / Update  
```js
let map = {};
map["a"] = 1;
map["b"] = 2;
map["a"] += 1;  // update
```

### 🔹 Check Existence  
```js
if ("a" in map) { ... }
if (map.hasOwnProperty("a")) { ... }
```

### 🔹 Delete  
```js
delete map["a"];
```

### 🔹 Iterate Keys & Values  
```js
for (let key in map) {
  if (map.hasOwnProperty(key)) {
    console.log(key, map[key]);
  }
}

Object.keys(map).forEach(k => console.log(k, map[k]));
```

---

## 4. LeetCode Patterns with Objects as HashMaps  

### ✅ 4.1 Frequency Counter (Anagrams, Substring Problems)  
```js
let freq = {};
for (let ch of "leetcode") {
  freq[ch] = (freq[ch] || 0) + 1;
}
console.log(freq); 
// { l:1, e:3, t:1, c:1, o:1, d:1 }
```

---

### ✅ 4.2 Two Sum Problem  
```js
function twoSum(nums, target) {
  let map = {};
  for (let i = 0; i < nums.length; i++) {
    let complement = target - nums[i];
    if (map[complement] !== undefined) {
      return [map[complement], i];
    }
    map[nums[i]] = i;
  }
}
```
- Uses object as index → O(n) time.  

---

### ✅ 4.3 Group Anagrams  
```js
function groupAnagrams(strs) {
  let map = {};
  for (let s of strs) {
    let key = s.split("").sort().join(""); // canonical form
    if (!map[key]) map[key] = [];
    map[key].push(s);
  }
  return Object.values(map);
}
```

---

### ✅ 4.4 Prefix/Suffix Map (Dynamic Programming, Trie-lite)  
```js
let map = {};
let arr = ["apple", "ape", "bat"];
for (let word of arr) {
  let prefix = word[0];
  if (!map[prefix]) map[prefix] = [];
  map[prefix].push(word);
}
console.log(map);
// { a: ["apple","ape"], b:["bat"] }
```

---

## 5. Performance Analysis  

- **Average Time Complexity**:  
  - Insert: O(1)  
  - Lookup: O(1)  
  - Delete: O(1)  
- **Worst Case**: O(n) (hash collisions), but rare in practice.  

⚠️ **Caveat**: Object keys are **always strings**.  
- Numeric keys are coerced → `"1"` and `1` are the same.  
- To keep numeric keys without coercion → use `Map`.  

---

## 6. Object vs Map  

| Feature              | Object `{}`        | Map |
|----------------------|--------------------|-----|
| Key type             | String / Symbol    | Any (string, number, object) |
| Key order            | Not guaranteed (ES6+ preserves insertion for string keys) | Guaranteed insertion order |
| Iteration            | Must use `for..in` / `Object.keys` | Direct `.forEach`, `.entries` |
| Performance          | Good for small/medium | Better for large datasets |
| Typical LeetCode Use | Frequency maps, Two Sum, Anagrams | Complex keying (e.g. pairs, objects) |

👉 For **LeetCode**, Objects are usually enough because:  
- Inputs are mostly numbers/strings.  
- Less boilerplate compared to `Map`.  

---

## 7. Gotchas  

1. **Prototype Pollution**  
   ```js
   let obj = {};
   console.log(obj["toString"]); // function...
   ```
   - Because `Object` inherits from prototype chain.  
   - Fix: use a null-prototype object for pure hash map:  
     ```js
     let map = Object.create(null);
     ```

2. **Numeric Key Coercion**  
   ```js
   let obj = {};
   obj[1] = "x";
   console.log(obj["1"]); // "x"
   ```
   → Always coerced to string.  

3. **Performance Drop in Very Large HashMaps**  
   - If you expect millions of entries, prefer `Map` for consistency.  

---

## ✅ In Summary  

- In Node.js, **Objects** can be used as **HashMaps** for O(1) lookups.  
- Keys → always strings; values → anything.  
- Use for: **frequency counters, index maps, grouping problems, Two Sum**.  
- Watch out for **numeric coercion** and **prototype keys**.  
- If you need **non-string keys or massive datasets**, use `Map`.  

---



# ⚡ Node.js HashMap Utility (LeetCode Ready)

```javascript
// ===============================
// 📘 HashMap Utilities using Objects
// ===============================

// Create a clean hash map (no prototype pollution)
function createMap() {
  return Object.create(null);
}

// Increment a value (for frequency counting)
function increment(map, key, amount = 1) {
  map[key] = (map[key] || 0) + amount;
}

// Check if a key exists
function exists(map, key) {
  return map[key] !== undefined;
}

// Get a value with a default fallback
function get(map, key, defaultValue = 0) {
  return map[key] !== undefined ? map[key] : defaultValue;
}

// Remove a key
function remove(map, key) {
  delete map[key];
}

// Return all keys
function keys(map) {
  return Object.keys(map);
}

// Return all values
function values(map) {
  return Object.values(map);
}

// Return [key, value] pairs
function entries(map) {
  return Object.entries(map);
}
```

---

## 🔑 Usage Examples

### ✅ Frequency Counter

```javascript
let freq = createMap();
let str = "leetcode";
for (let ch of str) increment(freq, ch);

console.log(freq); 
// { l:1, e:3, t:1, c:1, o:1, d:1 }
```

---

### ✅ Two Sum (Index HashMap)

```javascript
function twoSum(nums, target) {
  let map = createMap();
  for (let i = 0; i < nums.length; i++) {
    let complement = target - nums[i];
    if (exists(map, complement)) {
      return [map[complement], i];
    }
    map[nums[i]] = i;
  }
}
console.log(twoSum([2,7,11,15], 9)); // [0,1]
```

---

### ✅ Group Anagrams

```javascript
function groupAnagrams(strs) {
  let map = createMap();
  for (let s of strs) {
    let key = s.split("").sort().join("");
    if (!exists(map, key)) map[key] = [];
    map[key].push(s);
  }
  return values(map);
}
```

---

### ✅ Remove Keys Safely

```javascript
let cache = createMap();
cache["user1"] = "Alice";
cache["user2"] = "Bob";
remove(cache, "user1");
console.log(cache); // { user2: "Bob" }
```

---

## ✅ Why This is Leetcode-Ready

* **Clean maps** → `Object.create(null)` avoids prototype pollution (`toString`, `__proto__`).
* **Reusable helpers** → increment, exists, get, remove — the most common LeetCode patterns.
* **Optimized for speed** → plain object hash lookups are O(1) average.
* **Covers most problem types** → frequency maps, index maps, grouping.

---



# ⚡ Node.js Bidirectional HashMap Toolkit (LeetCode Ready)

```javascript
// ===============================
// 📘 Bidirectional HashMap Utilities
// ===============================

// Create a clean bidirectional map
function createBiMap() {
  return {
    forward: Object.create(null), // key -> value
    backward: Object.create(null) // value -> key
  };
}

// Set mapping (both directions)
function setBiMap(bimap, key, value) {
  bimap.forward[key] = value;
  bimap.backward[value] = key;
}

// Get value by key
function getForward(bimap, key) {
  return bimap.forward[key];
}

// Get key by value
function getBackward(bimap, value) {
  return bimap.backward[value];
}

// Check if key exists
function hasKey(bimap, key) {
  return bimap.forward[key] !== undefined;
}

// Check if value exists
function hasValue(bimap, value) {
  return bimap.backward[value] !== undefined;
}

// Delete mapping by key
function deleteByKey(bimap, key) {
  const value = bimap.forward[key];
  if (value !== undefined) {
    delete bimap.forward[key];
    delete bimap.backward[value];
  }
}

// Delete mapping by value
function deleteByValue(bimap, value) {
  const key = bimap.backward[value];
  if (key !== undefined) {
    delete bimap.backward[value];
    delete bimap.forward[key];
  }
}
```

---

## 🔑 Usage Examples

### ✅ String Isomorphism (LeetCode #205)

Check if two strings have a one-to-one mapping between characters.

```javascript
function isIsomorphic(s, t) {
  if (s.length !== t.length) return false;

  let map = createBiMap();

  for (let i = 0; i < s.length; i++) {
    let c1 = s[i], c2 = t[i];

    if (hasKey(map, c1)) {
      if (getForward(map, c1) !== c2) return false;
    } else {
      if (hasValue(map, c2)) return false; // already mapped
      setBiMap(map, c1, c2);
    }
  }
  return true;
}
console.log(isIsomorphic("egg", "add")); // true
console.log(isIsomorphic("foo", "bar")); // false
```

---

### ✅ Graph Bidirectional Mapping

Store graph edges with quick lookup both ways.

```javascript
let graph = createBiMap();
setBiMap(graph, "A", "B");
setBiMap(graph, "C", "D");

console.log(getForward(graph, "A"));  // "B"
console.log(getBackward(graph, "B")); // "A"
```

---

### ✅ Word Pattern (LeetCode #290)

Pattern `"abba"` vs words `"dog cat cat dog"`.

```javascript
function wordPattern(pattern, s) {
  let words = s.split(" ");
  if (pattern.length !== words.length) return false;

  let map = createBiMap();

  for (let i = 0; i < pattern.length; i++) {
    let p = pattern[i], w = words[i];

    if (hasKey(map, p)) {
      if (getForward(map, p) !== w) return false;
    } else {
      if (hasValue(map, w)) return false;
      setBiMap(map, p, w);
    }
  }
  return true;
}
console.log(wordPattern("abba", "dog cat cat dog")); // true
console.log(wordPattern("abba", "dog cat cat fish")); // false
```

---

## ✅ Why This is Leetcode-Ready

* **Direct + Reverse Lookup** → O(1) for both directions.
* **Null-prototype maps** → avoids prototype pollution bugs.
* **Perfect for Isomorphism / Bijection problems** (common in Leetcode string + graph questions).
* **Modular helpers** → clean, reusable, less boilerplate.

